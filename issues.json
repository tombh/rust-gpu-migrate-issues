[
  {
    "author": {
      "id": "MDQ6VXNlcjcwMDgzODg=",
      "is_bot": false,
      "login": "JensGM",
      "name": "Jens G√•semyr Magnus"
    },
    "body": "### Expected Behaviour\r\nCompile doesn't fail\r\n\r\n### Example & Steps To Reproduce\r\n\r\n1. Write a shader with a dependency on uom\r\n\r\n## System Info\r\n<!--\r\nHelpful commands:\r\n- Rustc version: `rustc -V`\r\n- SPIR-V version: `spirv-val --version`\r\n-->\r\n\r\n - Rust: rustc 1.74.0-nightly (8ce4540bd 2023-09-29)\r\n - OS: macos 14.5 (23F79)\r\n - GPU: m1 pro\r\n\r\n\r\n## Backtrace\r\n\r\n<details><summary>\r\nUpdating crates.io index                           \r\n     Compiling uom v0.36.0                                                                                        \r\n  thread 'rustc' panicked at /Users/jens/sources/rust-gpu/crates/rustc_codegen_spirv/src/builder/builder_methods.rs:521:34:                                                                                                         \r\n  attempt to divide by zero                              \r\n  stack backtrace:                                       \r\n     0:        0x1052144dc - <std::sys_common::backtrace::_print::DisplayBacktrace as core::fmt::Display>::fmt::h8895b8b562a90ee4                                                                                                   \r\n     1:        0x105267f58 - core::fmt::write::h7a9cc4d1d610bd71                                                  \r\n     2:        0x10520a08c - std::io::Write::write_fmt::h87ff59bc697656ff                                         \r\n     3:        0x10521431c - std::sys_common::backtrace::print::ha692d990665b4a43                                                                                                                                                   \r\n     4:        0x105216f18 - std::panicking::default_hook::{{closure}}::hf23c7dbcec5e5d80                                                                                                                                           \r\n     5:        0x105216c30 - std::panicking::default_hook::h6d5fe0c884e09021                                                                                                                                                        \r\n     6:        0x10d7596fc - <alloc[edcccedc0388b9d1]::boxed::Box<rustc_driver_impl[19b3a9f15fe02931]::install_ice_hook::{closure#0}> as core[49eafda268333cb]::ops::function::Fn<(&dyn for<'a, 'b> core[49eafda268333cb]::ops::func\r\ntion::Fn<(&'a core[49eafda268333cb]::panic::panic_info::PanicInfo<'b>,), Output = ()> + core[49eafda268333cb]::marker::Sync + core[49eafda268333cb]::marker::Send, &core[49eafda268333cb]::panic::panic_info::PanicInfo)>>::call         7:        0x10d7596fc - <alloc[edcccedc0388b9d1]::boxed::Box<rustc_driver_impl[19b3a9f15fe02931]::install_ice_hook::{closure#0}> as core[49eafda268333cb]::ops::function::Fn<(&dyn for<'a, 'b> core[49eafda268333cb]::ops::func\r\ntion::Fn<(&'a core[49eafda268333cb]::panic::panic_info::PanicInfo<'b>,), Output = ()> + core[49eafda268333cb]::marker::Sync + core[49eafda268333cb]::marker::Send, &core[49eafda268333cb]::panic::panic_info::PanicInfo)>>::call\r\n     8:        0x1052176b0 - std::panicking::rust_panic_with_hook::h7c3b2a0098acc318                                                                                                                                                \r\n     9:        0x10521743c - std::panicking::begin_panic_handler::{{closure}}::h5a56c37d4253c5c6                                                                                                                                    \r\n    10:        0x105214968 - std::sys_common::backtrace::__rust_end_short_backtrace::h6240b1fcaf592476                                                                                                                              \r\n    11:        0x1052171e8 - _rust_begin_unwind                                                                   \r\n    12:        0x1052932c0 - core::panicking::panic_fmt::h665dccaf061d2198                                        \r\n    13:        0x105293334 - core::panicking::panic::he1ba182bf716bbc2                                            \r\n    14:        0x106c7099c - rustc_codegen_spirv::builder::builder_methods::<impl rustc_codegen_spirv::builder::Builder>::recover_access_chain_from_offset::he6b0c04ddb3305e7\r\n    15:        0x106c76c2c - rustc_codegen_spirv::builder::builder_methods::<impl rustc_codegen_ssa::traits::builder::BuilderMethods for rustc_codegen_spirv::builder::Builder>::pointercast::h9cc3e414ef1f966a\r\n    16:        0x106c75fe0 - rustc_codegen_spirv::builder::builder_methods::<impl rustc_codegen_ssa::traits::builder::BuilderMethods for rustc_codegen_spirv::builder::Builder>::bitcast::h95bef7ee067e6e52\r\n    17:        0x106c72388 - rustc_codegen_spirv::builder::builder_methods::<impl rustc_codegen_ssa::traits::builder::BuilderMethods for rustc_codegen_spirv::builder::Builder>::ret::hea66e4be1e6f30df\r\n    18:        0x106c37b04 - rustc_codegen_ssa::mir::block::<impl rustc_codegen_ssa::mir::FunctionCx<Bx>>::codegen_terminator::ha5211e4b8b8ed3fc                                                                                    \r\n    19:        0x106c34f08 - rustc_codegen_ssa::mir::codegen_mir::h680cf704b650ab2a                                                                                                                                                 \r\n    20:        0x106cc9080 - rustc_codegen_ssa::base::codegen_instance::hf2c0f9e676c3fe71                                                                                                                                           \r\n    21:        0x106c0e9b4 - <rustc_middle::mir::mono::MonoItem as rustc_codegen_ssa::mono_item::MonoItemExt>::define::hf389f7022ecbfada                                                                                            \r\n    22:        0x106c24f6c - <rustc_codegen_spirv::SpirvCodegenBackend as rustc_codegen_ssa::traits::backend::ExtraBackendMethods>::compile_codegen_unit::{{closure}}::h0218353bb7111ed5\r\n    23:        0x106c2491c - <rustc_codegen_spirv::SpirvCodegenBackend as rustc_codegen_ssa::traits::backend::ExtraBackendMethods>::compile_codegen_unit::h91c26f9a6763dca3\r\n    24:        0x106cc8a9c - rustc_codegen_ssa::base::codegen_crate::h54fbe7881ae09c5c                                                                                                                                              \r\n    25:        0x106c23ccc - <rustc_codegen_spirv::SpirvCodegenBackend as rustc_codegen_ssa::traits::backend::CodegenBackend>::codegen_crate::ha25804fa111ed196\r\n    26:        0x10d8bb7d4 - <rustc_session[8d223c133578b34a]::session::Session>::time::<alloc[edcccedc0388b9d1]::boxed::Box<dyn core[49eafda268333cb]::any::Any>, rustc_interface[698431996f4b6697]::passes::start_codegen::{closur\r\ne#0}>                                                    \r\n    27:        0x10d89dd28 - rustc_interface[698431996f4b6697]::passes::start_codegen                                                                                                                                               \r\n    28:        0x10d8bf5e4 - <rustc_middle[21fd61e7f89d9c73]::ty::context::GlobalCtxt>::enter::<<rustc_interface[698431996f4b6697]::queries::Queries>::ongoing_codegen::{closure#0}, core[49eafda268333cb]::result::Result<alloc[edc\r\nccedc0388b9d1]::boxed::Box<dyn core[49eafda268333cb]::any::Any>, rustc_span[de8f35f4add29872]::ErrorGuaranteed>>\r\n    29:        0x10d88f4a0 - <rustc_interface[698431996f4b6697]::queries::Queries>::ongoing_codegen                                                                                                                                 \r\n    30:        0x10d7860b4 - rustc_span[de8f35f4add29872]::set_source_map::<core[49eafda268333cb]::result::Result<(), rustc_span[de8f35f4add29872]::ErrorGuaranteed>, rustc_interface[698431996f4b6697]::interface::run_compiler<cor\r\ne[49eafda268333cb]::result::Result<(), rustc_span[de8f35f4add29872]::ErrorGuaranteed>, rustc_driver_impl[19b3a9f15fe02931]::run_compiler::{closure#1}>::{closure#0}::{closure#0}>\r\n    31:        0x10d757618 - std[3254da1c1438db11]::sys_common::backtrace::__rust_begin_short_backtrace::<rustc_interface[698431996f4b6697]::util::run_in_thread_with_globals<rustc_interface[698431996f4b6697]::interface::run_comp\r\niler<core[49eafda268333cb]::result::Result<(), rustc_span[de8f35f4add29872]::ErrorGuaranteed>, rustc_driver_impl[19b3a9f15fe02931]::run_compiler::{closure#1}>::{closure#0}, core[49eafda268333cb]::result::Result<(), rustc_span[de\r\n8f35f4add29872]::ErrorGuaranteed>>::{closure#0}::{closure#0}, core[49eafda268333cb]::result::Result<(), rustc_span[de8f35f4add29872]::ErrorGuaranteed>>\r\n    32:        0x10d758738 - <<std[3254da1c1438db11]::thread::Builder>::spawn_unchecked_<rustc_interface[698431996f4b6697]::util::run_in_thread_with_globals<rustc_interface[698431996f4b6697]::interface::run_compiler<core[49eafda\r\n268333cb]::result::Result<(), rustc_span[de8f35f4add29872]::ErrorGuaranteed>, rustc_driver_impl[19b3a9f15fe02931]::run_compiler::{closure#1}>::{closure#0}, core[49eafda268333cb]::result::Result<(), rustc_span[de8f35f4add29872]::\r\nErrorGuaranteed>>::{closure#0}::{closure#0}, core[49eafda268333cb]::result::Result<(), rustc_span[de8f35f4add29872]::ErrorGuaranteed>>::{closure#1} as core[49eafda268333cb]::ops::function::FnOnce<()>>::call_once::{shim:vtable#0}\r\n    33:        0x105220558 - std::sys::unix::thread::Thread::new::thread_start::h86fccd826fc7dcb1                                                                                                                                   \r\n    34:        0x197ecaf94 - __pthread_joiner_wake\r\n</summary>\r\n<p>\r\n\r\n```\r\n<backtrace>\r\n```\r\n\r\n</p>\r\n</details>\r\n",
    "comments": [],
    "createdAt": "2024-05-21T12:17:15Z",
    "labels": [
      {
        "id": "MDU6TGFiZWwyMjI3MzM4ODEz",
        "name": "t: bug",
        "description": "Something isn't working",
        "color": "52E8A0"
      }
    ],
    "number": 1150,
    "reactionGroups": [],
    "state": "OPEN",
    "title": "Compiling uom crashes the compiler",
    "url": "https://github.com/EmbarkStudios/rust-gpu/issues/1150"
  },
  {
    "author": {
      "id": "MDQ6VXNlcjE3Mjg0MzYy",
      "is_bot": false,
      "login": "Makogan",
      "name": "Makogan"
    },
    "body": "Currently, it seems that rustgpu does not support operator overloading (there is no ops module under spirv_std, and none of the examples seem to do this).\r\n\r\nThis is useful because although linear algebra is the most popular mathematical representation for transformations in computer graphics, it is not the only option. \r\n\r\nFor example, I currently use projective geometric algebra for skin animations. To do this I need to define a multivector type on the shader that is capable of addition, multiplication, scalar multiplication...\r\n\r\nOf course, one can work around the issue by defining methods, but this is less ergonomic than having operators. \r\n\r\n",
    "comments": [
      {
        "id": "IC_kwDOENG44858jNBS",
        "author": {
          "login": "FishArmy100"
        },
        "authorAssociation": "NONE",
        "body": "I thought there was a form of operator overloading via glam? Though, I might be mistaken. ",
        "createdAt": "2024-05-02T05:20:57Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/1149#issuecomment-2089603154",
        "viewerDidAuthor": false
      },
      {
        "id": "IC_kwDOENG4485-UWRH",
        "author": {
          "login": "Patryk27"
        },
        "authorAssociation": "NONE",
        "body": "> there is no ops module under spirv_std, and none of the examples seem to do this\r\n\r\nBut there's `core::ops`, no? `spirv_std` is just a couple of extra stuff - it just complements `core`, not replaces it.",
        "createdAt": "2024-05-19T14:49:59Z",
        "includesCreatedEdit": true,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/1149#issuecomment-2119263303",
        "viewerDidAuthor": false
      }
    ],
    "createdAt": "2024-05-01T21:25:10Z",
    "labels": [
      {
        "id": "MDU6TGFiZWwyMjI3MzM4ODE2",
        "name": "t: enhancement",
        "description": "A new feature or improvement to an existing one.",
        "color": "52E8A0"
      }
    ],
    "number": 1149,
    "reactionGroups": [],
    "state": "OPEN",
    "title": "Operator Overlaoding support",
    "url": "https://github.com/EmbarkStudios/rust-gpu/issues/1149"
  },
  {
    "author": {
      "id": "MDQ6VXNlcjE3Mjg0MzYy",
      "is_bot": false,
      "login": "Makogan",
      "name": "Makogan"
    },
    "body": "I would find it useful if rust-builder could be compiled as a static library that could then be invoked from rust, C or C++. This has some possible advantages:\r\n\r\n* Allowing a project using a new toolchain to use rust builder\r\n* Allowing non rust projects to use rust shaders\r\n\r\n\r\n",
    "comments": [],
    "createdAt": "2024-04-14T21:35:40Z",
    "labels": [
      {
        "id": "MDU6TGFiZWwyMjI3MzM4ODE2",
        "name": "t: enhancement",
        "description": "A new feature or improvement to an existing one.",
        "color": "52E8A0"
      }
    ],
    "number": 1144,
    "reactionGroups": [
      {
        "content": "THUMBS_UP",
        "users": {
          "totalCount": 2
        }
      }
    ],
    "state": "OPEN",
    "title": "Allow to compile rust-builder as a static c library with the builder calls exported",
    "url": "https://github.com/EmbarkStudios/rust-gpu/issues/1144"
  },
  {
    "author": {
      "id": "MDQ6VXNlcjE0MTI5NTU3",
      "is_bot": false,
      "login": "sirati",
      "name": "sirati"
    },
    "body": "<!-- Thank you for filing a bug report! üêõ -->\r\n  rustc: spirv-tools/source/opt/optimizer.cpp:66: spvtools::Optimizer::Optimizer(spv_target_env): Assertion `env != SPV_ENV_WEBGPU_0' failed.\r\n\r\n### Expected Behaviour\r\n<!-- Please describe what you expected to happen. -->\r\nproperly compiling\r\n\r\n### Example & Steps To Reproduce\r\n<!-- \r\nDescribe what actually happened, including any relevant examples (smaller\r\nthe better), error messages, or the relevant SPIR-V binary. \r\n-->\r\nresearching this. so far i have nothing but stub methods in my project and this still triggers. dont know if this is a portable bug yet.\r\n\r\n\r\n## System Info\r\n<!--\r\nHelpful commands:\r\n- Rustc version:\r\n- SPIR-V version: apparently not installed, but it cann still run spirv-tools code?!?!??! Installing did not help `spirv-val --version`\r\n-->\r\n\r\n - Rust:  `rustc 1.71.0-nightly (1a5f8bce7 2023-05-26)`\r\n - OS: PopOS\r\n - GPU: Intel(R) UHD Graphics 630\r\n - SPIR-V: apparently not installed, but it cann still run spirv-tools code?!?!??! Installing did not help\r\n\r\n\r\n## Backtrace\r\n<!-- If relevant, please include a backtrace of the error below. -->\r\n\r\n<details><summary>Backtrace</summary>\r\n<p>\r\n\r\n```\r\n/home/sirati/.cargo/bin/cargo check --message-format json --workspace --all-targets -Z unstable-options --keep-going\r\n    Checking ahash v0.8.11\r\n    Checking hashbrown v0.14.3\r\n    Checking indexmap v2.2.6\r\n    Checking gpu-descriptor v0.2.4\r\n    Checking naga v0.19.2\r\n    Checking civ3-renderer-shaders v0.1.0 (/home/sirati/RustroverProjects/Civ3Renderer/shaders)\r\n   Compiling Civ3Renderer v0.1.0 (/home/sirati/RustroverProjects/Civ3Renderer)\r\n    Checking wgpu-hal v0.19.3\r\n    Checking wgpu-core v0.19.3\r\n    Checking wgpu v0.19.3\r\nerror: failed to run custom build command for `Civ3Renderer v0.1.0 (/home/sirati/RustroverProjects/Civ3Renderer)`\r\nerror: failed to run custom build command for `Civ3Renderer v0.1.0 (/home/sirati/RustroverProjects/Civ3Renderer)`\r\nnote: To improve backtraces for build dependencies, set the CARGO_PROFILE_DEV_BUILD_OVERRIDE_DEBUG=true environment variable to enable debug information generation.\r\nCaused by:\r\n  process didn't exit successfully: `/home/sirati/RustroverProjects/Civ3Renderer/target/debug/build/Civ3Renderer-da0432a522988ca8/build-script-build` (exit status: 1)\r\n  --- stdout\r\n  cargo:rerun-if-env-changed=RUSTGPU_CODEGEN_ARGS\r\n  cargo:rerun-if-env-changed=RUSTGPU_RUSTFLAGS\r\n  --- stderr\r\n     Compiling civ3-renderer-shaders v0.1.0 (/home/sirati/RustroverProjects/Civ3Renderer/shaders)\r\n  rustc: spirv-tools/source/opt/optimizer.cpp:66: spvtools::Optimizer::Optimizer(spv_target_env): Assertion `env != SPV_ENV_WEBGPU_0' failed.\r\n  error: could not compile `civ3-renderer-shaders` (lib)\r\n  Error: BuildFailed\r\n\r\n```\r\n\r\n</p>\r\n</details>\r\n",
    "comments": [],
    "createdAt": "2024-04-05T23:00:44Z",
    "labels": [
      {
        "id": "MDU6TGFiZWwyMjI3MzM4ODEz",
        "name": "t: bug",
        "description": "Something isn't working",
        "color": "52E8A0"
      }
    ],
    "number": 1141,
    "reactionGroups": [],
    "state": "OPEN",
    "title": "spirv-tools: Assertion `env != SPV_ENV_WEBGPU_0' failed.(my bug report)",
    "url": "https://github.com/EmbarkStudios/rust-gpu/issues/1141"
  },
  {
    "author": {
      "id": "MDQ6VXNlcjM2ODkwNA==",
      "is_bot": false,
      "login": "LegNeato",
      "name": "Christian Legnitto"
    },
    "body": "When setting `#[spirv(fragment)]` on a non-pub function, rust-gpu errors with an obtuse error:\r\n\r\n```\r\nerror: error:0:0 - No OpEntryPoint instruction was found. This is only allowed if the Linkage capability is being used.\r\n```\r\n\r\nThis case should be detected and warned or even made an error if it is not supported. Further, the error message should be fixed as suggested in https://github.com/EmbarkStudios/rust-gpu/issues/1139.",
    "comments": [
      {
        "id": "IC_kwDOENG44854tsjX",
        "author": {
          "login": "LegNeato"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "From discord eddyb says:\r\n\r\n> to add context to this, it's silly like this because specifically the #[spirv(...)] attributes that denote an entry-point are only processed when that function is codegen'd. this also means you can probably cause it to be monomorphized more than once if you do weird things with calling it from other functions :/",
        "createdAt": "2024-03-28T13:54:37Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/1140#issuecomment-2025244887",
        "viewerDidAuthor": false
      }
    ],
    "createdAt": "2024-03-26T15:36:56Z",
    "labels": [
      {
        "id": "MDU6TGFiZWwyMjI3MzM4ODE2",
        "name": "t: enhancement",
        "description": "A new feature or improvement to an existing one.",
        "color": "52E8A0"
      }
    ],
    "number": 1140,
    "reactionGroups": [],
    "state": "OPEN",
    "title": "Warn (or error) on a non-pub entrypoint",
    "url": "https://github.com/EmbarkStudios/rust-gpu/issues/1140"
  },
  {
    "author": {
      "id": "MDQ6VXNlcjM2ODkwNA==",
      "is_bot": false,
      "login": "LegNeato",
      "name": "Christian Legnitto"
    },
    "body": "Currently the `rust-gpu` error messages are super obtuse and require understanding of both graphics programming and the underlying apis like vulkan. They are not written for humans to understand and while useful don't meet the high bar that rustc has set. For example, this is the error message when you use a built-in variable that is only valid for vertex shaders in a fragment shader:\r\n\r\n```\r\nerror: error:0:0 - [VUID-Position-Position-04318] Vulkan spec allows BuiltIn Position to be used only with Vertex, TessellationControl, TessellationEvaluation or Geometry execution models. ID <15> (OpLoad) is referencing ID <2> (OpVariable) which is decorated with BuiltIn Position in function <1> called with execution model Fragment.\r\n         %15 = OpLoad %v4float %frag_coord\r\n```\r\n\r\nInstead of an issue this might be more a project, let me know if you want me to write a RFC with concrete suggestions and a plan to make these great.\r\n\r\n",
    "comments": [
      {
        "id": "IC_kwDOENG44854cox6",
        "author": {
          "login": "LegNeato"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "Another:\r\n\r\nWhen you don't declare an entrypoint pub you get:\r\n\r\n```\r\nerror: error:0:0 - No OpEntryPoint instruction was found. This is only allowed if the Linkage capability is being used.\r\n```",
        "createdAt": "2024-03-26T15:38:20Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/1139#issuecomment-2020772986",
        "viewerDidAuthor": false
      }
    ],
    "createdAt": "2024-03-26T15:34:16Z",
    "labels": [
      {
        "id": "MDU6TGFiZWwyMjI3MzM4ODE2",
        "name": "t: enhancement",
        "description": "A new feature or improvement to an existing one.",
        "color": "52E8A0"
      }
    ],
    "number": 1139,
    "reactionGroups": [],
    "state": "OPEN",
    "title": "Make error messages more human",
    "url": "https://github.com/EmbarkStudios/rust-gpu/issues/1139"
  },
  {
    "author": {
      "id": "MDQ6VXNlcjc3NDI0",
      "is_bot": false,
      "login": "eddyb",
      "name": "Eduard-Mihai Burtescu"
    },
    "body": "I was looking at minimal shader `Cargo.toml`s and they're often mainly:\r\n```toml\r\n[dependencies]\r\nspirv-std = \"0.9.0\"\r\n```\r\n\r\n---\r\n\r\nIn the past (e.g. https://github.com/EmbarkStudios/rust-gpu/issues/911#issuecomment-1220547953) any speculation was focused on the backend (`rustc_codegen_spirv`) being built in some way tied to whatever interface (e.g. `spirv-builder`, or some future CLI) was being used to actually build, and therefore their versions being tied.\r\n\r\nFor example we thought maybe we could have a way to \"install Rust-GPU 0.123.0\" but then you will have to install a new one every Rust-GPU release, and anyone who wants to interact with your shader crates has to do the same etc.\r\n\r\nAlso, as big as it is, the (still unmerged) PR I made on a whim a few months ago _also_ has that limitation:\r\n- https://github.com/EmbarkStudios/rust-gpu/pull/1103\r\n\r\n---\r\n\r\nBut what if we _instead_ made a *future-compatible* tool (usable as build dep/CLI/etc.) that:\r\n1. used `cargo_metadata` to understand the shader's dependency graph (from `Cargo.toml`, workspace etc.)\r\n   - in hot-reload mode, this would add more latency but at the same time we probably do want more visibility into stuff like that, and ideally it could be used in such a way that changing _only_ the source code is much faster\r\n2. expects _exactly one_ `spirv-std` dependency, and uses it to get the actual toolchain+backend\r\n   - wrt #1103:\r\n     - this is actually _very_ similar to that PR, just `spirv-std` instead of `spirv-builder`\r\n     - in theory, there's not much stopping us from having `spirv-std`'s build script build the backend, or anything that silly, I would just be worried about making it too much a house of cards\r\n   - an important consequence is that _any path/git rev/crates.io version_ dependency for `spirv-std` would work (just like the PR which does this for `spirv-build`)\r\n     - this is important to avoid impeding testing! (unlike \"install a Rust-GPU version\" workflows)\r\n3. gets the toolchain it wants with `rustup` and builds the right version of `rustc_codegen_spirv`\r\n   - (again this is the same as the PR that does all that in `spirv-builder`'s build script)\r\n   - another potential advantage is that dependening on how this is done, it could let it show progress for that slower part of the build (though if you were using build scripts you'd have the same problem again, I think?)\r\n4. expose e.g. Cargo subcommands, with the env vars set to get you a Rust-GPU build\r\n   - this could potentially mean `cargo gpu check` / `cargo gpu clippy`! (tricky to expose right now)\r\n5. ???\r\n6. profit\r\n   - more seriously, it would be nice if we could have a \"safe hot-reload\" interface eventually, where the build script \"freezes\" your shader interface and generates Rust types/impls so you can safely fill compatible buffers, and also generating the Rust code for a hot-reloading convenience that forces that \"frozen interface\" to keep matching (i.e. rebuild the app itself if you want to change the interface incompatibly)\r\n\r\n---\r\n\r\nI'm not sure if I've heard this kind of \"dependency consequence inversion\" being used anywhere - usually libraries might be driven by compiler versions, not the other way around. <sub>If anyone had suggested this for Rust-GPU in the past, I apologize for being unfamiliar with your game because all my other ideas until now have been mediocre compromises at bets.</sub>\r\n\r\n---\r\n\r\n**EDIT1**: forgot to mention an incidental source of inspiration - back around Rust-GPU `0.4` (which had to change how `#[spirv(...)]` works due to upstream `rustc` changes), we considered making `spirv-std-macros` turn `#[spirv(foo)]` into `#[rust_gpu_0_9_0_git9d8095177::spirv_foo]` (or some other kind of verbose encoding of a version) - and once you have that kind of \"self-awareness\" in `spirv-std` about the backend version it wants, a build tool can pull that out. <sub>(stricter checks around that would've saved me from some confusing build failures just earlier, which is probably why it was on my mind)</sub>\r\n\r\n---\r\n\r\n**EDIT2**: in theory, this is comparable to if Rust itself let you do:\r\n```toml\r\n[dependencies]\r\nstd = \"1.79.0\"\r\n```\r\nand have that act as a `rust-toolchain.toml` replacement. <sub>(likely unviable without replacing (parts of) `rustup`+`cargo`+`rustc` CLIs all at once with a combined `rust` one or something similarly extreme)</sub>\r\n\r\nActually, if we allow more \"conceptual\" dependencies, the comparison becomes\r\n```toml\r\n[dependencies]\r\nrust = \"1.79.0\"\r\nrust-gpu = \"0.123.0\"\r\n```\r\nAnd we do have the `rust-gpu` package on `crates.io` so that could be used instead of `spirv-std` to be more explicit (and then \"namespaced dependencies\" like `rust-gpu/spirv-std`, or really `rust_gpu::spirv_std` could exist? also the attribute could then not have to go into `spirv-std` etc.)",
    "comments": [
      {
        "id": "IC_kwDOENG44851NQAv",
        "author": {
          "login": "LegNeato"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "Look who has `cargo-gpu` on crates.io...a couple steps ahead of you üòÑ ",
        "createdAt": "2024-02-27T12:09:42Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [
          {
            "content": "EYES",
            "users": {
              "totalCount": 2
            }
          }
        ],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/1137#issuecomment-1966407727",
        "viewerDidAuthor": false
      },
      {
        "id": "IC_kwDOENG44851nltG",
        "author": {
          "login": "LegNeato"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "Food for thought, though I don't want this to be come like JS where every tool has its own config file, having a `GPU.toml` or whatever might be a better route.",
        "createdAt": "2024-03-01T14:35:14Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/1137#issuecomment-1973312326",
        "viewerDidAuthor": false
      },
      {
        "id": "IC_kwDOENG44851pLn6",
        "author": {
          "login": "eddyb"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "See https://doc.rust-lang.org/cargo/reference/manifest.html#the-metadata-table\n\nWith `[package.metadata.rust-gpu.*]` we could configure anything beyond what we can with just dependencies.\n\nAnd you have to keep in mind that we can't remove the `spirv-std` dependency being explicit for several reasons (e.g. users wanting to compile common code, or even the entire shader, as a regular dependency of host code, or me wanting to have access to the breadth of Cargo path/git dependency/override specifiers.",
        "createdAt": "2024-03-01T18:38:05Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "users": {
              "totalCount": 2
            }
          }
        ],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/1137#issuecomment-1973729786",
        "viewerDidAuthor": false
      },
      {
        "id": "IC_kwDOENG44851qd7Q",
        "author": {
          "login": "charles-r-earp"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "[krnl](https://github.com/charles-r-earp/krnl) has krnlc, which includes rustc_codgen_spirv into the binary and at runtime copies it back to the target dir. I found I had to sym link the rust sys root libs as well. So that's a working example of a cli instead of a builder / build script. \r\n\r\nIt does something similar to what @eddyb describes with spirv-std, krnl has krnl-core which links to spirv-std, and krnlc looks for krnl-core via cargo_metadata, checks that the version is compatible, and copies that dependency into the generated Cargo.toml for the device crate. This ensures that host and device crates have identical krnl-core / krnl-macros versions. Macros are used to generate host / device bindings, so identical versions means that the private interface can be unstable.\r\n\r\nOne thing that is somewhat awkward is needing to install krnlc with a specific nightly version, so that it isn't as easy to update and it's more cumbersome to mix two different versions. The spirv-builder dependency means krnlc has to have its own workspace.\r\n\r\nConsidering that rust-gpu requires a specific nightly, I'm not sure it would make sense to have something like krnlc be installable on stable or even just nightly, but it could. So if rust-gpu handled installing the required nightly + components + rustc_codegen_spirv, that makes it easier for other tools like krnlc or naga to use it. \r\n",
        "createdAt": "2024-03-01T23:27:01Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "users": {
              "totalCount": 1
            }
          }
        ],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/1137#issuecomment-1974066896",
        "viewerDidAuthor": false
      },
      {
        "id": "IC_kwDOENG4486TElVN",
        "author": {
          "login": "schell"
        },
        "authorAssociation": "NONE",
        "body": "> So if rust-gpu handled installing the required nightly + components + rustc_codegen_spirv, that makes it easier for other tools like krnlc or naga to use it.\r\n\r\n@charles-r-earp Just an FYI than the new [cargo-gpu](https://github.com/rust-gpu/cargo-gpu) does almost all of this. You still need to install nightly and components before hand, but I'll fix that tomorrow. \r\n\r\nI ran into [this problem](https://github.com/Rust-GPU/rust-gpu/issues/22) when running `cargo-gpu` in my CI, so a fix is important. I think using the `cargo-gpu` cache dir `$CACHE_DIR/rust-gpu/{dep_prefix}+{nightly_channel}` would be a good place to put these files. `cargo-gpu` can put the files in place and maybe we could pass a parameter to `spirv-builder` to tell it where to look, and if omitted it would fall back to the current behavior? \r\n\r\n ",
        "createdAt": "2024-11-11T07:49:21Z",
        "includesCreatedEdit": true,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/1137#issuecomment-2467452237",
        "viewerDidAuthor": false
      }
    ],
    "createdAt": "2024-02-27T08:47:30Z",
    "labels": [],
    "number": 1137,
    "reactionGroups": [],
    "state": "OPEN",
    "title": "Consider build CLI (e.g. `cargo gpu`) mapping `spirv-std` deps to toolchain & backend versions.",
    "url": "https://github.com/EmbarkStudios/rust-gpu/issues/1137"
  },
  {
    "author": {
      "id": "MDQ6VXNlcjc3NDI0",
      "is_bot": false,
      "login": "eddyb",
      "name": "Eduard-Mihai Burtescu"
    },
    "body": "We've known for a while that the existing inliner+`mem2reg` setup can lead to long compile times (e.g. #851), but we've never had a simple stress test to measure that behavior and e.g. validate potential solutions against, only full projects.\r\n\r\nThankfully, @schell published a `crabslab` crate with a `#[derive(...)]` proc macro which generates what is effectively a \"shallow deserialization from GPU buffer\" method, and [I was able to turn that into a benchmark](https://gist.github.com/eddyb/484c8828f4e4d5a57c22d7c564215385/fa7b3b148928f53db0159e5f0992b6ec867019fb):\r\n\r\n|                       |   O(_‚Åø) | `n=4` | `n=5` | `n=6` | `n=7` |  `n=8` | `n=9`\r\n|----------------------:|--------:|-------|-------|-------|-------|--------|------\r\n|                 total | O(3.3‚Åø) | 0.664 | 0.965 | 2.135 | 9.124 | 46.472 | 247.335\r\n| post-inline `mem2reg` | O(5.4‚Åø) | 0.054 | 0.245 | 1.173 | 7.584 | 43.371 | 239.904\r\n|           `spirv-opt` | O(2.2‚Åø) | 0.081 | 0.169 | 0.351 | 0.767 |  1.783 | 4.397\r\n|                inline | O(3.4‚Åø) |     0 | 0.007 | 0.020 | 0.067 |  0.234 | 0.959\r\n|      SPIR-V -> SPIR-T |   O(2‚Åø) | 0.005 | 0.008 | 0.014 | 0.032 |  0.071 | 0.167\r\n\r\nIf you don't mind the very rudimentary curve-fitting (also I've simplified the rows from the `-Z time-passes` names), what you should be able to notice is there are two trends:\r\n- `~2‚Åø`: the amount of SPIR-V generated (as observed by `SPIR-V -> SPIR-T` and `spirv-opt`)\r\n  - this is intended for this test: there should be 2‚Åø leaf calls generated and inlined\r\n  - the inliner itself should also fit here but it's not bottom-up so presumably has extra inefficiencies\r\n    - while working on the fix, I saw the amount of debuginfo generated, that is likely a lot of the cost\r\n- `>4‚Åø`: post-inline `mem2reg` is at least `(2‚Åø)¬≤`, i.e. _quadratic_ (or worse) in the amount of SPIR-V\r\n  - we more or less knew this, but this test is simple enough that it _shouldn't_ have any `mem2reg` work left!\r\n\r\nWhat happened? We forgot to switch the inliner over to `OpPhi`s for its return value dataflow, so to this day it generates `OpVariable`s (w/ `OpStore`s replacing callee returns, and `OpLoad`s at call site):\r\nhttps://github.com/EmbarkStudios/rust-gpu/blob/8678d58d61a78f01201ec854cb5e3835c014fa3b/crates/rustc_codegen_spirv/src/linker/inline.rs#L658-L664\r\n\r\nSome quick hacky test (using `OpUndef`), for two known projects, ended up making `mem2reg`:\r\n- _**15x faster**_ (~`730s` -> ~`50s`) for @hatoo's `rene`\r\n  - see also #851\r\n  - **EDIT**: initially this said \"3x\" but that was an invalid comparison and Rust-GPU `main` is really slow\r\n- _**30x faster**_ (~`150s` -> ~`5s`) on @schell's more recent `renderling` (at https://github.com/schell/renderling/commit/d9f4d6fa485b238bc00ba01a6e1c7119319b5cbd)\r\n\r\n<sub>(that is, if we fix this bug, it could bring some projects from minutes to seconds - for them, `mem2reg` was spinning its wheels that entire time, due to those `OpVariable`s generated by the inliner, instead of actually helping)</sub>\r\n\r\n---\r\n\r\nSince this is caused by the inliner itself, and we have to force-inline calls taking pointers into buffers (due to SPIR-V not allowing them to be passed to calls), [I repro'd with just `#[derive(Clone)]`](https://gist.github.com/eddyb/484c8828f4e4d5a57c22d7c564215385/d7071e59fa6f3cce6984a76e524b8086025d96da) too:\r\n|                       |   O(_‚Åø) | `n=4` | `n=5` | `n=6` | `n=7` | `n=8` | `n=9`\r\n|----------------------:|--------:|-------|-------|-------|-------|-------|------\r\n|                 total | O(1.7‚Åø) | 0.543 | 0.567 | 0.625 | 0.875 | 1.952 | 7.683\r\n| post-inline `mem2reg` | O(4.8‚Åø) |     0 | 0.013 | 0.059 | 0.264 | 1.225 | 6.695\r\n|           `spirv-opt` | O(1.9‚Åø) | 0.009 | 0.012 | 0.022 | 0.046 | 0.096 | 0.204\r\n|                inline |   O(3‚Åø) |     0 |     0 |     0 | 0.009 | 0.024 | 0.080\r\n|      SPIR-V -> SPIR-T | O(1.7‚Åø) | 0.003 | 0.004 | 0.007 | 0.010 | 0.019 | 0.047\r\n\r\nThat one is fast enough that it deserved more columns, but I'm not messing with `jq`/sorting any further.\r\n\r\nThere is, however, a _very_ compact testcase that can be generated from it:\r\n```rust\r\n#[derive(Clone)]\r\npub struct D<T>(T, T);\r\ntype D4<T> = D<D<D<D<T>>>>;\r\ntype D12<T> = D4<D4<D4<T>>>;\r\n\r\n#[spirv(fragment)]\r\npub fn fs_main(\r\n    #[spirv(storage_buffer, descriptor_set = 0, binding = 0)] buf: &D12<f32>,\r\n    out: &mut D12<f32>,\r\n) {\r\n    *out = buf.clone();\r\n}\r\n```\r\n- on `main`, it takes `692s` (~`11.5min`) in `mem2reg`, and ~`11.7s` _everywhere else_\r\n- with the local hacky workaround, it's down to ~`6.2s` _in total_\r\n  - alright, that should be impossible, even the inlining is faster, the hack is doing too much\r\n  - then again, variables _do_ require weirder handling, and the inliner isn't bottom-up, so maybe?\r\n  - either way, anywhere between 6 and 12 seconds _should_ be possible with the true `OpPhi` fix\r\n\r\nAnd if a 100x speedup isn't impressive enough (or 11-12 minutes not slow enough for a CI timeout), you can always bump it further: a `type D13<T> = D<D12<T>>;` should still take less than a minute once fixed, but anywhere from 45 minutes _to a whole hour_ on `main` (I am not further delaying this issue just to prove that, though).",
    "comments": [],
    "createdAt": "2024-02-20T10:38:57Z",
    "labels": [],
    "number": 1136,
    "reactionGroups": [
      {
        "content": "HOORAY",
        "users": {
          "totalCount": 8
        }
      },
      {
        "content": "HEART",
        "users": {
          "totalCount": 6
        }
      }
    ],
    "state": "OPEN",
    "title": "Inliner->`mem2reg` can quadratically amplify already-exponential inlining (turning seconds into minutes).",
    "url": "https://github.com/EmbarkStudios/rust-gpu/issues/1136"
  },
  {
    "author": {
      "id": "U_kgDOBX1o4g",
      "is_bot": false,
      "login": "pyranota",
      "name": "pyranota"
    },
    "body": "**EDIT**(@eddyb): while there are reasons to _avoid_ such arrays, the slowdown is the immediate Rust-GPU bug - I've left unchanged the original text, but used ~~strikethrough~~ for parts that don't apply, IMO.\r\n\r\n---\r\n\r\n~~User should not be able to create large sized arrays in rust-gpu shaders.~~\r\n~~Stack is limited, and large sized data-structures should be moved in buffers.~~\r\nPlus it makes compilation incredibly slow (I assume this syntax [0; SIZE] translates to spirv's [0, 0, 0, 0, 0, ... SIZE])\r\n\r\n### Expected Behaviour\r\n~~spirv-builder should throw an error, when user creates large array in stack~~\r\n\r\n### Example & Steps To Reproduce\r\n1. Setup basic rust-gpu shader \r\n2. `let arr = [0; 32 * 1024];`\r\n3. `cargo build`\r\n\r\n## System Info\r\n - Rust: rustc 1.75.0 (82e1608df 2023-12-21)\r\n - OS: Pop!_OS\r\n - GPU: nvidia 1060\r\n - SPIR-V: SPIRV-Tools v2022.2-dev unknown hash, 2022-02-16T16:37:15\r\n\r\n\r\n",
    "comments": [
      {
        "id": "IC_kwDOENG44850eQa7",
        "author": {
          "login": "eddyb"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "I suspect `let mut array = [0; 32 * 1024];` is worse than something like:\r\n```rust\r\nlet mut array = MaybeUninit::<[_; 32 * 1024]>::zeroed().assume_init();\r\n// or `core::mem::zeroed`?\r\n```\r\nI _think_ we have an optimization for e.g. `memset(0)`, but not `[expr; N]`.\r\n(haven't checked the code though, but it could be as simple as using the better approach in more places)",
        "createdAt": "2024-02-20T12:14:25Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/1132#issuecomment-1954088635",
        "viewerDidAuthor": false
      },
      {
        "id": "IC_kwDOENG44850eikk",
        "author": {
          "login": "pyranota"
        },
        "authorAssociation": "NONE",
        "body": "Thank you for correction, @eddyb ",
        "createdAt": "2024-02-20T12:57:44Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/1132#issuecomment-1954162980",
        "viewerDidAuthor": false
      }
    ],
    "createdAt": "2024-02-11T13:28:58Z",
    "labels": [
      {
        "id": "MDU6TGFiZWwyMjI3MzM4ODEz",
        "name": "t: bug",
        "description": "Something isn't working",
        "color": "52E8A0"
      }
    ],
    "number": 1132,
    "reactionGroups": [],
    "state": "OPEN",
    "title": "Large array variable initialization (`let arr = [0; 32 * 1024];`) compiles very slowly.",
    "url": "https://github.com/EmbarkStudios/rust-gpu/issues/1132"
  },
  {
    "author": {
      "id": "U_kgDOCHvjnw",
      "is_bot": false,
      "login": "gl-yziquel",
      "name": ""
    },
    "body": "Currently, the 0.9.0 release on crates.io instructs to use a toolchain which forbids me to use cargo:\r\n\r\n```console\r\nmini-me@virtucon ~/h/s/mud-rust-gpu (develop)> cargo clean\r\nerror: the 'cargo' binary, normally provided by the 'cargo' component, is not applicable to the 'nightly-2023-05-27-x86_64-unknown-linux-gnu' toolchain\r\n```\r\n\r\nBetter instructions would be useful.\r\n\r\nSee here for the spirv-builder crate on crates-io:\r\n\r\nhttps://crates.io/crates/spirv-builder",
    "comments": [],
    "createdAt": "2024-01-17T12:41:20Z",
    "labels": [
      {
        "id": "MDU6TGFiZWwyMjI3MzM4ODE2",
        "name": "t: enhancement",
        "description": "A new feature or improvement to an existing one.",
        "color": "52E8A0"
      }
    ],
    "number": 1117,
    "reactionGroups": [],
    "state": "OPEN",
    "title": "Cargo component not available with nightly 2023-05-27 which is publicised on crates.io",
    "url": "https://github.com/EmbarkStudios/rust-gpu/issues/1117"
  },
  {
    "author": {
      "id": "MDQ6VXNlcjMzMzU3MTM4",
      "is_bot": false,
      "login": "DGriffin91",
      "name": "Griffin"
    },
    "body": "I noticed that a rust gpu shader was running much slower than the equivalent wgsl one. \r\nThe wgsl one takes 53ms, and the rust gpu version takes 67ms. \r\nLooking at the SPIRV I tracked part of the issue down to this:\r\n```rs\r\nif uvt.x > 0.0 && uvt.y > 0.0 && uvt.z > 0.0 && uvt.x + uvt.y < 1.0 {\r\n    uvt\r\n} else {\r\n    vec3(f32::MAX, f32::MAX, f32::MAX)\r\n}\r\n```\r\nI used spirv-cross to look at the code rust-gpu was producing in glsl and noticed it was producing this:\r\n```glsl\r\nif (_1039 > 0.0)\r\n{\r\n    bool _1057;\r\n    bool _1058;\r\n    if (_1040 > 0.0)\r\n    {\r\n        bool _1047 = _1041 > 0.0;\r\n        bool _1053;\r\n        if (_1047)\r\n        {\r\n            _1053 = fma(_1028, _1023, _1040) < 1.0;\r\n        }\r\n        else\r\n        {\r\n            _1053 = _76;\r\n        }\r\n        _1057 = _1053;\r\n        _1058 = _1047 ? false : true;\r\n    }\r\n    else\r\n    {\r\n        _1057 = _76;\r\n        _1058 = true;\r\n    }\r\n    _1061 = _1057;\r\n    _1062 = _1058;\r\n}\r\nelse\r\n{\r\n    _1061 = _76;\r\n    _1062 = true;\r\n}\r\n```\r\n\r\nWhereas if I take wgsl through the same path (wgsl -> spirv -> glsl) it looks like this:\r\n```glsl\r\nif ((((_87.x > 0.0) && (_87.y > 0.0)) && (_87.z > 0.0)) && ((_87.x + _87.y) < 1.0)) {\r\n    return _87;\r\n} else {\r\n    return vec3(F32MAX);\r\n}\r\n```\r\n\r\nI tried forcing it to not branch but generate a bool, with `u32(uvt.x > 0.0 && uvt.y > 0.0 && uvt.z > 0.0 && uvt.x + uvt.y < 1.0) == 1`, and while it kept the conversion and the equality check, it still had this same nested branching structure.\r\n\r\nI then tried this which got me a lot closer to the wgsl perf (now 58ms):\r\n```rs\r\nif (uvt.x > 0.0) as u32\r\n    & (uvt.y > 0.0) as u32\r\n    & (uvt.z > 0.0) as u32\r\n    & (uvt.x + uvt.y < 1.0) as u32\r\n    == 1\r\n{\r\n    uvt\r\n} else {\r\n    vec3(f32::MAX, f32::MAX, f32::MAX)\r\n}\r\n```\r\n\r\nThis actually results in it using mix here:\r\n```rs\r\nmix(vec3(F32MAX), vec3(_1024, _1025, _1026), bvec3((((uint(_1024 > 0.0) & uint(_1025 > 0.0)) & uint(_1026 > 0.0)) & uint(fma(_1013, _1008, _1025) < 1.0)) == 1u)).y;\r\n```\r\n\r\nIs it possible to improve the code generation in rust gpu to avoid the excessive branching in situations like this?\r\n\r\n(I'm aware that this could also be written differently to avoid branching, I'm not concerned about this specific impl, but about the code generation in general)",
    "comments": [
      {
        "id": "IC_kwDOENG4485vcOO8",
        "author": {
          "login": "ickk"
        },
        "authorAssociation": "NONE",
        "body": "does it improve after running through spirv-opt?",
        "createdAt": "2023-12-26T17:08:06Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/1110#issuecomment-1869669308",
        "viewerDidAuthor": false
      },
      {
        "id": "IC_kwDOENG4485vclbW",
        "author": {
          "login": "DGriffin91"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "@ickk rust-gpu uses spirv-opt, so no unfortunately.",
        "createdAt": "2023-12-26T20:45:35Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/1110#issuecomment-1869764310",
        "viewerDidAuthor": false
      },
      {
        "id": "IC_kwDOENG4485vcljE",
        "author": {
          "login": "DGriffin91"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "It seems like the best option currently it do write it like:\r\n`if (uvt.x > 0.0) & (uvt.y > 0.0) & (uvt.z > 0.0) & (uvt.x + uvt.y < 1.0) {`\r\n[Discussion on discord](https://discord.com/channels/750717012564770887/1186047991065346240/1186941332598571099)\r\n\r\n",
        "createdAt": "2023-12-26T20:46:57Z",
        "includesCreatedEdit": true,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "users": {
              "totalCount": 1
            }
          }
        ],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/1110#issuecomment-1869764804",
        "viewerDidAuthor": false
      }
    ],
    "createdAt": "2023-12-18T19:06:07Z",
    "labels": [
      {
        "id": "MDU6TGFiZWwyMjI3MzM4ODEz",
        "name": "t: bug",
        "description": "Something isn't working",
        "color": "52E8A0"
      }
    ],
    "number": 1110,
    "reactionGroups": [],
    "state": "OPEN",
    "title": "Conditionals and code generation performance",
    "url": "https://github.com/EmbarkStudios/rust-gpu/issues/1110"
  },
  {
    "author": {
      "id": "MDQ6VXNlcjc2NzU4NDc=",
      "is_bot": false,
      "login": "JulianKnodt",
      "name": "Julian Knodt"
    },
    "body": "I was hoping to learn how to write rust-gpu shaders, so I was going through the tutorial, and have to run the CPU version on my old mac air.\r\n\r\nI think for rendering, it may be useful to include images, as I'm not sure if this output looks correct:\r\n\r\n<img width=\"1284\" alt=\"image\" src=\"https://github.com/EmbarkStudios/rust-gpu/assets/7675847/2c984d42-03bc-46fe-ba0a-5db2ba270117\">\r\n\r\nSpecifically it may be useful to include an image after the initial build steps to make sure that it's running correctly.",
    "comments": [
      {
        "id": "IC_kwDOENG44850jQKg",
        "author": {
          "login": "ARez2"
        },
        "authorAssociation": "NONE",
        "body": "Really late reply, but this looks like you are just outputting the sun in the sky example. This looks like the output when I was testing the hot reloading and removed the added sky color at the end of the shader\r\n(something like `lin + l0` is what it _should_ say)",
        "createdAt": "2024-02-20T23:51:25Z",
        "includesCreatedEdit": true,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "users": {
              "totalCount": 1
            }
          }
        ],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/1108#issuecomment-1955398304",
        "viewerDidAuthor": false
      },
      {
        "id": "IC_kwDOENG44850syMX",
        "author": {
          "login": "JulianKnodt"
        },
        "authorAssociation": "NONE",
        "body": "at this point completely forgot what I was doing, but I'm pretty sure I didn't edit any of the shaders, it's just the output looked wrong after following the tutorial so I had no idea what was happening.",
        "createdAt": "2024-02-21T20:54:09Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/1108#issuecomment-1957896983",
        "viewerDidAuthor": false
      }
    ],
    "createdAt": "2023-12-16T19:14:48Z",
    "labels": [
      {
        "id": "MDU6TGFiZWwyMjI3MzM4ODE2",
        "name": "t: enhancement",
        "description": "A new feature or improvement to an existing one.",
        "color": "52E8A0"
      }
    ],
    "number": 1108,
    "reactionGroups": [],
    "state": "OPEN",
    "title": "Improve documentation to include visual of what example app should look like?",
    "url": "https://github.com/EmbarkStudios/rust-gpu/issues/1108"
  },
  {
    "author": {
      "id": "MDQ6VXNlcjM2ODkwNA==",
      "is_bot": false,
      "login": "LegNeato",
      "name": "Christian Legnitto"
    },
    "body": "I ported the shadertoy shader from https://www.shadertoy.com/view/tsXBzS to rust-gpu (code at https://github.com/LegNeato/rust-gpu/tree/fractal). When I run it, shadertoy on the web is way faster than rustgpu + wgpu locally, even with a small window.\r\n\r\nThis is the command I am running:\r\n\r\n```sh\r\ncargo run --release --bin wgpu_runner -- -s FractalPyramid\r\n```\r\n\r\nI'm on a MacBook Pro with an M1 Pro on macOS 13.5.2.\r\n\r\n",
    "comments": [
      {
        "id": "IC_kwDOENG4485t6Mly",
        "author": {
          "login": "Cazadorro"
        },
        "authorAssociation": "NONE",
        "body": "Have you tried it with out rust-gpu? Like using GLSL directly in WGPU, or using SPIR-V generated by GLSLang or HLSL in WGPU?  I'm not sure how this isolates to rust-gpu otherwise, even if it is the problem. ",
        "createdAt": "2023-12-07T01:13:11Z",
        "includesCreatedEdit": true,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/1106#issuecomment-1843972466",
        "viewerDidAuthor": false
      },
      {
        "id": "IC_kwDOENG4485uBhhn",
        "author": {
          "login": "LegNeato"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "I am using `rust-gpu` so I can use my Rust knowledge for graphics programming. I am not a graphics programmer who wants to use Rust. It is a good suggestion though, I'll poke around and see if I can eliminate some variables. Thank you!",
        "createdAt": "2023-12-07T18:28:20Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/1106#issuecomment-1845893223",
        "viewerDidAuthor": false
      },
      {
        "id": "IC_kwDOENG4485vFw1n",
        "author": {
          "login": "LegNeato"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "Adding `#[inline(always)]` to the functions in the shader speeds it up a bit. It is still slow, but reasonably faster than before.",
        "createdAt": "2023-12-20T03:10:07Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/1106#issuecomment-1863781735",
        "viewerDidAuthor": false
      },
      {
        "id": "IC_kwDOENG4485vGVad",
        "author": {
          "login": "Cazadorro"
        },
        "authorAssociation": "NONE",
        "body": "First, I finally had a proper look at your code, I think you *may* have a bunch of implicit slow behavior going on.  Primitive choice matters a lot GPU because of the massive difference in performance, particularly between i32, f32,and f64 (yes, all three have completely different performance characteristics that vary wildly platform to platform, Ada as 1/2 the i32 as f32, and either 1/32 or 1/64 I believe f64 as f32).  I think you might have a bunch of f64 math by accident here, but it's hard to tell, since rust doesn't really give a `let x= 1.0` literal instantiation a type [until *after* it's been used](https://doc.rust-lang.org/rust-by-example/types/literals.html), and I'm not sure how Rust-GPU handles this. \r\n\r\nFor example, this:\r\n\r\n`Vec3::new(0.2, 0.7, 0.9)`\r\n\r\nSeems fine, but this:\r\n\r\n`let mut t = 0.0;`\r\n\r\n*might not be fine* and could result in `t` being a double (at least for Rust GPUs code-gen), which on Nvidia at least, would result in 1/32 the performance for basic float math compared to float 32 depending on if you used a consumer graphics GPU or a server grade GPU.   I would probably consider this a bug in Rust GPU if it didn't handle this properly. \r\n\r\nNext, Have you run the spir-v output through [SPIR-V Opt](https://github.com/KhronosGroup/SPIRV-Tools)?  I don't think Rust GPU does any serious optimization passes though I could be wrong, and by default sharderc and glslang actually *do* run their generated spir-v through SPIRV opt if I remember correctly.    OpenGL works differently if you don't use the SPIR-V extensions, (ie like WebGL) so it's basically implicitly doing a bunch of optimization passes behind the scenes at the driver level, before it's even turned into gpu IR (or, if you're on safari, who knows what's happening). \r\n\r\nOne way or another, you're going to have to take a look at rust-gpu's generated spirv for the same code as GLSLang/shaderc's if those actually produce faster SPIR-V, and to determine that, you need to isolate, so use spirv from those programs and run it through your current codebase, and benchmark.   Luckily that shader doesn't look too complicated, so it should be pretty straight forward to also port it to standalone vulkan GLSL, likely easier than rust-gpu, but that's something you need to do. \r\n\r\n* So first, test if it's just because it hasn't been run through spir-v opt.  If it is, it's not a problem with rust-gpu.  There's no point in duplicating Khronos Groups effort here. \r\n\r\n* If it's just as slow with shaderc/glslang run through spir-v opt, it's not the Rust GPU shader, it's moltenvk or wgpu or what ever you're using to *actually* run these shaders on Mac.   Note massive perf differences between these tools and WebGL may be expected, because the projects aren't related at all, if you're running shadertoy on safari, you're using Apple's implementation of WebGL, which may go directly to Metal. \r\n\r\n* If it's faster with shaderc/glslang, then you'll need to look at the decompiled SPIR-V and compare the output between the GLSL shader you made, and the rust-gpu one, again, the shader looks simple enough that you should easily be able to determine what functions are what. Make sure you output debug symbols into your SPIR-V.  \r\n * From there you can start to find where this program is going wrong.   I would recommend you *exactly* match the glsl, not just kind of match it, for example , while the code in the GLSL just uses a float for time, you seem to have created a new type struct for it\r\n\r\n```\r\n#[derive(Clone, Copy)]\r\nstruct Time(f32);\r\n```\r\n\r\n* Who knows what's going on there with code gen, for all I know, Rust GPU treats that as a struct with a single member, then implements copy and clone *actual SPIRV-V functions* for that type, generating a bunch of actual function calls and  [access chain](https://registry.khronos.org/SPIR-V/specs/unified1/SPIRV.html#OpAccessChain) instructions which wouldn't normally be needed since it's just a float.   That might be a bug, but again, sounds like the kind of thing SPIR-V opt or your actual SPIR-V compiler from your driver would take care of anyway?   You also wouldn't be able to inline these functions manually using this derive attribute IIUC.. \r\n\r\n* Once you isolate the problem, you should be able to make a new issue that better specifies an actionable specific cause of the problem. \r\n\r\n\r\n ",
        "createdAt": "2023-12-20T06:38:18Z",
        "includesCreatedEdit": true,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/1106#issuecomment-1863931549",
        "viewerDidAuthor": false
      },
      {
        "id": "IC_kwDOENG4485vXMES",
        "author": {
          "login": "LegNeato"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "Awesome, thanks for the pointers! I Hope to look into this more after the holidays.",
        "createdAt": "2023-12-23T18:43:59Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/1106#issuecomment-1868349714",
        "viewerDidAuthor": false
      }
    ],
    "createdAt": "2023-12-06T03:16:14Z",
    "labels": [
      {
        "id": "MDU6TGFiZWwyMjI3MzM4ODEz",
        "name": "t: bug",
        "description": "Something isn't working",
        "color": "52E8A0"
      }
    ],
    "number": 1106,
    "reactionGroups": [],
    "state": "OPEN",
    "title": "Ported shadertoy shader runs very slow (fractal pyramid)",
    "url": "https://github.com/EmbarkStudios/rust-gpu/issues/1106"
  },
  {
    "author": {
      "id": "MDQ6VXNlcjM2ODkwNA==",
      "is_bot": false,
      "login": "LegNeato",
      "name": "Christian Legnitto"
    },
    "body": "## Proposal\r\nCreate infrastructure that translates (working) shadertoy shaders into rust-gpu (and runs?). This would make it so we have a sort of burndown chart a la https://github.com/uutils/coreutils#gnu-test-suite-compatibility and https://boajs.dev/boa/test262/ and stress test different parts of `rust-gpu`. Implementing enough to flip a shader from not working to working may be an easier place for contributors to start, and seeing shaders work is neat!\r\n\r\n## Feasibility\r\n\r\nThe shadertoy api looks pretty straightforward to implement from the runner side:  https://www.shadertoy.com/howto.\r\n\r\nI'm not sure how easy the transpiling will be, but there is https://github.com/phaazon/glsl/tree/master/glsl/src/transpiler and spot checks on some shadertoy shaders doesn't look too crazy. We could probably allowlist or denylist.\r\n\r\n\r\n## Implementation\r\nI wanted to open this for comments before starting on an implementation.\r\n\r\n",
    "comments": [
      {
        "id": "IC_kwDOENG4485s_hce",
        "author": {
          "login": "LegNeato"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "Related: https://github.com/EmbarkStudios/rust-gpu/issues/1096",
        "createdAt": "2023-11-27T20:56:11Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/1104#issuecomment-1828591390",
        "viewerDidAuthor": false
      },
      {
        "id": "IC_kwDOENG4485uKVy2",
        "author": {
          "login": "LegNeato"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "I hand ported three shaders from shadertoy...I think automating this is doable for most of the image shaders. It would be cool to have a harness that compares rendering results.",
        "createdAt": "2023-12-09T03:29:53Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/1104#issuecomment-1848204470",
        "viewerDidAuthor": false
      },
      {
        "id": "IC_kwDOENG4485uKV83",
        "author": {
          "login": "LegNeato"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "Example, which works with mouse too:\r\n<img width=\"1090\" alt=\"Screenshot 2023-12-08 at 11 27 42 PM\" src=\"https://github.com/EmbarkStudios/rust-gpu/assets/368904/cbe134bf-5a8b-4f26-b75a-fa269823b8c3\">\r\n\r\nPorted from https://www.shadertoy.com/view/DlGfzh. Code in https://github.com/LegNeato/rust-gpu/tree/fork-shield\r\n\r\n",
        "createdAt": "2023-12-09T03:31:54Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/1104#issuecomment-1848205111",
        "viewerDidAuthor": false
      },
      {
        "id": "IC_kwDOENG4485wSeFF",
        "author": {
          "login": "LegNeato"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "Update: I have a WIP PR to make naga translate to rust.",
        "createdAt": "2024-01-09T22:16:59Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/1104#issuecomment-1883889989",
        "viewerDidAuthor": false
      },
      {
        "id": "IC_kwDOENG44854e_Xq",
        "author": {
          "login": "LegNeato"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "Update: I have a WIP differential harness that compares the original shadertoy shader and the converted rust shader's output.",
        "createdAt": "2024-03-26T20:20:31Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/1104#issuecomment-2021389802",
        "viewerDidAuthor": false
      }
    ],
    "createdAt": "2023-11-27T17:58:09Z",
    "labels": [
      {
        "id": "MDU6TGFiZWwyNDQwMDY4MjAw",
        "name": "mcp: proposed",
        "description": "A major change to the compiler, that hasn't yet been approved.",
        "color": "fbca04"
      }
    ],
    "number": 1104,
    "reactionGroups": [
      {
        "content": "THUMBS_UP",
        "users": {
          "totalCount": 2
        }
      }
    ],
    "state": "OPEN",
    "title": "Infrastructure for using ShaderToy as a test corpus",
    "url": "https://github.com/EmbarkStudios/rust-gpu/issues/1104"
  },
  {
    "author": {
      "id": "MDQ6VXNlcjE2MzEzNDg0",
      "is_bot": false,
      "login": "Steelbirdy",
      "name": "Patrick Ammons"
    },
    "body": "<!-- Thank you for filing a bug report! üêõ -->\r\n\r\n### Expected Behaviour\r\n<!-- Please describe what you expected to happen. -->\r\nShader crate successfully compiles\r\n\r\n### Example & Steps To Reproduce\r\n<!-- \r\nDescribe what actually happened, including any relevant examples (smaller\r\nthe better), error messages, or the relevant SPIR-V binary. \r\n-->\r\n\r\n```rust\r\n#[spirv(any_hit)]\r\npub fn my_any_hit() {\r\n    let p = Vec3A::ZERO;\r\n    if p.length_squared() < 1e-3 {\r\n        unsafe { spirv_std::arch::ignore_intersection(); }\r\n    }\r\n}\r\n```\r\n\r\n1. Use the above snippet in a shader crate\r\n2. Compilation fails\r\n\r\nReplacing this with the below snippet causes it to compile.\r\n```rust\r\n#[spirv(any_hit)]\r\npub fn my_any_hit() {\r\n    let p = Vec3A::ZERO;\r\n    if p.length_squared() < 1e-3 {\r\n        my_ignore_intersection();\r\n    }\r\n}\r\n\r\n#[inline(never)]\r\nfn my_ignore_intersection() {\r\n    unsafe { spirv_std::arch::ignore_intersection(); }\r\n}\r\n```\r\n\r\n## System Info\r\n\r\n - Rust: 1.71.0-nightly (1a5f8bce7 2023-05-26)\r\n - OS: Windows 11\r\n - GPU: NVIDIA RTX 3060 Ti\r\n\r\n\r\n## Backtrace\r\n<!-- If relevant, please include a backtrace of the error below. -->\r\n\r\n<details><summary>Backtrace</summary>\r\n<p>\r\n\r\n```\r\n  error: Selection must be structured\r\n           OpBranchConditional %1274 %1275 %1276\r\n    |\r\n    = note: module `C:\\Users\\Pat\\CLionProjects\\rayven_gpu2\\target\\spirv-builder\\spirv-unknown-vulkan1.2\\release\\deps\\shader.spv`\r\n\r\n  warning: an unknown error occurred\r\n    |\r\n    = note: spirv-opt failed, leaving as unoptimized\r\n    = note: module `C:\\Users\\Pat\\CLionProjects\\rayven_gpu2\\target\\spirv-builder\\spirv-unknown-vulkan1.2\\release\\deps\\shader.spv`\r\n\r\n  error: error:0:0 - Selection must be structured\r\n           OpBranchConditional %1274 %1275 %1276\r\n    |\r\n    = note: spirv-val failed\r\n    = note: module `C:\\Users\\Pat\\CLionProjects\\rayven_gpu2\\target\\spirv-builder\\spirv-unknown-vulkan1.2\\release\\deps\\shader.spv`\r\n```\r\n\r\n</p>\r\n</details>\r\n",
    "comments": [],
    "createdAt": "2023-11-13T21:07:54Z",
    "labels": [
      {
        "id": "MDU6TGFiZWwyMjI3MzM4ODEz",
        "name": "t: bug",
        "description": "Something isn't working",
        "color": "52E8A0"
      }
    ],
    "number": 1099,
    "reactionGroups": [],
    "state": "OPEN",
    "title": "Using `arch::ignore_intersection` causes shader compilation to fail",
    "url": "https://github.com/EmbarkStudios/rust-gpu/issues/1099"
  },
  {
    "author": {
      "id": "MDQ6VXNlcjMxMjIyNzQw",
      "is_bot": false,
      "login": "Firestar99",
      "name": ""
    },
    "body": "<!-- Thank you for filing a bug report! üêõ -->\r\n\r\n### Expected Behaviour\r\n<!-- Please describe what you expected to happen. -->\r\nIn the following example, you can't have a `uniform` with a variable amount of data, so it must be a `storage_buffer` instead. Currently, rust-gpu compiles it to an invalid spv, that is then caught by spirv-opt running afterwards, noticing the invalid spv and failing the build. Rust-gpu should probably catch this mistake earlier in the build pipeline and not even produce an invalid spv in the first place.\r\n```rust\r\n#[spirv(descriptor_set = 0, binding = 0, uniform)] vertex_input_buffer: &[f32],\r\n```\r\n\r\n### Example & Steps To Reproduce\r\n<!-- \r\nDescribe what actually happened, including any relevant examples (smaller\r\nthe better), error messages, or the relevant SPIR-V binary. \r\n-->\r\n\r\n1. have a shader entry point with the parameter declaration above\r\n2. compile the shader crate\r\n3. observe compile failing due to invalid spv being optimized\r\n\r\n## System Info\r\n<!--\r\nHelpful commands:\r\n- Rustc version: `rustc -V`\r\n- SPIR-V version: `spirv-val --version`\r\n-->\r\n\r\n - Rust: nightly-2023-05-27\r\n - OS: Ubuntu 23.04\r\n - GPU: irrevelant\r\n - SPIR-V: v2023.5 unknown hash, 2023-10-17T17:19:41\r\n\r\n\r\n## Backtrace\r\n<!-- If relevant, please include a backtrace of the error below. -->\r\n\r\n<details><summary>Backtrace</summary>\r\n<p>\r\n\r\n```\r\n   Compiling space-engine v0.1.0 (<project dir>/space-engine)\r\nerror: failed to run custom build command for `space-engine v0.1.0 (<project dir>/space-engine)`\r\nnote: To improve backtraces for build dependencies, set the CARGO_PROFILE_DEV_BUILD_OVERRIDE_DEBUG=true environment variable to enable debug information generation.\r\nCaused by:\r\n  process didn't exit successfully: `<project dir>/target/debug/build/space-engine-ab7683b3782ee376/build-script-build` (exit status: 1)\r\n  --- stdout\r\n  cargo:rerun-if-env-changed=RUSTGPU_CODEGEN_ARGS\r\n  cargo:rerun-if-env-changed=RUSTGPU_RUSTFLAGS\r\n  --- stderr\r\n     Compiling space-engine-shader v0.1.0 (<project dir>/space-engine-shader)\r\nwarning: error:0:0 - [VUID-StandaloneSpirv-OpTypeRuntimeArray-04680] For Vulkan, an OpTypeStruct variable containing an OpTypeRuntimeArray must be decorated with BufferBlock if it has storage class Uniform.\r\n    |\r\n    = note: spirv-opt failed, leaving as unoptimized\r\n    = note: module `<project dir>/target/spirv-builder/spirv-unknown-vulkan1.2/release/deps/space_engine_shader.spvs/space-renderer-lod_obj-opaque_shader-opaque_vs.spv`\r\n  error: error:0:0 - [VUID-StandaloneSpirv-OpTypeRuntimeArray-04680] For Vulkan, an OpTypeStruct variable containing an OpTypeRuntimeArray must be decorated with BufferBlock if it has storage class Uniform.\r\n    |\r\n    = note: spirv-val failed\r\n    = note: module `<project dir>/target/spirv-builder/spirv-unknown-vulkan1.2/release/deps/space_engine_shader.spvs/space-renderer-lod_obj-opaque_shader-opaque_vs.spv`\r\n  warning: `space-engine-shader` (lib) generated 1 warning\r\n  error: could not compile `space-engine-shader` (lib) due to previous error; 1 warning emitted\r\n  Error: SpirvBuilderError(BuildFailed)\r\nProcess finished with exit code 101\r\n```\r\n\r\n</p>\r\n</details>\r\n",
    "comments": [],
    "createdAt": "2023-11-13T10:30:24Z",
    "labels": [
      {
        "id": "MDU6TGFiZWwyMjI3MzM4ODEz",
        "name": "t: bug",
        "description": "Something isn't working",
        "color": "52E8A0"
      }
    ],
    "number": 1098,
    "reactionGroups": [],
    "state": "OPEN",
    "title": "RuntimeArray as uniform creates invalid spv instead of erroring",
    "url": "https://github.com/EmbarkStudios/rust-gpu/issues/1098"
  },
  {
    "author": {
      "id": "MDQ6VXNlcjg3NjUzOTQ4",
      "is_bot": false,
      "login": "FishArmy100",
      "name": ""
    },
    "body": "I think it would be beneficial to expose the `AccessQualifier` in the `Image!` macro, as at least for `wgpu`, `ReadWrite` and `ReadOnly` storage textures are only supported on native platforms. So, it would be benificial for `Image`s allow for `WriteOnly`.\r\n",
    "comments": [
      {
        "id": "IC_kwDOENG4485yY_tz",
        "author": {
          "login": "eddyb"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "Oh I'm really sorry I haven't checked what [SPIR-V's \"Access Qualifier\"](https://registry.khronos.org/SPIR-V/specs/unified1/SPIRV.html#Access_Qualifier) *is*.\r\nThe reason it's optional and not included in `spirv_std::Image` seems to be that it's `Kernel`-only.\r\n\r\nThat is, this is an OpenCL feature, _not_ a Vulkan one, and `wgpu` couldn't possibly make use of it (unless they misunderstood the specification, too?).\r\n\r\nThe Vulkan feature is `NonWritable`/`NonReadable` on the `OpVariable`, seems like, just like `StorageBuffer`s.\r\n\r\nIt does seem weird to put it in the attribute in the `#[spirv(...)] img: Image!(...)` declaration, as the `Image<...>` type could really use the knowledge, and a writable `&Image` behaves more like a `&[Cell<u32>]`/`&[AtomicU32]` (relying on interior mutability), if that makes sense.\r\n\r\nIt may be possible to pretend that it _is_ a parameter on image types, or even reuse the `AccessQualifier` (and rewrite it away to the Vulkan equivalent), but that seems a bit sketchy, not sure what to do about it for now.\r\n\r\n(cc @Algorhythm-sxv - sorry you ended up implementing a different feature that the needed one)",
        "createdAt": "2024-01-31T13:58:30Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/1097#issuecomment-1919155059",
        "viewerDidAuthor": false
      },
      {
        "id": "IC_kwDOENG4485yZpLT",
        "author": {
          "login": "Algorhythm-sxv"
        },
        "authorAssociation": "NONE",
        "body": "@eddyb is there a workaround to allow use of a wgpu `StorageTexture` using the attribute syntax then? I see the [`AccessQualifier`](https://docs.rs/spirv_headers/1.5.0/spirv_headers/enum.AccessQualifier.html) in `spirv-headers` but no documentation on how to use it, or if it's possible to use it.",
        "createdAt": "2024-01-31T15:21:47Z",
        "includesCreatedEdit": true,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/1097#issuecomment-1919324883",
        "viewerDidAuthor": false
      },
      {
        "id": "IC_kwDOENG4485yac-k",
        "author": {
          "login": "eddyb"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "This is the relevant part of my message:\r\n> The Vulkan feature is `NonWritable`/`NonReadable` on the `OpVariable`, seems like, just like `StorageBuffer`s.\r\n\r\nWe currently support toggling `NonWritable` for buffers based on whether you use `&T` vs `&mut T` with `#[spirv(storage_buffer, ...)]` entry-point parameter declarations, since:\r\n- #1011\r\n\r\n_In theory_, we could do it for images based on `&Image` vs `&mut Image`, but like I was saying earlier that doesn't fit very well IMO, since images already behaves as if they wrap interior mutability _anyway_, and also that doesn't cover `NonReadable` (because Rust has nothing like a \"write-only reference\"), which I believe you need?\r\n\r\nThere's two possible paths, as I see it:\r\n- `#[spirv(descriptor_set = ..., binding = ..., non_readable)] img: &Image!(...)` in the entry-point params\r\n  - this has been proposed before at least for buffers: #692\r\n  - this seems potentially problematic in terms of being able to turn off methods on the actual types, as the `Image<...>` would have no information about how it's used\r\n- `Image!(..., non_readable)` - in the type, even if Vulkan SPIR-V does not store that information there\r\n  - ideally mapped to e.g. `struct Image<..., const READABLE: bool, const WRITABLE: bool>` to allow `impl` blocks to select whether they need one or the other (or work regardless), tho see also the `trait HasImageFoo` pattern\r\n  - this might cause problems depending on the exact details, because [the SPIR-V spec states](https://registry.khronos.org/SPIR-V/specs/unified1/SPIRV.html#TypesVariables):\r\n    > It is invalid to declare multiple non-aggregate, non-pointer type `<id>`s having the same opcode and operands.\r\n\r\n    - that is, you would want tests which use the same identical `Image<...>` type with only these new differences being toggled between them, to show that they don't lead to duplicated definitions or ID conflicts\r\n  - in theory this could even be done with the same syntax and names as for the OpenCL feature (i.e. like in your PR), but at some point those would have to be replaced with the Vulkan equivalent (`entry.rs` can generate the Vulkan annotations at the same time, and then you have to remove `AccessQualifier` from the type, replacing all uses of the type, or maybe just never generate the `AccessQualifier` in the first place, getting you back to what I was saying earlier, but with the downside of seemingly-OpenCL concepts used with Vulkan shaders)",
        "createdAt": "2024-01-31T17:06:55Z",
        "includesCreatedEdit": true,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/1097#issuecomment-1919537060",
        "viewerDidAuthor": false
      }
    ],
    "createdAt": "2023-11-11T19:28:09Z",
    "labels": [
      {
        "id": "MDU6TGFiZWwyMjI3MzM4ODE2",
        "name": "t: enhancement",
        "description": "A new feature or improvement to an existing one.",
        "color": "52E8A0"
      }
    ],
    "number": 1097,
    "reactionGroups": [
      {
        "content": "THUMBS_UP",
        "users": {
          "totalCount": 1
        }
      }
    ],
    "state": "OPEN",
    "title": "spirv-std/`Image!` should expose `AccessQualifier`.",
    "url": "https://github.com/EmbarkStudios/rust-gpu/issues/1097"
  },
  {
    "author": {
      "id": "U_kgDOB5oSNA",
      "is_bot": false,
      "login": "johnny-smitherson",
      "name": "Johnny"
    },
    "body": "I've been porting some WGSL code like [like these](https://github.com/bevyengine/bevy/blob/main/assets/shaders/game_of_life.wgsl) into [rust](https://github.com/Bevy-Rust-GPU/example-workspace/pull/22#issuecomment-1796063937) and the documentation for actually writing shaders is very sparse: https://embarkstudios.github.io/rust-gpu/book/writing-shader-crates.html\r\n\r\nI only managed to get the above program working by reading through the spriv-std test code.\r\n\r\nHere are some pain points I have:\r\n- confusion about the various binding types and how WGSL declaration syntax converts to rust-spirv attribute equivalent for basic types\r\n  -    ` #[spirv(storage_buffer, ...)]` vs. ` #[spirv(storage, ...)]` vs. `Image!` - how do they translate from WGSL definitions?\r\n  - https://github.com/EmbarkStudios/rust-gpu/issues/976\r\n- confusion about various barrier types: which of [these ones](https://github.com/search?q=repo%3AEmbarkStudios%2Frust-gpu+barrier+path%3Atests&type=code) should i use for [wgsl storageBarrier()](https://github.com/bevyengine/bevy/blob/aaef5577cdbb5f7256d177be5fc98b0965d67753/assets/shaders/game_of_life.wgsl#L62) ? what about [atomic ops](https://github.com/gfx-rs/wgpu/blob/ba3d6898f18c25bb5a2b8ba18790134b97758e83/examples/hello-synchronization/src/shaders.wgsl)?\r\n- basic operations, like reading and writing to image textures, image sampling, are not documented nor in examples\r\n- what Rust types are allowed by default? I found out at runtime `u8` are not a thing - not a problem, but should be outlined for the non-initiated\r\n- is [this assembly here](https://github.com/EmbarkStudios/rust-gpu/blob/e87c324bfda6bea144fe2635586281c4ef144f0d/examples/shaders/reduce/src/lib.rs#L16) the only way to do this thing? What is even this thing that's being done?\r\n- what Rust language features are known not to work? I discovered the hard way [while and loop and/or for don't work](https://github.com/EmbarkStudios/rust-gpu/issues/1076#issuecomment-1656943689) - I just can't remember which ones\r\n- [how do i configure capabilities??](https://github.com/EmbarkStudios/rust-gpu/issues/1094) - this should be a documentation page\r\n- [how do i debug?](https://github.com/EmbarkStudios/rust-gpu/issues/578) - this should be a documentation page\r\n\r\nHaving a small body of real-life examples, ported from [the wgpu wgsl examples](https://github.com/gfx-rs/wgpu/tree/trunk/examples)  for instance, would greatly help outside people actually get into your ecosystem, without really going through the [spirv specification](https://registry.khronos.org/SPIR-V/specs/unified1/SPIRV.html#SpecializationSection) and diffing it to the [wgsl specification](https://www.w3.org/TR/WGSL/) to display a couple of spinning triangles.\r\n\r\nI get it that some concepts will not be translateable 1-to-1 but a few more starting examples showing off basic shader features (all shader types, most of binding types, various barrier types, various combinations of globals, uniforms -- these would all help porting WGSL and GLSL into rust\r\n\r\nI propose a Before + After rust conversion from each example, so everyone can see how the porting gets done, what gets translated into what. And you can also do benchmarks and correctness testIng on the rust shader vs. the original shader. \r\n\r\nMaybe the original WGPU example runner can be used with minimal modification to accept spirv-type shaders alongside the original wgsl, so you won't have to rebuild all the runner bind group code from scratch.\r\n\r\nOtherwise, I feel like without being a GPU pipeline engineer, I can't be the target audience for this project, but I really want to be, WGSL is awful, Rust is great.\r\n\r\n**edit** found \r\n- https://dev.to/bardt/notes-on-migrating-from-wgsl-to-rust-gpu-shaders-56bg\r\n- https://dev.to/bardt/sharing-types-between-wgpu-code-and-rust-gpu-shaders-17c4\r\n\r\nAre there any other resources that exist for this?",
    "comments": [
      {
        "id": "IC_kwDOENG4485tNz5b",
        "author": {
          "login": "Cazadorro"
        },
        "authorAssociation": "NONE",
        "body": ">confusion about the various binding types and how WGSL declaration syntax converts to rust-spirv attribute equivalent for basic types\r\n\r\nYou probably know this and probably what I'll say subsequently, but virtually all attributes and binding types in WGSL AFAIK are based on the SPIR-V spec.  SPIR-V was originally going to be the target language for WebGPU instead of WGSL until Apple's lawyers started getting involved and stopping the process due to some weird legal issue with Khronos Group.   \r\n\r\nWGSL was put forward in order to still have SPIR-V tools be usable in the web space while satisfying Apple's lawyers.   As such, WGSL's documentation in the past made *explicit mention* of how their own types and attributes map to SPIR-V (or at least used to, they seemed to remove it over time...).  This means a lot of the engineers that worked on WGSL kind of know SPIR-V also and implicitly assume SPIR-V knowledge by accident when you read the spec, and thus it's \"natural\"ish for them to translate between the two in how their concepts map.   Note WGSL has changed a lot in recent years as well, so a lot of the issue is on WGSL not being \"stable\" until recently either.   \r\n\r\nBut anyway I agree, RustGPU needs the kinds of resources mentioned. In the mean time,  I'll attempt to answer some of the mappings as best I can here.\r\n\r\n> #[spirv(storage_buffer, ...)] vs.  #[spirv(storage, ...)] vs. Image!\r\n\r\nThese come from SPIR-V, specifically, these come from the *storage class specifier*, see the full list here: https://registry.khronos.org/SPIR-V/specs/unified1/SPIRV.html#_storage_class  Make sure to discount the ones that are OpenCL only (kernel mode capability etc...). \r\n\r\nFrom here you can map what belongs where, `storage_buffer` is equivalent to the `storage` Address space in WGSL. \r\n\r\n While the `Image` storage class is equivalent to `handle`, it's almost 1:1. You basically don't deal with storage classes with them directly, (WGSL, samplers and textures are always in handle space, in SPIR-V they are always in \"Image\" storage class) Opaque handles (samplers and textures) are handled somewhat separately in this way.  They are known as \"Opaque handles\"/\"Opaque Pointers\" in CUDA and other APIs because they don't live in the same world as a traditional pointer to memory, are typically fixed on execution of a kernel/shader, and you can't increment or decrment/convert to uint with them (they are \"opaque\", you don't know the address, and you don't know how it's implemented). \r\n\r\nThe `Image!` macro exists, because it's covering for the longwinded declaration necessary in SPIR-V, see this https://registry.khronos.org/SPIR-V/specs/unified1/SPIRV.html#OpTypeImage But it is just syntax sugar \r\n\r\nThere are potentially 8 different parameters you need to stuff in there.   See [this](https://docs.rs/spirv-std/latest/spirv_std/image/struct.Image.html) for the real `spirv_std` type that does the same thing. \r\n\r\n\r\n> confusion about various barrier types: which of [these ones](https://github.com/search?q=repo%3AEmbarkStudios%2Frust-gpu+barrier+path%3Atests&type=code) should i use for [wgsl storageBarrier()](https://github.com/bevyengine/bevy/blob/aaef5577cdbb5f7256d177be5fc98b0965d67753/assets/shaders/game_of_life.wgsl#L62) ?\r\n\r\nBarriers in SPIR-V follow memory semantics (barrier(scope, given_semantic)).  Barriers in WGSL are strictly less powerful IIRC. \r\n * scope docs https://registry.khronos.org/SPIR-V/specs/unified1/SPIRV.html#Scope_-id-\r\n * semantics docs https://registry.khronos.org/SPIR-V/specs/unified1/SPIRV.html#Memory_Semantics_-id-\r\n * scope enums in `spirv-std` https://docs.rs/spirv-std/latest/spirv_std/memory/enum.Scope.html\r\n * semantics enum for `spirv-std` https://docs.rs/spirv-std/latest/spirv_std/memory/struct.Semantics.html\r\n\r\nIf you look there, you'll see \"`UniformMemory`\" is the memory semantic for `storage_buffer`.  The problem is for what ever reason spirv-std doesn't give you one of those as a single function with out parameters. \r\n\r\nsee https://github.com/EmbarkStudios/rust-gpu/blob/main/crates/spirv-std/src/arch/barrier.rs for barriers availible. \r\n\r\nI'm not sure why they don't do this, they may want you to use the more general barriers  in which case you may chose to use a memory barrier appropriate to your use case, in this case WGSL [defines control barriers as per workgroup](https://www.w3.org/TR/WGSL/#control-barrier), so  use the `workgroup_memory_barrier()`.  Otherwise you can do the following to get the exact meaning for the storage buffer barrier (note according to WGSL, [it also uses `acquireRelease` memory semantics](https://www.w3.org/TR/WGSL/#memory-semantics) )\r\n\r\n        spirv_std::arch::memory_barrier<\r\n                spirv_std::memory::Scope::Workgroup as u32, \r\n                spirv_std::memory::Semantics::UNIFORM_MEMORY.bits() | spirv_std::memory::Semantics::ACQUIRE_RELEASE.bits()\r\n        >(); \r\n\r\n> what about [atomic ops](https://github.com/gfx-rs/wgpu/blob/ba3d6898f18c25bb5a2b8ba18790134b97758e83/examples/hello-synchronization/src/shaders.wgsl)\r\n\r\natomics ops work much the same way in SPIR-V as barriers, but that also makes them much different from WGSL.  If you want to use atomics, you'll want to use one of these implementations depending on your use case. Note that atomic operations in the real world matter at the *subgroup* level as well, which WGSL doesn't give you access to. \r\n\r\nhttps://github.com/EmbarkStudios/rust-gpu/blob/main/crates/spirv-std/src/arch/atomics.rs  Scope and semantics are the same type of thing as before, except now you're talking about \"None( relaxed)\", \"Acquire\", \"Release\", and \"AcquireRelease\", just like  [rust ](https://doc.rust-lang.org/nomicon/atomics.html) and c++, but they aren't attached to the type in these functions.  WGSL attaches the scope to atomics, and apparently always uses relaxed (presumably because of mobile GPUs poor memory models). \r\n\r\nthere for adding to the count variable in your example might look like:\r\n```\r\n spirv_std::arch::atomic_i_add<\r\n    u32,  \r\n    spirv_std::memory::Scope::Workgroup as u32, \r\n    spirv_std::memory::Semantics::None as u32\r\n>( &mut count, 1u32); \r\n```\r\n\r\n> basic operations, like reading and writing to image textures, image sampling, are not documented nor in examples\r\n\r\nyep, really weird they don't show this, I don't think there's a single sampled image in their examples for shaders.  The easiest way to find out is to look up, say, \"sample\" in spirv-std https://docs.rs/spirv-std/latest/spirv_std/index.html and then look at the spir-v docs, and extrapolate from there. there's also examples from other people scattered *outside* of this repository ie [strolle](https://github.com/Patryk27/strolle) or embarks own [Kajiya](https://github.com/EmbarkStudios/kajiya) specifically here: https://github.com/EmbarkStudios/kajiya/tree/main/crates/lib/rust-shaders/src\r\n\r\nFor example, to use a sampled image, you'd take a texture and a sampler , and one of the associated [sampling functions](https://docs.rs/spirv-std/latest/spirv_std/image/struct.Image.html#method.sample_by_lod) and do something like:\r\n```\r\n\r\n#[spirv(vertex)]\r\npub fn foo_vs(\r\n//inputs \r\n vertex_attribute_0: Vec4,\r\n...\r\n\r\n//outputs \r\nfragment_uv: &mut Vec2,\r\n...\r\n){\r\n}\r\n```\r\n\r\n```\r\n#[spirv(fragment)]\r\nfn foo_fs(\r\n#[spirv(descriptor_set = 0, binding = 0)] texture: &Image!(2D, type=f32, sampled=true),\r\n#[spirv(descriptor_set = 0, binding = 1)] sampler: &Sampler),\r\n//inputs\r\n fragment_uv: Vec2,\r\n//outputs\r\nout_color: &mut Vec4\r\n){\r\n\r\n   let sampled_color : Vec4 = texture.sample(sampler, fragment_uv); \r\n  *out_color = sampled_color; \r\n}\r\n\r\n```\r\n\r\n\r\n> what Rust types are allowed by default? I found out at runtime u8 are not a thing - not a problem, but should be outlined for the non-initiated\r\n\r\nYeah, not sure what the deal is but this is a problem. You have to search for open issues on what is implemented right now, for example, int128 doesn't exist.  Though TBH, I'm not sure why u8 is not implemented since it *is* a thing in SPIR-V, and would look nearly identical to the code for i32,i64 etc... Strangely when I look through the codebase, it would appear that it is implemented, and I can see other projects using it: \r\n\r\nhttps://github.com/EmbarkStudios/kajiya/blob/d373f76b8a2bff2023c8f92b911731f8eb49c6a9/crates/lib/rust-shaders-shared/src/ssgi.rs#L8\r\n\r\nhttps://github.com/Patryk27/strolle/blob/92b042e1c95638c7200ac4b7e894ee0664320ef4/strolle-shaders/reference-shading/src/lib.rs#L57\r\n\r\n If you want, you can go implement this yourself with https://registry.khronos.org/SPIR-V/specs/unified1/SPIRV.html#OpTypeInt but this seems like another bug if you can't use that type. \r\n\r\n\r\n\r\n> is [this assembly here](https://github.com/EmbarkStudios/rust-gpu/blob/e87c324bfda6bea144fe2635586281c4ef144f0d/examples/shaders/reduce/src/lib.rs#L16) the only way to do this thing? What is even this thing that's being done?\r\n\r\nIt's possible the problem here is that you're coming from WGSL, and unless you're *also* a GPGPU programmer or have worked extensively with modern vulkan, you may have never encountered \"subgroups\". \r\n\r\nYou probably know a lot or all of this, but it's worth repeating anyway. The GPU doesn't actually execute \"threads\" in the traditional sense.  A gpu is more or less a collection of *SIMD units* masquerading as individual threads for each lane for the programmer.  On the gpu every set \"n\" threads is a \"subgroup\" (usually a power of 2, on Nvidia 32, on Amd, 32 or 64, on Intel sometimes 128, sometimes 16, other GPUS have different subgroup sizes) Because the GPU is organized this way, there are many consequences, mainly:\r\n\r\n* Branching within a subgroup that is not optimized out will result in something called \"thread divergence\"\r\n    * because you're actually executing on an SIMD unit, in order for instructions to execute at the same time, they must all be the same. \r\n    *  When you have \"thread divergence\", the instruction pointer must change for each branch, and thus each branch executes independently, *in serial, ie one after another*. \r\n* Branching on the subgroup boundary (ie first 32 take one path, and next 32 take another path on Nvidia) Will *not* result in \"thread divergence\"\r\n* each hardware subgroup \"knows\" about all other threads in the subgroup, and thus may use *cooperation instructions* to work with threads within a subgroup for significant speed up versus other methods (such as reaching back to shared memory). \r\n\r\nNote that subgroup is a \"generalized\" cross-platform term for this concept, in the past they have been referred to as \"Wavefronts\" by AMD and pre-gpu parrallel processing literature, and are called \"Warps\" in Nvidia CUDA nomenclature. \r\n\r\nYou can see all the types of subgroup operations available explained here (it's GLSL but it maps to SPIR-V and thus maps to RustGPU)\r\n\r\nhttps://www.khronos.org/blog/vulkan-subgroup-tutorial\r\n\r\nand the corresponding SPIR-V instructions here\r\n\r\nhttps://registry.khronos.org/SPIR-V/specs/unified1/SPIRV.html#_group_operation\r\n\r\nin particular, this function is trying to emulate the following function described in the vulkan subgroup tutorial\r\n\r\n`T subgroupAdd(T value) returns the summation of all active invocations value's across the subgroup.`\r\n\r\nWhat this is saying, is that if I have, say, a subgroup size of 32, and I make the following call:\r\n\r\n    let sum = subgroup_add( 1u32); \r\n\r\nThat will result in `sum` having a value of `32u32` and if I instead call `subgroup_add( 10u32)` it will be `320u32`, and if I use another variable, say a value from the array of 32 values\r\n\r\n    let sum = subgroup_add( my_array[my_subgroup_idx]); \r\n\r\nit will be the sum of all 32 values.  And not only will *this* subgroup thread get access to that value, that value is broadcast to *every* thread in the subgroup. \r\n\r\n> what Rust language features are known not to work? I discovered the hard way https://github.com/EmbarkStudios/rust-gpu/issues/1076#issuecomment-1656943689 - I just can't remember which ones\r\n\r\nLots of bugs with loops and optimization, I'm also frustrated that this has not been coalesced searchably into one document. \r\n\r\n> https://github.com/EmbarkStudios/rust-gpu/issues/1094 - this should be a documentation page\r\n\r\nIt looks like the answer is already there, but I suspect the reason that kind of stuff isn't a priority is because kernel and shader mode spirv are not compatible, and Rust-GPU was developed for shader/vulkan SPIR-V so I'm not even sure basic  functionality will work if you try to, say sample a texture in kernel mode. \r\n\r\nHopefully this helps answer the questions put forth here and anyone else who wanders here, and highlights the need for better documentation for rust-gpu. ",
        "createdAt": "2023-11-29T16:58:36Z",
        "includesCreatedEdit": true,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "users": {
              "totalCount": 1
            }
          }
        ],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/1096#issuecomment-1832336987",
        "viewerDidAuthor": false
      }
    ],
    "createdAt": "2023-11-07T18:49:37Z",
    "labels": [
      {
        "id": "MDU6TGFiZWwyMjI3MzM4ODE2",
        "name": "t: enhancement",
        "description": "A new feature or improvement to an existing one.",
        "color": "52E8A0"
      }
    ],
    "number": 1096,
    "reactionGroups": [
      {
        "content": "THUMBS_UP",
        "users": {
          "totalCount": 3
        }
      }
    ],
    "state": "OPEN",
    "title": "documentation and examples for porting WGSL/GLSL shaders",
    "url": "https://github.com/EmbarkStudios/rust-gpu/issues/1096"
  },
  {
    "author": {
      "id": "MDQ6VXNlcjc3NDI0",
      "is_bot": false,
      "login": "eddyb",
      "name": "Eduard-Mihai Burtescu"
    },
    "body": "\"Zombies\" are a form of deferred errors (mostly to ignore errors caused in unused code), for both:\n- concepts representable in SPIR-V, but not legal (e.g. OpenCL-only pointer operations)\n- concepts not even representable (often implemented as \"zombie\"-annotated `OpUndef` values)\n  - this is often not a true spec limitation, only an implementation one, e.g. an Intel OpenCL extension could be used for function pointers, and `OpSpecConstantOp` can express non-trivial constant pointers (in both cases, these would only serve as *inputs* to legalization, which is expected to rewrite them away - see below)\n\nHowever, a primary goal of Rust-GPU is to *legalize* the Rust dynamic semantics into legal SPIR-V, and we're currently inconsistent, where some aspects are not checked *before* legalization (e.g. variables containing pointers) so that legalization has a chance to rewrite them away - but others use \"zombies\" and can only compile if \"actually unused\".\n\nIn the past, I've considered making further compromises to keep this system around (perhaps for a bit of nostalgia?), but if I try to be objective about this, Rust-GPU has a better chance at supporting more Rust code if the validation is deferred, and our post-legalization error reporting nowadays is arguably lossless (as e.g. inlining generates custom debuginfo now, for both this usecase, and panic \"backtraces\").\n\nSo I think what we can do is replicate the same checks we have for zombies, but as something more akin to \"`spirv-val` for SPIR-T\" (with only the few rules we care about for now)\n- see also: https://github.com/EmbarkStudios/spirt/issues/2\n\n(I did start on something like this a month or two ago, but it was slowed down and overcomplicated by trying to do it piecemeal, and it should be quicker if zombies are all going away)",
    "comments": [],
    "createdAt": "2023-10-12T10:57:12Z",
    "labels": [],
    "number": 1095,
    "reactionGroups": [],
    "state": "OPEN",
    "title": "Replace \"zombie\" system with post-legalization SPIR-T validation.",
    "url": "https://github.com/EmbarkStudios/rust-gpu/issues/1095"
  },
  {
    "author": {
      "id": "MDQ6VXNlcjE1MDg1MDYy",
      "is_bot": false,
      "login": "jczaja",
      "name": "Jacek Czaja"
    },
    "body": "Hi,\r\n\r\nI have a dummy compute kernel:\r\n```\r\n#[spirv(compute(threads(768)))]\r\npub fn main_cs(\r\n    #[spirv(global_invocation_id)] id: UVec3,\r\n    #[spirv(storage_buffer, descriptor_set = 0, binding = 0)] prime_indices: &mut [u32],\r\n) {\r\n    let index = id.x as usize;\r\n    prime_indices[index] = collatz(prime_indices[index]).1u32;\r\n}\r\n\r\n```\r\n\r\nI can run it using [Vulkano](https://github.com/vulkano-rs/vulkano) abd it works, but I wanted to run this spir-v kernel using Intel Level Zero and this did not work. Problem is that Intel Level zero is OpenCL like API and it [require](https://spec.oneapi.io/level-zero/latest/core/SPIRV.html#validation-rules) that SPIR-V is : \r\n```\r\nOpCapability Kernel\r\nOpMemoryModel Physical64 OpenCL\r\n..\r\n```\r\n\r\nwhile my dummy compute kernel as SPIR-V contains:\r\n```\r\nOpCapability Shader \r\nOpMemoryModel Logical Simple \r\n...\r\n\r\n```\r\n\r\nHow can I compiler my rust compute shader so it is of SPIR-V form OpCapability Kernel ?\r\n",
    "comments": [
      {
        "id": "IC_kwDOENG4485oq1CR",
        "author": {
          "login": "JoelCourtney"
        },
        "authorAssociation": "NONE",
        "body": "I believe you do it in the spirv builder interface.\r\n\r\n```rust\r\nSpirvBuilder::new(<path_to_crate>, <target>)\r\n        .capability(Capability::Kernel)\r\n        .build()?\r\n```",
        "createdAt": "2023-10-10T18:59:11Z",
        "includesCreatedEdit": true,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/1094#issuecomment-1756057745",
        "viewerDidAuthor": false
      }
    ],
    "createdAt": "2023-09-22T07:57:23Z",
    "labels": [],
    "number": 1094,
    "reactionGroups": [],
    "state": "OPEN",
    "title": "How to get spir-v with OpCapability Kernel?",
    "url": "https://github.com/EmbarkStudios/rust-gpu/issues/1094"
  },
  {
    "author": {
      "id": "MDQ6VXNlcjQ5Nzg0MDE5",
      "is_bot": false,
      "login": "atynagano",
      "name": ""
    },
    "body": "https://github.com/EmbarkStudios/rust-gpu/blob/e87c324bfda6bea144fe2635586281c4ef144f0d/crates/spirv-std/src/byte_addressable_buffer.rs#L73-L78\r\n\r\n```rust\r\nif byte_index + mem::size_of::<T>() as u32 > (mem::size_of::<u32> * self.data.len()) as u32\r\n```\r\n\r\nIsn't the right-hand side multiplied by 4 because `data` is `&[u32]`?",
    "comments": [
      {
        "id": "IC_kwDOENG4485nHWbH",
        "author": {
          "login": "Patryk27"
        },
        "authorAssociation": "NONE",
        "body": "`ByteAddressableBuffer` requires for the data to be aligned to 4 bytes, so the current condition is fine IMO; the naming could be better (`word_index: u32`), but the comment above explains it's inherited from HLSL.\r\n\r\nNote that `buffer_load_intrinsic()` ends up doing `4 * byte_index`:\r\n\r\nhttps://github.com/EmbarkStudios/rust-gpu/blob/e87c324bfda6bea144fe2635586281c4ef144f0d/crates/rustc_codegen_spirv/src/builder/byte_addressable_buffer.rs#L202",
        "createdAt": "2023-09-21T17:09:22Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/1093#issuecomment-1729980103",
        "viewerDidAuthor": false
      },
      {
        "id": "IC_kwDOENG4485nJaqZ",
        "author": {
          "login": "atynagano"
        },
        "authorAssociation": "NONE",
        "body": "So does the left side `size_of<T>` needs to be divided by 4? Or does `size_of` returns dword size?",
        "createdAt": "2023-09-22T00:15:22Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/1093#issuecomment-1730521753",
        "viewerDidAuthor": false
      },
      {
        "id": "IC_kwDOENG4485nKjFK",
        "author": {
          "login": "Patryk27"
        },
        "authorAssociation": "NONE",
        "body": "Oh, yeah - I think it should say `mem::size_of::<T>() / 4` then ü§î ",
        "createdAt": "2023-09-22T05:23:20Z",
        "includesCreatedEdit": true,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/1093#issuecomment-1730818378",
        "viewerDidAuthor": false
      }
    ],
    "createdAt": "2023-09-21T11:51:47Z",
    "labels": [],
    "number": 1093,
    "reactionGroups": [],
    "state": "OPEN",
    "title": "Incorrect index validation",
    "url": "https://github.com/EmbarkStudios/rust-gpu/issues/1093"
  },
  {
    "author": {
      "id": "MDQ6VXNlcjQ5Nzg0MDE5",
      "is_bot": false,
      "login": "atynagano",
      "name": ""
    },
    "body": "<!--\r\nThank you for your interest in the `rust-gpu` project! This template is for\r\nproposing a minor improvement, such as addig a new method, or improving \r\ndocumentation. Please try to provide a short high level overview of what you would\r\nlike you to add. Also be sure to check the existing and `wontfix` issues to see\r\nif it's already been proposed before posting.\r\n\r\nExisting Issues: https://github.com/EmbarkStudios/rust-gpu/issues?q=is%3Aopen+is%3Aissue+label%3A%22t%3A+enhancement%22\r\nClosed Issues: https://github.com/EmbarkStudios/rust-gpu/labels/s%3A%20wontfix\r\n\r\n-->\r\n\r\nhttps://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/HitTriangleVertexPositionsKHR.html\r\n\r\nIs it planned, or is there any way to use such a extension?",
    "comments": [
      {
        "id": "IC_kwDOENG4485nQWNJ",
        "author": {
          "login": "atynagano"
        },
        "authorAssociation": "NONE",
        "body": "```rust\r\n    use core::arch::asm;\r\n    use spirv_std::glam::Vec3;\r\n\r\n    #[spirv_std::macros::gpu_only]\r\n    pub fn get_positions() -> [Vec3; 3] {\r\n        unsafe {\r\n            let mut result: [Vec3; 3] = Default::default();\r\n            asm! {\r\n                \"%f32 = OpTypeFloat 32\",\r\n                \"%f32x3 = OpTypeVector %f32 3\",\r\n                // OpTypeArray in asm! is not supported yet\r\n                // \"%f32x3x3 = OpTypeArray %f32x3 3\",\r\n                \"%f32x3x3 = OpTypeMatrix %f32x3 3\",\r\n                \"%ptr_f32x3x3 = OpTypePointer Generic %f32x3x3\",\r\n                \"%positions = OpVariable %ptr_f32x3x3 Input\",\r\n                \"OpDecorate %positions BuiltIn HitTriangleVertexPositionsKHR\",\r\n                \"%result = OpLoad %f32x3x3 %positions\",\r\n                \"OpStore {result} %result\",\r\n                result = in(reg) &mut result,\r\n            }\r\n            result\r\n        }\r\n    }\r\n```\r\nI tried the above code and got the error message `error: unknown BuiltIn HitTriangleVertexPositionsKHR`. So I think [rspirv](https://github.com/gfx-rs/rspirv) needs to support it first.\r\n(I am not familiar with spirv so this code may be wrong to begin with.)",
        "createdAt": "2023-09-23T15:08:17Z",
        "includesCreatedEdit": true,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/1092#issuecomment-1732338505",
        "viewerDidAuthor": false
      },
      {
        "id": "IC_kwDOENG44855knx6",
        "author": {
          "login": "atynagano"
        },
        "authorAssociation": "NONE",
        "body": "Seems supported in version 0.12.",
        "createdAt": "2024-04-05T12:12:54Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/1092#issuecomment-2039643258",
        "viewerDidAuthor": false
      }
    ],
    "createdAt": "2023-09-12T05:05:37Z",
    "labels": [
      {
        "id": "MDU6TGFiZWwyMjI3MzM4ODE2",
        "name": "t: enhancement",
        "description": "A new feature or improvement to an existing one.",
        "color": "52E8A0"
      }
    ],
    "number": 1092,
    "reactionGroups": [],
    "state": "OPEN",
    "title": "Ray tracing position fetch support",
    "url": "https://github.com/EmbarkStudios/rust-gpu/issues/1092"
  },
  {
    "author": {
      "id": "MDQ6VXNlcjMxMjIyNzQw",
      "is_bot": false,
      "login": "Firestar99",
      "name": ""
    },
    "body": "<!-- Thank you for filing a bug report! üêõ -->\r\n\r\n### Expected Behaviour\r\nrust-gpu compiling for any `spirv-unknown-vulkan1.X` target should not implicitly emit `OpCapability VulkanMemoryModel` in the resulting spv, instead one would need to call `SpirvBuilder.capability(Capability::VulkanMemoryModel)` to enable the `VulkanMemoryModel` explicitly.\r\nThis implicit enabling of that Capability can get in the way of 1:1 porting of glsl shaders to rust-gpu, as it also requires changes to the CPU code to enable the VulkanMemoryModel device feature. Switching to target `spirv-unknown-spv1.X` does remove the implicit capability from the shader, but it is disencouraged as it also \"disables a bunch of rules in `spirv-val`\".\r\n<!-- Please describe what you expected to happen. -->\r\n\r\n### Example & Steps To Reproduce\r\n<!-- \r\nDescribe what actually happened, including any relevant examples (smaller\r\nthe better), error messages, or the relevant SPIR-V binary. \r\n-->\r\n\r\n1. `git clone` https://github.com/Firestar99/rust-gpu-vulkano-example.git\r\n2. In `example/build.rs` change `TARGET` from `spirv-unknown-spv1.3` to `spirv-unknown-vulkan1.2` (or any other vulkan version)\r\n3. `cargo run` to see it fail when changes of 2. are applied\r\n\r\n## System Info\r\n<!--\r\nHelpful commands:\r\n- Rustc version: `rustc -V`\r\n- SPIR-V version: `spirv-val --version`\r\n-->\r\n\r\n - Rust: nightly-2023-05-27\r\n - OS: Ubuntu 23.04\r\n - GPU: RADV REMBRANDT\r\n - SPIR-V: SPIRV-Tools v2023.3 unknown hash, 2023-05-25T20:33:54\r\n",
    "comments": [],
    "createdAt": "2023-08-10T11:29:34Z",
    "labels": [
      {
        "id": "MDU6TGFiZWwyMjI3MzM4ODEz",
        "name": "t: bug",
        "description": "Something isn't working",
        "color": "52E8A0"
      }
    ],
    "number": 1090,
    "reactionGroups": [],
    "state": "OPEN",
    "title": "Shaders should not implicitly enable VulkanMemoryModel",
    "url": "https://github.com/EmbarkStudios/rust-gpu/issues/1090"
  },
  {
    "author": {
      "id": "MDQ6VXNlcjI0OTQy",
      "is_bot": false,
      "login": "schell",
      "name": "Schell Carl Scivally"
    },
    "body": "<!-- Thank you for filing a bug report! üêõ -->\r\n\r\n### Expected Behaviour\r\nShaders should compile.\r\n\r\n### Example & Steps To Reproduce\r\nShaders that previously compiled in 0.8 are no longer compiling when bumping `rust-gpu`, `spirv-std` and `spirv-builder` to 0.9.\r\n\r\nSpecifically the shaders in question all give some form of this error:\r\n```\r\nerror: error:0:0 - In Logical addressing, variables may not allocate a pointer type\r\n         %24 = OpVariable %_ptr_Private__ptr_Private_uint Private %25\r\n  |\r\n  = note: spirv-val failed\r\n  = note: module `/Users/schell/code/renderling/shaders/shader-crate/target/spirv-unknown-vulkan1.2/release/deps/shader_crate.spvs/main_fragment_scene.spv`\r\n```\r\n\r\n1. `git clone https://github.com/schell/renderling --branch chore/bump-rust-gpu-0.9`\r\n2. `cd renderling/shaders`\r\n3. `cargo run --release`\r\n\r\n## System Info\r\nApple M1\r\nmacOS 13.4.1 (22F82)\r\n\r\n### spirv-val \r\n```\r\nSPIRV-Tools v2023.3 v2022.4-198-ge7c6084f\r\nTargets:\r\n  SPIR-V 1.0\r\n  SPIR-V 1.1\r\n  SPIR-V 1.2\r\n  SPIR-V 1.3\r\n  SPIR-V 1.4\r\n  SPIR-V 1.5\r\n  SPIR-V 1.6\r\n  SPIR-V 1.2 (under OpenCL 2.2 Full Profile semantics)\r\n  SPIR-V 1.0 (under Vulkan 1.0 semantics)\r\n  SPIR-V 1.3 (under Vulkan 1.1 semantics)\r\n SPIR-V 1.4 (under Vulkan 1.1 semantics)\r\n SPIR-V 1.5 (under Vulkan 1.2 semantics)\r\n SPIR-V 1.6 (under Vulkan 1.3 semantics)\r\n```",
    "comments": [
      {
        "id": "IC_kwDOENG4485j_IXu",
        "author": {
          "login": "repi"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "any ideas @eddyb ?",
        "createdAt": "2023-08-14T14:57:16Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/1089#issuecomment-1677493742",
        "viewerDidAuthor": false
      },
      {
        "id": "IC_kwDOENG4485j_vuA",
        "author": {
          "login": "eddyb"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "@repi sorry, this got discussed on the Discord but I forgot to post a reply here as well.\r\n\r\nThe problem is that 0.8, and perhaps earlier versions too (0.7? unsure how far back it goes), are actually in the wrong here, at least in the short term.\r\n\r\nThat is, __*we had allowed code we didn't intend to, to compile*__.\r\n\r\nThe reason is MIR inlining: it got enabled by default, and IIRC even made more aggressive, upstream, and it wasn't obvious right away how damaging it could be to us (I think the first hint was debug builds sometimes erroring).\r\n\r\n0.9 closed this hole, but the damage had been done in some codebases, if they had used previous versions.\r\n\r\n---\r\n\r\nFor this specific example I'm not even sure what's triggering it, my plan for a while has been to add our own validation (that can generate SPIR-T diagnostics, and thus get far more context information than `spir-val`), but I only started on that last week, I should prioritize it, to make debugging in general.\r\n\r\nBut \"helping users tweak their code to bypass a limitation\" is only a short-term solution.\r\nHere it looks like the problem is something like `&&123`, and presumably enough inlining and/or constant-folding can eliminate the extra indirection, but it will take a lot more SPIR-T work to make it almost always work.",
        "createdAt": "2023-08-14T16:23:20Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "users": {
              "totalCount": 1
            }
          }
        ],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/1089#issuecomment-1677654912",
        "viewerDidAuthor": false
      },
      {
        "id": "IC_kwDOENG4485ll4fv",
        "author": {
          "login": "schell"
        },
        "authorAssociation": "NONE",
        "body": "After compiling my shaders with `RUSTGPU_CODEGEN_ARGS='--no-early-report-zombies --no-infer-storage-classes --spirt-passes=qptr' cargo run --release` I got [these errors](https://gist.github.com/schell/997b438c98a9869c73e281149b8f7c50) which were quite a bit more helpful (thanks @eddyb for the tip). \r\n\r\nI then made [this one line change](https://github.com/schell/renderling/pull/55/commits/dd9c13315ecf2f6cd33e75794cd9b871a34f985e#diff-2c1f893ae0b3b98bea0d8059b3fab64abdd3fe0231ecc125ba0d6075b6249af7L79):\r\n```\r\n -       self == &Id::NONE\r\n +      *self == Id::NONE\r\n``` \r\nand now my shaders compile and validate.",
        "createdAt": "2023-09-03T23:06:34Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/1089#issuecomment-1704429551",
        "viewerDidAuthor": false
      },
      {
        "id": "IC_kwDOENG4485xrfaM",
        "author": {
          "login": "pema99"
        },
        "authorAssociation": "NONE",
        "body": "Hello. I am facing a similar issue when updating to 0.9:\r\n\r\n```\r\nerror: In Logical addressing, variables may not allocate a pointer type\r\n           %165 = OpVariable %_ptr_Private__ptr_Private_uint Private %164\r\n    |\r\n    = note: module `D:\\Projects\\rust-gpu-compute-example\\target\\spirv-builder\\spirv-unknown-vulkan1.1\\release\\deps\\kernels.spv`\r\n\r\n  warning: an unknown error occurred\r\n    |\r\n    = note: spirv-opt failed, leaving as unoptimized\r\n    = note: module `D:\\Projects\\rust-gpu-compute-example\\target\\spirv-builder\\spirv-unknown-vulkan1.1\\release\\deps\\kernels.spv`\r\n\r\n  error: error:0:0 - In Logical addressing, variables may not allocate a pointer type\r\n           %165 = OpVariable %_ptr_Private__ptr_Private_uint Private %164\r\n    |\r\n    = note: spirv-val failed\r\n    = note: module `D:\\Projects\\rust-gpu-compute-example\\target\\spirv-builder\\spirv-unknown-vulkan1.1\\release\\deps\\kernels.spv\r\n```\r\n\r\nWhen I run with the flags suggested in the comment just above this one, I get an ICE\r\n```\r\nerror: failed to run custom build command for `rustic v0.1.0 (D:\\Projects\\rust-gpu-compute-example)`\r\n\r\nCaused by:\r\n  process didn't exit successfully: `D:\\Projects\\rust-gpu-compute-example\\target\\debug\\build\\rustic-abd3588c8bbf489a\\build-script-build` (exit code: 101)   \r\n  --- stdout\r\n  cargo:rerun-if-env-changed=RUSTGPU_CODEGEN_ARGS\r\n  cargo:rerun-if-env-changed=RUSTGPU_RUSTFLAGS\r\n\r\n  --- stderr\r\n     Compiling core v0.0.0 (C:\\Users\\Pema Malling\\.rustup\\toolchains\\nightly-2023-05-27-x86_64-pc-windows-msvc\\lib\\rustlib\\src\\rust\\library\\core)\r\n     Compiling rustc-std-workspace-core v1.99.0 (C:\\Users\\Pema Malling\\.rustup\\toolchains\\nightly-2023-05-27-x86_64-pc-windows-msvc\\lib\\rustlib\\src\\rust\\library\\rustc-std-workspace-core)\r\n     Compiling compiler_builtins v0.1.92\r\n     Compiling libm v0.2.6\r\n     Compiling bytemuck v1.13.1\r\n     Compiling spirv-std-types v0.7.0\r\n     Compiling bitflags v1.3.2\r\n     Compiling num-traits v0.2.15\r\n     Compiling glam v0.22.0\r\n     Compiling spirv-std v0.7.0\r\n     Compiling shared_structs v0.1.0 (D:\\Projects\\rust-gpu-compute-example\\shared_structs)\r\n     Compiling kernels v0.1.0 (D:\\Projects\\rust-gpu-compute-example\\kernels)\r\n  thread 'rustc' panicked at 'unknown `--spirt-passes=qpt`', C:\\Users\\Pema Malling\\.cargo\\registry\\src\\index.crates.io-6f17d22bba15001f\\rustc_codegen_spirv-0.9.0\\src\\linker\\spirt_passes\\mod.rs:176:18\r\n  stack backtrace:\r\n     0:     0x7ffe3aef60ac - <std::sys_common::backtrace::_print::DisplayBacktrace as core::fmt::Display>::fmt::h70b4919684dd67bc\r\n     1:     0x7ffe3af2f2cb - core::fmt::write::h49ea4d0830ece613\r\n     2:     0x7ffe3aeeb809 - <std::io::IoSliceMut as core::fmt::Debug>::fmt::hb84243a4dbe28bcc\r\n     3:     0x7ffe3aef5e5b - std::sys::common::alloc::realloc_fallback::h7830197214bb8741\r\n     4:     0x7ffe3aef96b9 - std::panicking::default_hook::h0792f154c0945b0f\r\n     5:     0x7ffe3aef936f - std::panicking::default_hook::h0792f154c0945b0f\r\n     6:     0x7ffdfa350406 - rustc_driver_impl[870db4b48175521f]::install_ice_hook\r\n     7:     0x7ffe3aef9dcb - std::panicking::rust_panic_with_hook::hd9c01cbcced319a5\r\n     8:     0x7ffe3aef9b4d - <std::panicking::begin_panic_handler::StrPanicPayload as core::panic::BoxMeUp>::get::h09e6bfb0ba837dd7\r\n     9:     0x7ffe3aef6cd9 - <std::sys_common::backtrace::_print::DisplayBacktrace as core::fmt::Display>::fmt::h70b4919684dd67bc\r\n    10:     0x7ffe3aef9850 - rust_begin_unwind\r\n    11:     0x7ffe3af62aa5 - core::panicking::panic_fmt::ha271b31fcd91f4fb\r\n    12:     0x7ffe174ff401 - rustc_codegen_spirv::linker::spirt_passes::run_func_passes::h96f076ae6786ab8a\r\n    13:     0x7ffe1734ef93 - rustc_codegen_spirv::linker::link::h43a3a67e6510621b\r\n    14:     0x7ffe175966a5 - rustc_codegen_spirv::link::link::hc84c0de595892507\r\n    15:     0x7ffe1750412d - <rustc_codegen_spirv::SpirvCodegenBackend as rustc_codegen_ssa::traits::backend::CodegenBackend>::link::h5402102cc366c311      \r\n    16:     0x7ffdf7c31451 - <rustc_interface[66947bf71e0aa21e]::queries::Linker>::link\r\n    17:     0x7ffdf7c0b252 - rustc_driver_impl[870db4b48175521f]::args::arg_expand_all\r\n    18:     0x7ffdf7c0a246 - rustc_driver_impl[870db4b48175521f]::args::arg_expand_all\r\n    19:     0x7ffe3af0d1cc - std::sys::windows::thread::Thread::new::ha73e81f94151504d\r\n    20:     0x7ffe7c187344 - BaseThreadInitThunk\r\n    21:     0x7ffe7cf026b1 - RtlUserThreadStart\r\n\r\n  error: the compiler unexpectedly panicked. this is a bug.\r\n\r\n  note: we would appreciate a bug report: https://github.com/EmbarkStudios/rust-gpu/issues/new\r\n\r\n  note: rustc 1.71.0-nightly (1a5f8bce7 2023-05-26) running on x86_64-pc-windows-msvc\r\n\r\n  note: compiler flags: --crate-type dylib --crate-type lib -C opt-level=3 -C embed-bitcode=no -C codegen-units=1 -Z unstable-options -Z codegen-backend=D:\\Projects\\rust-gpu-compute-example\\target\\debug\\rustc_codegen_spirv.dll -Z binary-dep-depinfo -C symbol-mangling-version=v0 -Z crate-attr=feature(register_tool) -Z crate-attr=register_tool(rust_gpu) -C overflow-checks=off -C debug-assertions=off -Z inline-mir=off -C llvm-args=--no-early-report-zombies --no-infer-storage-classes --spirt-passes=qpt\r\n\r\n  note: some of the compiler flags provided by cargo are hidden\r\n\r\n  query stack during panic:\r\n  end of query stack\r\n  note: `rust-gpu` version `0.9.0`\r\n\r\n  error: could not compile `kernels` (lib)\r\n  thread 'main' panicked at 'Kernel failed to compile: BuildFailed', build.rs:22:10\r\n  note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\r\n  ```\r\n  \r\n Project: https://github.com/pema99/rust-path-tracer/tree/wgpu19 (happens after bumping the spirv-builder dep from 0.8.0 to 0.9.0)\r\n \r\n Any ideas on how I can debug this?",
        "createdAt": "2024-01-24T02:02:42Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/1089#issuecomment-1907226252",
        "viewerDidAuthor": false
      },
      {
        "id": "IC_kwDOENG4485x6YIm",
        "author": {
          "login": "schell"
        },
        "authorAssociation": "NONE",
        "body": "@pema99 Maybe try bisecting your source for instances where functions or structs are using references. It's tedious but that's all I've got. ",
        "createdAt": "2024-01-25T22:57:31Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/1089#issuecomment-1911128614",
        "viewerDidAuthor": false
      },
      {
        "id": "IC_kwDOENG4485yAvFZ",
        "author": {
          "login": "pema99"
        },
        "authorAssociation": "NONE",
        "body": "I'm guessing it's one of these two causing issues. Are you not allowed to store references in structs at all?\r\n\r\n```rs\r\npub struct FixedVec<T, const CAPACITY: usize> {\r\n    pub data: [T; CAPACITY],\r\n    pub len: u32,\r\n}\r\n```\r\n\r\n```rs\r\npub struct BVHReference<'a> {\r\n    pub nodes: &'a [BVHNode],\r\n}\r\n```",
        "createdAt": "2024-01-26T22:48:40Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/1089#issuecomment-1912795481",
        "viewerDidAuthor": false
      },
      {
        "id": "IC_kwDOENG4485yCgwt",
        "author": {
          "login": "pema99"
        },
        "authorAssociation": "NONE",
        "body": "It was actually this:\r\n\r\n```\r\n    pub fn uses_mis(&self) -> bool {\r\n        self == &NextEventEstimation::MultipleImportanceSampling\r\n    }\r\n\r\n    pub fn uses_nee(&self) -> bool {\r\n        self != &NextEventEstimation::None\r\n    }\r\n```\r\n\r\n`self` is a simple enum type. I had to deref it instead of borrowing the literal",
        "createdAt": "2024-01-27T17:04:44Z",
        "includesCreatedEdit": true,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/1089#issuecomment-1913261101",
        "viewerDidAuthor": false
      },
      {
        "id": "IC_kwDOENG4485yEK3b",
        "author": {
          "login": "schell"
        },
        "authorAssociation": "NONE",
        "body": "That's a very similar situation to mine. I had to deref `self` in a similar comparison. Glad you figured it out @pema99 :) ",
        "createdAt": "2024-01-28T19:19:33Z",
        "includesCreatedEdit": true,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/1089#issuecomment-1913695707",
        "viewerDidAuthor": false
      },
      {
        "id": "IC_kwDOENG4485yiaoS",
        "author": {
          "login": "eddyb"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "Figured out why `==` is relevant: [the `PartialEq` implementation for `&T`](https://github.com/rust-lang/rust/blob/11f32b73e0dc9287e305b5b9980d24aecdc8c17f/library/core/src/cmp.rs#L1604-L1617) looks like this:\r\n```rust\r\n        #[inline]\r\n        fn eq(&self, other: &&B) -> bool {\r\n            PartialEq::eq(*self, *other)\r\n        }\r\n        #[inline]\r\n        fn ne(&self, other: &&B) -> bool {\r\n            PartialEq::ne(*self, *other)\r\n        }\r\n```\r\nIf it was using the operators, it would look like `**self == **other` and `**self != **other`.\r\n\r\nIn Rust-GPU `0.8.0` (and possibly a bit before, too), we accidentally allowed MIR inlining to merge that method with your code, _effectively_ giving you the `*self == Foo::Bar` / `*self != Foo:Baz` version that works for you today (and should've always worked).\r\n\r\nIt's unfortunate, and both versions will eventually work, but the version you were using with `self == &...` likely creates a `&'static &'static T` value for no good reason - well, other than `*` is uglier than `&`, so I can empathize on an aesthetic level with the more indirect version.",
        "createdAt": "2024-02-01T15:44:32Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "users": {
              "totalCount": 1
            }
          }
        ],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/1089#issuecomment-1921624594",
        "viewerDidAuthor": false
      }
    ],
    "createdAt": "2023-08-03T20:42:54Z",
    "labels": [
      {
        "id": "MDU6TGFiZWwyMjI3MzM4ODEz",
        "name": "t: bug",
        "description": "Something isn't working",
        "color": "52E8A0"
      }
    ],
    "number": 1089,
    "reactionGroups": [],
    "state": "OPEN",
    "title": "Some shaders that compiled in 0.8 are erring in 0.9 ",
    "url": "https://github.com/EmbarkStudios/rust-gpu/issues/1089"
  },
  {
    "author": {
      "id": "MDQ6VXNlcjI0OTQy",
      "is_bot": false,
      "login": "schell",
      "name": "Schell Carl Scivally"
    },
    "body": "While debugging an issue with nested loops I simplified my shader to one loop as a sanity check and then hit this compiler panic. It seems to be caused by looping indefinitely (in my shader I forgot to increment a value used in the break condition).\r\n\r\n### Expected Behaviour\r\nCompiler should error instead of panic. \r\n\r\n### Actual Behavior\r\nCompiler panics with:\r\n```\r\nthread 'rustc' panicked at 'assertion failed: list_eq_key(children) ==\\n    list_eq_key(self.func_def_body.at(unstructured_region).def().children)',\r\n  /Users/schell/.cargo/registry/src/index.crates.io-6f17d22bba15001f/spirt-0.2.0/src/cfg.rs:1214:13\r\n```\r\n\r\n### Example & Steps To Reproduce\r\nCompile this shader: \r\n\r\n```rust \r\nuse glam::{Vec3, Vec4, Vec4Swizzles, Vec3Swizzles};\r\nuse spirv_std::{image::Cubemap, Sampler, spirv};\r\n\r\n#[cfg(target_arch = \"spirv\")]\r\nuse spirv_std::num_traits::Float;\r\n\r\n#[spirv(fragment)]\r\npub fn fragment_convolve_diffuse_irradiance(\r\n    environment_texture: &Cubemap,\r\n    sampler: &Sampler,\r\n    local_pos: Vec3,\r\n    frag_color: &mut Vec4,\r\n) {\r\n    let pi: f32 = 3.1415927;\r\n\r\n    let normal = local_pos.normalize_or_zero();\r\n    let mut irradiance = Vec3::new(0.0, 0.0, 0.0);\r\n    let right = Vec3::new(0.0, 1.0, 0.0).cross(normal).normalize_or_zero();\r\n    let up = normal.cross(right).normalize_or_zero();\r\n\r\n    let nr_samples = 0.0;\r\n    irradiance += environment_texture.sample(*sampler, up).xyz();\r\n    loop {\r\n        if nr_samples > 2.0 {\r\n            break;\r\n        }\r\n\r\n        irradiance += environment_texture.sample(*sampler, up).xyz();\r\n    }\r\n    let color = irradiance * (pi / nr_samples);\r\n    *frag_color = color.xyz().extend(1.0);\r\n}\r\n```\r\n\r\n## System Info\r\nnote: rustc 1.70.0-nightly (84dd17b56 2023-04-14) running on aarch64-apple-darwin\r\n\r\nnote: compiler flags: --crate-type dylib -C opt-level=3 -C embed-bitcode=no -C codegen-units=1 -Z unstable-options -Z codegen-backend=/Users/schell/code/renderling/shaders/target/release/librustc_codegen_spirv.dylib -Z binary-dep-depinfo -C symbol-mangling-version=v0 -Z crate-attr=feature(register_tool) -Z crate-attr=register_tool(rust_gpu) -C llvm-args=--module-output=multiple\r\n\r\nnote: some of the compiler flags provided by cargo are hidden\r\n\r\nquery stack during panic:\r\nend of query stack\r\nnote: `rust-gpu` version 0.8.0\r\n\r\n\r\n - Rust: [e.g. 1.49.0-nightly (1eaadebb3 2020-10-21)]\r\n - OS: [e.g. macOS 10.15.7]\r\n - GPU: [e.g. Intel(R) UHD Graphics 630]\r\n - SPIR-V: [e.g. v2020.3 unknown hash, 2020-06-12T01:06:18]\r\n\r\n\r\n## Backtrace\r\n<!-- If relevant, please include a backtrace of the error below. -->\r\n\r\n<details><summary>Backtrace</summary>\r\n<p>\r\n\r\n```\r\nstack backtrace:\r\n   0:        0x102eb5894 - <std::sys_common::backtrace::_print::DisplayBacktrace as core::fmt::Display>::fmt::hec12b20601f2bdf0\r\n   1:        0x102f089a0 - core::fmt::write::h84e52a09c8a95be7\r\n   2:        0x102eab344 - std::io::Write::write_fmt::h694b0891aa3b64d5\r\n   3:        0x102eb56a8 - std::sys_common::backtrace::print::hdefc03f01b0d83f1\r\n   4:        0x102eb80bc - std::panicking::default_hook::{{closure}}::hc4c0bdc7bd459aa9\r\n   5:        0x102eb7e7c - std::panicking::default_hook::h6dc5d3ac0202ebe6\r\n   6:        0x10470d6f4 - rustc_codegen_spirv::__rustc_codegen_backend::{{closure}}::h6edd25957ff152e7\r\n   7:        0x102eb877c - std::panicking::rust_panic_with_hook::h04718b2e9bd107f5\r\n   8:        0x102eb8534 - std::panicking::begin_panic_handler::{{closure}}::h1c251c8e7c7e5969\r\n   9:        0x102eb5cb4 - std::sys_common::backtrace::__rust_end_short_backtrace::hc2f6697e294cde53\r\n  10:        0x102eb8308 - _rust_begin_unwind\r\n  11:        0x102f34420 - core::panicking::panic_fmt::hcabee496664f2172\r\n  12:        0x102f34490 - core::panicking::panic::hc56ef5c96c7e745b\r\n  13:        0x1049027e8 - spirt::cfg::Structurizer::structurize_func::h8ccbca14134c4bed\r\n  14:        0x10488ac74 - spirt::passes::legalize::structurize_func_cfgs::h5a9bb2f8c14010b3\r\n  15:        0x1046b6974 - rustc_codegen_spirv::linker::link::h666c87acc0f36829\r\n  16:        0x10465bae0 - rustc_codegen_spirv::link::link::h87c14272e01e3168\r\n  17:        0x10470bf54 - <rustc_codegen_spirv::SpirvCodegenBackend as rustc_codegen_ssa::traits::backend::CodegenBackend>::link::ha3f63258b51407e5\r\n  18:        0x10b47f7f8 - <rustc_interface[b2f1c94be2f1d7cc]::queries::Linker>::link\r\n  19:        0x10b3b3da4 - rustc_span[dc18a910ba5122f1]::set_source_map::<core[723a1ab69fb7b501]::result::Result<(), rustc_span[dc18a910ba5122f1]::ErrorGuaranteed>, rustc_interface[b2f1c94be2f1d7cc]::interface::run_compiler<core[723a1ab69fb7b501]::result::Result<(), rustc_span[dc18a910ba5122f1]::ErrorGuaranteed>, rustc_driver_impl[27bd541b75fbd8b5]::run_compiler::{closure#1}>::{closure#0}::{closure#0}>\r\n  20:        0x10b3c7184 - std[b04369226ecd3a5b]::sys_common::backtrace::__rust_begin_short_backtrace::<rustc_interface[b2f1c94be2f1d7cc]::util::run_in_thread_pool_with_globals<rustc_interface[b2f1c94be2f1d7cc]::interface::run_compiler<core[723a1ab69fb7b501]::result::Result<(), rustc_span[dc18a910ba5122f1]::ErrorGuaranteed>, rustc_driver_impl[27bd541b75fbd8b5]::run_compiler::{closure#1}>::{closure#0}, core[723a1ab69fb7b501]::result::Result<(), rustc_span[dc18a910ba5122f1]::ErrorGuaranteed>>::{closure#0}::{closure#0}, core[723a1ab69fb7b501]::result::Result<(), rustc_span[dc18a910ba5122f1]::ErrorGuaranteed>>\r\n  21:        0x10b3b8364 - <<std[b04369226ecd3a5b]::thread::Builder>::spawn_unchecked_<rustc_interface[b2f1c94be2f1d7cc]::util::run_in_thread_pool_with_globals<rustc_interface[b2f1c94be2f1d7cc]::interface::run_compiler<core[723a1ab69fb7b501]::result::Result<(), rustc_span[dc18a910ba5122f1]::ErrorGuaranteed>, rustc_driver_impl[27bd541b75fbd8b5]::run_compiler::{closure#1}>::{closure#0}, core[723a1ab69fb7b501]::result::Result<(), rustc_span[dc18a910ba5122f1]::ErrorGuaranteed>>::{closure#0}::{closure#0}, core[723a1ab69fb7b501]::result::Result<(), rustc_span[dc18a910ba5122f1]::ErrorGuaranteed>>::{closure#1} as core[723a1ab69fb7b501]::ops::function::FnOnce<()>>::call_once::{shim:vtable#0}\r\n  22:        0x102ec0e24 - std::sys::unix::thread::Thread::new::thread_start::h5343322b5f9311e3\r\n  23:        0x18df97fa8 - __pthread_joiner_wake\r\n\r\n```\r\n\r\n</p>\r\n</details>\r\n",
    "comments": [
      {
        "id": "IC_kwDOENG4485ipRR1",
        "author": {
          "login": "eddyb"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "I've edited the description and title to explicitly mention the message.\r\n\r\nThis is a \"known\" panic I have yet to investigate because so far I've only hit it with `RUSTGPU_CODEGEN_ARGS=--no-early-report-zombies`, which can let some malformed SPIR-V `rustc_codegen_spirv` generates through, so I just assumed that was the cause here.\r\n\r\nIf it can happen without `RUSTGPU_CODEGEN_ARGS`, then this deserves a lot more scrutiny. I'll attempt to minimize the testcase provided (~~is it complete though? there's no `#[spirv(...)]`, so that's just dead code?~~ **EDIT**: was just a missing `#[spirv(fragment)]`, added that to the issue description, can confirm it repros).",
        "createdAt": "2023-07-28T04:31:27Z",
        "includesCreatedEdit": true,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/1086#issuecomment-1654985845",
        "viewerDidAuthor": false
      },
      {
        "id": "IC_kwDOENG4485ipfju",
        "author": {
          "login": "eddyb"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "This reduces somewhat bizarrely:\r\n```rust\r\nuse spirv_std::spirv;\r\n\r\n#[inline(never)]\r\nfn bug(cond: bool) {\r\n    if (if cond { true } else { false }) {}\r\n    loop {}\r\n}\r\n\r\n#[spirv(fragment)]\r\npub fn main() {\r\n    bug(false);\r\n}\r\n```\r\n\r\nI'll have to move `--dump-spirt-passes` into a helper type that implements `Drop` so panics don't stop it from showing useful information (in general it seems sensible to do that sort of thing, just because removing 100% of possible panics is hard, esp. before we have a SPIR-T validator).",
        "createdAt": "2023-07-28T05:28:55Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/1086#issuecomment-1655044334",
        "viewerDidAuthor": false
      },
      {
        "id": "IC_kwDOENG4485i_ukK",
        "author": {
          "login": "eddyb"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "Starting to suspect it's in part caused by [this structurizer special-casing](https://github.com/EmbarkStudios/spirt/blob/81e30fe67e4c323c9f6bffd1b51c5c924bea15d5/src/cfg.rs#L425-L440), which has a `FIXME`:\r\n```rust\r\n            // Structured return, the function is fully structurized.\r\n            //\r\n            // FIXME(eddyb) also support structured return when the whole body\r\n            // is divergent, by generating undef constants (needs access to the\r\n            // whole `FuncDecl`, not just `FuncDefBody`, to get the right types).\r\n```\r\nI forgot about this since, because it apparently never(?) caused any issues in practice, but e.g. \"always reach an infinite loop\" Rust-GPU shaders wouldn't end up 100% structured - my best guess for why `spirv-val` doesn't complain is that the actual body *is* structured, there's just a single unstructured branch at the very start, which SPIR-V doesn't care about (\"structured SPIR-V\" only puts requirements on *merging* selects/loops).",
        "createdAt": "2023-08-01T18:33:35Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "users": {
              "totalCount": 1
            }
          }
        ],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/1086#issuecomment-1660872970",
        "viewerDidAuthor": false
      }
    ],
    "createdAt": "2023-07-28T01:00:19Z",
    "labels": [
      {
        "id": "MDU6TGFiZWwyMjI3MzM4ODEz",
        "name": "t: bug",
        "description": "Something isn't working",
        "color": "52E8A0"
      }
    ],
    "number": 1086,
    "reactionGroups": [],
    "state": "OPEN",
    "title": "SPIR-T panics with assertion failed: list_eq_key(children) ==\\n    list_eq_key(self.func_def_body.at(unstructured_region).def().children).",
    "url": "https://github.com/EmbarkStudios/rust-gpu/issues/1086"
  },
  {
    "author": {
      "id": "MDQ6VXNlcjMwNDg5MzM=",
      "is_bot": false,
      "login": "kevinboulain",
      "name": "Kevin Boulain"
    },
    "body": "As far as I can tell, the workgroup/shared memory ([context](https://github.com/EmbarkStudios/rust-gpu/issues/695)) can not be declared as to be zero-initialized and one has to do it manually.\r\n\r\nhttps://github.com/KhronosGroup/Vulkan-Docs/issues/1457 has a bunch of interesting links: the extension [`VK_KHR_zero_initialize_workgroup_memory`](https://github.com/KhronosGroup/Vulkan-Guide/blob/main/chapters/extensions/shader_features.adoc#vk_khr_zero_initialize_workgroup_memory) (promoted to core in Vulkan 1.3) allows to declare workgroup/shared variables with a [null initializer](https://github.com/KhronosGroup/VK-GL-CTS/blob/1d91116914824bc86bbf4d1a597be1bbb9e495c7/external/vulkancts/modules/vulkan/compute/vktComputeZeroInitializeWorkgroupMemoryTests.cpp#L232). On the SPIR-V side, [`OpVariable`](https://registry.khronos.org/SPIR-V/specs/unified1/SPIRV.html#OpVariable) with a `Workgroup` storage class is allowed to be initialized with [`OpConstantNull`](https://registry.khronos.org/SPIR-V/specs/unified1/SPIRV.html#OpConstantNull) only ([like so](https://github.com/alan-baker/SPIRV-Tools/blob/126c518aa78fc1972eed30f09bfed6f77b74c2d2/test/val/val_memory_test.cpp#L4120-L4121)).\r\n\r\nI don't know what the project would prefer, it could be an option to pass to the `SpirvBuilder` (I assume it could be desirable to always initialize these variables) or another symbol (similarly to how `storage_buffer` allows extra arguments): \r\n```rust\r\n#[spirv(compute(threads(256)))]  \r\nfn compute(\r\n    #[spirv(workgroup, null_initialized = true)] array: &mut [u32; N],\r\n    // ...\r\n) {\r\n  // ...\r\n}\r\n```\r\n",
    "comments": [
      {
        "id": "IC_kwDOENG4485gsD_8",
        "author": {
          "login": "Patryk27"
        },
        "authorAssociation": "NONE",
        "body": "Btw, [since recently](https://github.com/gfx-rs/naga/pull/2111), Naga automatically includes some glue code that zero-initializes workgroup memory.",
        "createdAt": "2023-07-05T17:09:35Z",
        "includesCreatedEdit": true,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/1077#issuecomment-1622163452",
        "viewerDidAuthor": false
      },
      {
        "id": "IC_kwDOENG4485g5duP",
        "author": {
          "login": "kevinboulain"
        },
        "authorAssociation": "NONE",
        "body": "Yeah, but unless I'm handling it wrong, it doesn't support a bunch of features and that limit its usefulness (e.g.: subgroups or atomics).",
        "createdAt": "2023-07-07T16:44:29Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/1077#issuecomment-1625676687",
        "viewerDidAuthor": false
      }
    ],
    "createdAt": "2023-07-04T20:07:53Z",
    "labels": [
      {
        "id": "MDU6TGFiZWwyMjI3MzM4ODE2",
        "name": "t: enhancement",
        "description": "A new feature or improvement to an existing one.",
        "color": "52E8A0"
      }
    ],
    "number": 1077,
    "reactionGroups": [],
    "state": "OPEN",
    "title": "Initializing workgroup memory",
    "url": "https://github.com/EmbarkStudios/rust-gpu/issues/1077"
  },
  {
    "author": {
      "id": "MDQ6VXNlcjMzOTU0Nzc=",
      "is_bot": false,
      "login": "Patryk27",
      "name": "Patryk Wychowaniec"
    },
    "body": "Hi,\r\n\r\nCompiling this code:\r\n\r\n```rust\r\n#[spirv(compute(threads(8, 8)))]\r\npub fn main(#[spirv(descriptor_set = 0, binding = 0)] out: TexRgba32f) {\r\n    let mut value = vec3(0.1, 0.2, 0.3);\r\n    let mut i = 0;\r\n\r\n    loop {\r\n        if i >= 32 {\r\n            break;\r\n        }\r\n\r\n        i += 1;\r\n    }\r\n\r\n    unsafe {\r\n        out.write(uvec2(0, 0), value.extend(1.0));\r\n    }\r\n}\r\n```\r\n\r\n... will work, but adding a seemingly no-op `value = value` into that loop:\r\n\r\n```rust\r\nloop {\r\n    value = value;\r\n\r\n    if i >= 32 {\r\n        break;\r\n    }\r\n\r\n    i += 1;\r\n}\r\n```\r\n\r\n... will panic the compiler, saying:\r\n\r\n```\r\nerror: malformed SPIR-V (in OpCompositeExtract: undefined ID %4547)\r\n```\r\n\r\nMeta:\r\n\r\n```\r\nrustc 1.71.0-nightly (1a5f8bce7 2023-05-26)\r\nSPIRV-Tools v2023.2 unknown hash, 1980-01-01T00:00:00\r\n```",
    "comments": [
      {
        "id": "IC_kwDOENG4485fHBnX",
        "author": {
          "login": "Patryk27"
        },
        "authorAssociation": "NONE",
        "body": "fwiw, an assignment after (or before) the loop triggers this error as well:\r\n\r\n```rust\r\n#[spirv(compute(threads(8, 8)))]\r\npub fn main(#[spirv(descriptor_set = 0, binding = 0)] out: TexRgba32f) {\r\n    let mut val = vec3(0.1, 0.2, 0.3);\r\n    let mut i = 0;\r\n\r\n    while i < 10 {\r\n        i += 1;\r\n    }\r\n\r\n    val = val;\r\n\r\n    unsafe {\r\n        out.write(uvec2(0, 0), val.extend(1.0));\r\n    }\r\n}\r\n```",
        "createdAt": "2023-06-17T08:51:31Z",
        "includesCreatedEdit": true,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/1076#issuecomment-1595677143",
        "viewerDidAuthor": false
      },
      {
        "id": "IC_kwDOENG4485iwvRJ",
        "author": {
          "login": "schell"
        },
        "authorAssociation": "NONE",
        "body": "@Patryk27 I think there's something up with `while` loops and loops with `loop { if ... { break; } }` because I have a number of shaders that work with `for i in range` that _won't_ work with any other looping mechanism.",
        "createdAt": "2023-07-29T22:53:49Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/1076#issuecomment-1656943689",
        "viewerDidAuthor": false
      }
    ],
    "createdAt": "2023-06-16T15:19:59Z",
    "labels": [
      {
        "id": "MDU6TGFiZWwyMjI3MzM4ODEz",
        "name": "t: bug",
        "description": "Something isn't working",
        "color": "52E8A0"
      }
    ],
    "number": 1076,
    "reactionGroups": [],
    "state": "OPEN",
    "title": "Malformed SPIR-V when compiling a simple loop",
    "url": "https://github.com/EmbarkStudios/rust-gpu/issues/1076"
  },
  {
    "author": {
      "id": "MDQ6VXNlcjMwNDg5MzM=",
      "is_bot": false,
      "login": "kevinboulain",
      "name": "Kevin Boulain"
    },
    "body": "### Expected Behaviour\r\n\r\nThis compiles fine with rustc (I guess this bit is probably eliminated?).\r\n\r\n### Example & Steps To Reproduce\r\n\r\nI was using const generic parameters to determine the length of some arrays. At some point, a base case ended up declaring a zero-length array, like so:\r\n\r\n```rust\r\n#![cfg_attr(target_arch = \"spirv\", no_std)]\r\nuse spirv_std::spirv;\r\n\r\nfn example<const LENGTH: usize>() {\r\n    let mut array = [0; LENGTH];\r\n    for i in 0..array.len() {\r\n        array[i] += i;\r\n    }\r\n}\r\n\r\n#[spirv(compute(threads(1, 1, 1)))]\r\npub fn compute() {\r\n    example::<0>();\r\n}\r\n```\r\n\r\nResulting in:\r\n```\r\nerror: GEP not implemented for type struct [usize; 0] {  }\r\n --> examples/shaders/compute-shader/src/lib.rs:7:9\r\n  |\r\n7 |         array[i] += i;\r\n  |         ^^^^^^^^^^^^^\r\n```\r\n\r\n## System Info\r\n<!--\r\nHelpful commands:\r\n- Rustc version: `rustc -V`\r\n- SPIR-V version: `spirv-val --version`\r\n-->\r\n\r\n - rustc: 1.71.0-nightly (1a5f8bce7 2023-05-26)\r\n - rust-gpu: b2e5eb7\r\n",
    "comments": [
      {
        "id": "IC_kwDOENG4485fN5Ml",
        "author": {
          "login": "kevinboulain"
        },
        "authorAssociation": "NONE",
        "body": "A slight modification of the previous example can also result in a division by zero in the compiler (can open another issue if you prefer):\r\n```rust\r\n#![cfg_attr(target_arch = \"spirv\", no_std)]\r\nuse spirv_std::spirv;\r\n\r\nfn example<const LENGTH: usize, R: Copy + Default>(callback: impl Fn() -> R) {\r\n    let mut array = [Default::default(); LENGTH];\r\n    for i in 0..array.len() {\r\n        array[i] = callback();\r\n    }\r\n}\r\n\r\n#[spirv(compute(threads(1, 1, 1)))]\r\npub fn compute() {\r\n    example::<10, ()>(|| ());\r\n}\r\n```\r\n\r\n```\r\nthread 'rustc' panicked at 'attempt to divide by zero', crates/rustc_codegen_spirv/src/builder/builder_methods.rs:441:34\r\nstack backtrace:\r\n   0: rust_begin_unwind\r\n             at /rustc/1a5f8bce74ee432f7cc3aa131bc3d6920e06de10/library/std/src/panicking.rs:578:5\r\n   1: core::panicking::panic_fmt\r\n             at /rustc/1a5f8bce74ee432f7cc3aa131bc3d6920e06de10/library/core/src/panicking.rs:67:14\r\n   2: core::panicking::panic\r\n             at /rustc/1a5f8bce74ee432f7cc3aa131bc3d6920e06de10/library/core/src/panicking.rs:117:5\r\n   3: rustc_codegen_spirv::builder::builder_methods::<impl rustc_codegen_spirv::builder::Builder>::recover_access_chain_from_offset\r\n             at ./crates/rustc_codegen_spirv/src/builder/builder_methods.rs:441:34\r\n   4: rustc_codegen_spirv::builder::builder_methods::<impl rustc_codegen_ssa::traits::builder::BuilderMethods for rustc_codegen_spirv::builder::Builder>::pointercast\r\n             at ./crates/rustc_codegen_spirv/src/builder/builder_methods.rs:1624:13\r\n   5: rustc_codegen_ssa::base::unsize_ptr\r\n             at /rustc/1a5f8bce74ee432f7cc3aa131bc3d6920e06de10/compiler/rustc_codegen_ssa/src/base.rs:225:14\r\n   6: rustc_codegen_ssa::mir::rvalue::<impl rustc_codegen_ssa::mir::FunctionCx<Bx>>::codegen_rvalue_operand\r\n             at /rustc/1a5f8bce74ee432f7cc3aa131bc3d6920e06de10/compiler/rustc_codegen_ssa/src/mir/rvalue.rs:462:29\r\n   7: rustc_codegen_ssa::mir::statement::<impl rustc_codegen_ssa::mir::FunctionCx<Bx>>::codegen_statement\r\n             at /rustc/1a5f8bce74ee432f7cc3aa131bc3d6920e06de10/compiler/rustc_codegen_ssa/src/mir/statement.rs:22:43\r\n   8: rustc_codegen_ssa::mir::block::<impl rustc_codegen_ssa::mir::FunctionCx<Bx>>::codegen_block\r\n             at /rustc/1a5f8bce74ee432f7cc3aa131bc3d6920e06de10/compiler/rustc_codegen_ssa/src/mir/block.rs:1178:17\r\n   9: rustc_codegen_ssa::mir::codegen_mir\r\n             at /rustc/1a5f8bce74ee432f7cc3aa131bc3d6920e06de10/compiler/rustc_codegen_ssa/src/mir/mod.rs:272:9\r\n  10: rustc_codegen_ssa::base::codegen_instance\r\n             at /rustc/1a5f8bce74ee432f7cc3aa131bc3d6920e06de10/compiler/rustc_codegen_ssa/src/base.rs:395:5\r\n  11: <rustc_middle::mir::mono::MonoItem as rustc_codegen_ssa::mono_item::MonoItemExt>::define\r\n             at /rustc/1a5f8bce74ee432f7cc3aa131bc3d6920e06de10/compiler/rustc_codegen_ssa/src/mono_item.rs:91:17\r\n  12: <rustc_codegen_spirv::SpirvCodegenBackend as rustc_codegen_ssa::traits::backend::ExtraBackendMethods>::compile_codegen_unit::{{closure}}\r\n             at ./crates/rustc_codegen_spirv/src/lib.rs:438:17\r\n  13: <rustc_codegen_spirv::SpirvCodegenBackend as rustc_codegen_ssa::traits::backend::ExtraBackendMethods>::compile_codegen_unit\r\n             at ./crates/rustc_codegen_spirv/src/lib.rs:450:36\r\n  14: rustc_codegen_ssa::base::codegen_crate\r\n             at /rustc/1a5f8bce74ee432f7cc3aa131bc3d6920e06de10/compiler/rustc_codegen_ssa/src/base.rs:728:34\r\n  15: <rustc_codegen_spirv::SpirvCodegenBackend as rustc_codegen_ssa::traits::backend::CodegenBackend>::codegen_crate\r\n             at ./crates/rustc_codegen_spirv/src/lib.rs:241:18\r\n  16: <rustc_session::session::Session>::time::<alloc::boxed::Box<dyn core::any::Any>, rustc_interface::passes::start_codegen::{closure#0}>\r\n  17: rustc_interface::passes::start_codegen\r\n  18: <rustc_middle::ty::context::GlobalCtxt>::enter::<<rustc_interface::queries::Queries>::ongoing_codegen::{closure#0}::{closure#0}, core::result::Result<alloc::boxed::Box<dyn core::any::Any>, rustc_span::ErrorGuaranteed>>\r\n  19: <rustc_interface::queries::Queries>::ongoing_codegen\r\n  20: <rustc_interface::interface::Compiler>::enter::<rustc_driver_impl::run_compiler::{closure#1}::{closure#2}, core::result::Result<core::option::Option<rustc_interface::queries::Linker>, rustc_span::ErrorGuaranteed>>\r\nnote: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.\r\n\r\nerror: the compiler unexpectedly panicked. this is a bug.\r\n\r\nnote: we would appreciate a bug report: https://github.com/EmbarkStudios/rust-gpu/issues/new\r\n\r\nnote: rustc 1.71.0-nightly (1a5f8bce7 2023-05-26) running on x86_64-unknown-linux-gnu\r\n\r\nnote: compiler flags: --crate-type dylib --crate-type lib -C opt-level=3 -C embed-bitcode=no -C codegen-units=1 -C incremental=[REDACTED] -Z unstable-options -Z codegen-backend=.../rust-gpu/target/debug/deps/librustc_codegen_spirv.so -Z binary-dep-depinfo -C symbol-mangling-version=v0 -Z crate-attr=feature(register_tool) -Z crate-attr=register_tool(rust_gpu) -C overflow-checks=off -C debug-assertions=off\r\n\r\nnote: some of the compiler flags provided by cargo are hidden\r\n\r\nquery stack during panic:\r\nend of query stack\r\nnote: `rust-gpu` version `0.8.0`\r\n```\r\n",
        "createdAt": "2023-06-19T16:43:54Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/1075#issuecomment-1597477669",
        "viewerDidAuthor": false
      },
      {
        "id": "IC_kwDOENG4485ojb1b",
        "author": {
          "login": "JoelCourtney"
        },
        "authorAssociation": "NONE",
        "body": "I also encountered the `attempt to divide by zero` error. I made [this change](https://github.com/JoelCourtney/rust-gpu/commit/044f5673f32d814e00e90efa59221a5cd725bcd1) on a fork and the build succeeded and appeared to work.\r\n\r\nI'm not opening a PR though because I made that change blindly (I'm not familiar with the internals of rust-gpu and have no idea what's going on :), so I'm not confident that it's sound.",
        "createdAt": "2023-10-10T00:41:38Z",
        "includesCreatedEdit": true,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/1075#issuecomment-1754119515",
        "viewerDidAuthor": false
      },
      {
        "id": "IC_kwDOENG4485yYY-Q",
        "author": {
          "login": "eddyb"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "> I made [this change](https://github.com/JoelCourtney/rust-gpu/commit/044f5673f32d814e00e90efa59221a5cd725bcd1) on a fork and the build succeeded and appeared to work.\r\n\r\nOh, that looks great! (I would only replace the panic but I haven't checked yet what's valid at that position)\r\n\r\n<sub>(sorry for not seeing this sooner, up until more recently the only way to guarantee I'd actually get notified would be to use `@eddyb` or ping me on Discord)</sub>",
        "createdAt": "2024-01-31T12:18:19Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/1075#issuecomment-1918996368",
        "viewerDidAuthor": false
      }
    ],
    "createdAt": "2023-06-16T09:49:20Z",
    "labels": [
      {
        "id": "MDU6TGFiZWwyMjI3MzM4ODEz",
        "name": "t: bug",
        "description": "Something isn't working",
        "color": "52E8A0"
      }
    ],
    "number": 1075,
    "reactionGroups": [],
    "state": "OPEN",
    "title": "GEP not implemented for type struct [_; 0] ",
    "url": "https://github.com/EmbarkStudios/rust-gpu/issues/1075"
  },
  {
    "author": {
      "id": "MDQ6VXNlcjI1ODg4NTE=",
      "is_bot": false,
      "login": "jansol",
      "name": ""
    },
    "body": "While trying to get `texpresso` to compile to SPIR-V I very early on encountered an error about a missing `OpCapability Int8`.\r\n\r\nAfter some searching around I eventually found out how to fix this, but it would be nice if the error message could point users towards the right API, i.e. in this case `SpirvBuilder.capability(spirv_builder::capability::Cap)`",
    "comments": [],
    "createdAt": "2023-06-07T19:53:52Z",
    "labels": [
      {
        "id": "MDU6TGFiZWwyMjI3MzM4ODE2",
        "name": "t: enhancement",
        "description": "A new feature or improvement to an existing one.",
        "color": "52E8A0"
      }
    ],
    "number": 1072,
    "reactionGroups": [
      {
        "content": "THUMBS_UP",
        "users": {
          "totalCount": 1
        }
      }
    ],
    "state": "OPEN",
    "title": "Point users towards correct fix for \"missing capability\" errors",
    "url": "https://github.com/EmbarkStudios/rust-gpu/issues/1072"
  },
  {
    "author": {
      "id": "MDQ6VXNlcjQzODg2ODg=",
      "is_bot": false,
      "login": "Keavon",
      "name": "Keavon Chambers"
    },
    "body": "While the GPU provides hardware for texture sampling and interpolation, on other targets (i.e. CPU in general) it's necessary to emulate that. Currently, the `Image` and `Sampler` APIs don't provide texture sampling operations when compiling to non-SPIRV targets.\r\n\r\nWe need this for [an issue on Graphite](https://github.com/GraphiteEditor/Graphite/issues/1247) to support image transformation with graceful CPU fallback (even if the performance would be not ideal), since WebGPU is only available on Chromium browsers for now and thus CPU is still an important target. Having this feature be as performant as possible would be eventually nice, but a slower solution would be a reasonable starting point of greater priority to our use case (something is better than nothing, existing is better than fast).\r\n\r\nThis issue [was discussed](https://discord.com/channels/750717012564770887/750717499737243679/1097046635789434940) in the Embark Discord.\r\n\r\nAlso on Discord before filing this issue, @eddyb summarized some recollection of the potential main three main concerns involved:\r\n\r\n> how to feed data into the API, how the API stores the data internally, and how the sampling is implemented - with the middle one, with its potential need to add lifetimes, and/or remove Copy & use Arc, being the worst part, since at least unoptimized sampling is mostly \"just\" looking up 4 texels and interpolating them",
    "comments": [],
    "createdAt": "2023-05-26T16:12:52Z",
    "labels": [
      {
        "id": "MDU6TGFiZWwyMjI3MzM4ODE2",
        "name": "t: enhancement",
        "description": "A new feature or improvement to an existing one.",
        "color": "52E8A0"
      }
    ],
    "number": 1065,
    "reactionGroups": [
      {
        "content": "THUMBS_UP",
        "users": {
          "totalCount": 4
        }
      },
      {
        "content": "HEART",
        "users": {
          "totalCount": 2
        }
      }
    ],
    "state": "OPEN",
    "title": "Emulate Image/Sampler API operations on non-SPIRV platforms",
    "url": "https://github.com/EmbarkStudios/rust-gpu/issues/1065"
  },
  {
    "author": {
      "id": "MDQ6VXNlcjI2MTk0OTkx",
      "is_bot": false,
      "login": "charles-r-earp",
      "name": ""
    },
    "body": "Initializing arrays seems to replace 0i32 with 0u32 when using [0i32; N].\r\n\r\nExample (see https://github.com/charles-r-earp/rust-gpu/tree/array-init for compiletests).\r\n```\r\n; SPIR-V\r\n; Version: 1.3\r\n; Generator: Google rspirv; 0\r\n; Bound: 11\r\n; Schema: 0\r\n               OpCapability Shader\r\n               OpCapability Float64\r\n               OpCapability Int64\r\n               OpCapability Int16\r\n               OpCapability Int8\r\n               OpCapability ShaderClockKHR\r\n               OpExtension \"SPV_KHR_shader_clock\"\r\n               OpMemoryModel Logical Simple\r\n               OpEntryPoint Fragment %1 \"main\" %o\r\n               OpExecutionMode %1 OriginUpperLeft\r\n          %3 = OpString \"/home/charles/Documents/rust/rust-gpu/tests/ui/lang/core/array/init_array_i32.rs\"\r\n               OpSource Unknown 0 %3 \"// Test creating an array.\r\n// build-pass\r\n\r\nuse spirv_std::macros::spirv;\r\n\r\n#[spirv(fragment)]\r\npub fn main(o: &mut i32) {\r\n    let array = [0i32; 4];\r\n    *o = array[0];\r\n}\r\n\"\r\n               OpName %o \"o\"\r\n               OpDecorate %o Location 0\r\n        %int = OpTypeInt 32 1\r\n%_ptr_Output_int = OpTypePointer Output %int\r\n       %void = OpTypeVoid\r\n          %7 = OpTypeFunction %void\r\n          %o = OpVariable %_ptr_Output_int Output\r\n       %uint = OpTypeInt 32 0\r\n     %uint_0 = OpConstant %uint 0\r\n          %1 = OpFunction %void None %7\r\n         %10 = OpLabel\r\n               OpLine %3 9 4\r\n               OpStore %o %uint_0\r\n               OpNoLine\r\n               OpReturn\r\n               OpFunctionEnd\r\n```\r\nA 0u32 is stored to `o` instead of the expected 0i32, which fails to compile. \r\n\r\nWhat works:\r\n- f32, this seems to be an issue with signed integers\r\n- `<[T; N]>::default()`\r\n- An explicit list, `[0i32, 0i32, ..]`\r\n-  Using 1 instead of 0, `[1i32; 1]`\r\n\r\n",
    "comments": [],
    "createdAt": "2023-05-21T05:56:49Z",
    "labels": [
      {
        "id": "MDU6TGFiZWwyMjI3MzM4ODEz",
        "name": "t: bug",
        "description": "Something isn't working",
        "color": "52E8A0"
      }
    ],
    "number": 1061,
    "reactionGroups": [],
    "state": "OPEN",
    "title": "Array init with 0i32 uses 0u32 instead.",
    "url": "https://github.com/EmbarkStudios/rust-gpu/issues/1061"
  },
  {
    "author": {
      "id": "MDQ6VXNlcjE5MzE2MDg1",
      "is_bot": false,
      "login": "beepster4096",
      "name": "beepster"
    },
    "body": "<!-- Thank you for filing a bug report! üêõ -->\r\n\r\n### Expected Behaviour\r\n<!-- Please describe what you expected to happen. -->\r\nSuccessful compilation\r\n\r\n### Example & Steps To Reproduce\r\n<!-- \r\nDescribe what actually happened, including any relevant examples (smaller\r\nthe better), error messages, or the relevant SPIR-V binary. \r\n-->\r\n\r\n```rust\r\n#![no_std]\r\n\r\n#[track_caller]\r\nfn panic() {\r\n    panic!(\"owo\")\r\n}\r\n\r\n#[spirv_std::spirv(fragment)]\r\npub fn main() {\r\n    panic();\r\n}\r\n```\r\nproduces\r\n```\r\nerror: function pointer types are not allowed\r\n   --> \r\nC:\\Users\\DrMeepster\\.rustup\\toolchains\\nightly-2023-03-04-x86_64-pc-windows-msvc\\lib\\rustlib\\src\\rust\\library\\core\\src\\fmt\\mod.rs:401:5\r\n    |\r\n401 |     pub const fn new_v1(pieces: &'a [&'static str], args: &'a [ArgumentV1<'a>]) -> Arguments<'a> {\r\n    |     ^\r\n    |\r\n\r\nerror: cannot cast between pointer types\r\n       from `*struct core::option::Option<&[core::fmt::rt::v1::Argument]> { *[struct core::fmt::rt::v1::Argument { position: u32, \r\nformat: struct core::fmt::rt::v1::FormatSpec { precision: struct core::fmt::rt::v1::Count { u32, u32 }, width: struct \r\ncore::fmt::rt::v1::Count { u32, u32 }, flags: u32, fill: u32, align: u8 } }], u32 }`\r\n         to `**struct fn(&[&'static str], &[core::fmt::ArgumentV1<'_>]) -> core::fmt::Arguments<'_> \r\n{core::fmt::Arguments::<'_>::new_v1} {  }`\r\n   --> \r\nC:\\Users\\DrMeepster\\.rustup\\toolchains\\nightly-2023-03-04-x86_64-pc-windows-msvc\\lib\\rustlib\\src\\rust\\library\\core\\src\\fmt\\mod.rs:405:34\r\n    |\r\n405 |         Arguments { pieces, fmt: None, args }\r\n    |                                  ^\r\n    |\r\n\r\nerror: cannot cast between pointer types\r\n       from `*[struct &str { *[u8], u32 }; 1]`\r\n         to `*[struct &str { *[u8], u32 }]`\r\n  --> \r\nC:\\Users\\DrMeepster\\.rustup\\toolchains\\nightly-2023-03-04-x86_64-pc-windows-msvc\\lib\\rustlib\\src\\rust\\library\\core\\src\\panic.rs:57:38\r\n   |\r\n57 |         $crate::panicking::panic_fmt($crate::const_format_args!($($t)+))\r\n   |                                      ^\r\n   |\r\n\r\nerror: cannot cast between pointer types\r\n       from `*struct ! {  }`\r\n         to `*[struct core::fmt::ArgumentV1<'_> { value: *struct core::fmt::Opaque {  }, formatter: *fn(*struct core::fmt::Opaque {  }, \r\n*struct core::fmt::Formatter<'_> { buf: struct &mut dyn core::fmt::Write { *struct dyn core::fmt::Write {  }, *[u32; 3] }, width: \r\nstruct core::option::Option<usize> { u32, u32 }, precision: struct core::option::Option<usize> { u32, u32 }, flags: u32, fill: u32, \r\nalign: u8 }) -> bool }]`\r\n  --> \r\nC:\\Users\\DrMeepster\\.rustup\\toolchains\\nightly-2023-03-04-x86_64-pc-windows-msvc\\lib\\rustlib\\src\\rust\\library\\core\\src\\panic.rs:57:38\r\n   |\r\n57 |         $crate::panicking::panic_fmt($crate::const_format_args!($($t)+))\r\n   |                                      ^\r\n   |\r\n```\r\n\r\n## System Info\r\n<!--\r\nHelpful commands:\r\n- Rustc version: `rustc -V`\r\n- SPIR-V version: `spirv-val --version`\r\n-->\r\n\r\n - Rust: 1.69.0-nightly (44cfafe2f 2023-03-03)\r\n - OS: Windows 11 10.0.22621\r\n - GPU: NVIDIA GeForce RTX 3070 Laptop\r\n\r\n## Backtrace\r\n<!-- If relevant, please include a backtrace of the error below. -->\r\n\r\n<details><summary>Backtrace</summary>\r\n<p>\r\n\r\n```\r\nerror: function pointer types are not allowed\r\n   --> \r\nC:\\Users\\DrMeepster\\.rustup\\toolchains\\nightly-2023-03-04-x86_64-pc-windows-msvc\\lib\\rustlib\\src\\rust\\library\\core\\src\\fmt\\mod.rs:401:5\r\n    |\r\n401 |     pub const fn new_v1(pieces: &'a [&'static str], args: &'a [ArgumentV1<'a>]) -> Arguments<'a> {\r\n    |     ^\r\n    |\r\n    = note: used by `core::fmt::ArgumentV1<'_>`\r\n    = note: used by unnamed global (%31)\r\n    = note: used by unnamed global (%32)\r\n    = note: used by `&[core::fmt::ArgumentV1<'_>]`\r\n    = note: used by `core::fmt::Arguments<'_>`\r\nnote: used from within `gpu::panic`\r\n   --> \r\nC:\\Users\\DrMeepster\\.rustup\\toolchains\\nightly-2023-03-04-x86_64-pc-windows-msvc\\lib\\rustlib\\src\\rust\\library\\core\\src\\panic.rs:57:38\r\n    |\r\n57  |         $crate::panicking::panic_fmt($crate::const_format_args!($($t)+))\r\n    |                                      ^\r\nnote: called by `gpu::main`\r\n   --> gpu\\src\\lib.rs:10:5\r\n    |\r\n10  |     panic();\r\n    |     ^\r\nnote: called by `main`\r\n   --> gpu\\src\\lib.rs:8:1\r\n    |\r\n8   | #[spirv_std::spirv(fragment)]\r\n    | ^\r\n\r\nerror: cannot cast between pointer types\r\n       from `*struct core::option::Option<&[core::fmt::rt::v1::Argument]> { *[struct core::fmt::rt::v1::Argument { position: u32, \r\nformat: struct core::fmt::rt::v1::FormatSpec { precision: struct core::fmt::rt::v1::Count { u32, u32 }, width: struct \r\ncore::fmt::rt::v1::Count { u32, u32 }, flags: u32, fill: u32, align: u8 } }], u32 }`\r\n         to `**struct fn(&[&'static str], &[core::fmt::ArgumentV1<'_>]) -> core::fmt::Arguments<'_> \r\n{core::fmt::Arguments::<'_>::new_v1} {  }`\r\n   --> \r\nC:\\Users\\DrMeepster\\.rustup\\toolchains\\nightly-2023-03-04-x86_64-pc-windows-msvc\\lib\\rustlib\\src\\rust\\library\\core\\src\\fmt\\mod.rs:405:34\r\n    |\r\n405 |         Arguments { pieces, fmt: None, args }\r\n    |                                  ^\r\n    |\r\nnote: used from within `<core::fmt::Arguments>::new_v1`\r\n   --> \r\nC:\\Users\\DrMeepster\\.rustup\\toolchains\\nightly-2023-03-04-x86_64-pc-windows-msvc\\lib\\rustlib\\src\\rust\\library\\core\\src\\fmt\\mod.rs:405:34\r\n    |\r\n405 |         Arguments { pieces, fmt: None, args }\r\n    |                                  ^\r\nnote: called by `gpu::panic`\r\n   --> \r\nC:\\Users\\DrMeepster\\.rustup\\toolchains\\nightly-2023-03-04-x86_64-pc-windows-msvc\\lib\\rustlib\\src\\rust\\library\\core\\src\\panic.rs:57:38\r\n    |\r\n57  |         $crate::panicking::panic_fmt($crate::const_format_args!($($t)+))\r\n    |                                      ^\r\nnote: called by `gpu::main`\r\n   --> gpu\\src\\lib.rs:10:5\r\n    |\r\n10  |     panic();\r\n    |     ^\r\nnote: called by `main`\r\n   --> gpu\\src\\lib.rs:8:1\r\n    |\r\n8   | #[spirv_std::spirv(fragment)]\r\n    | ^\r\n\r\nerror: cannot cast between pointer types\r\n       from `*[struct &str { *[u8], u32 }; 1]`\r\n         to `*[struct &str { *[u8], u32 }]`\r\n  --> \r\nC:\\Users\\DrMeepster\\.rustup\\toolchains\\nightly-2023-03-04-x86_64-pc-windows-msvc\\lib\\rustlib\\src\\rust\\library\\core\\src\\panic.rs:57:38\r\n   |\r\n57 |         $crate::panicking::panic_fmt($crate::const_format_args!($($t)+))\r\n   |                                      ^\r\n   |\r\nnote: used from within `gpu::panic`\r\n  --> \r\nC:\\Users\\DrMeepster\\.rustup\\toolchains\\nightly-2023-03-04-x86_64-pc-windows-msvc\\lib\\rustlib\\src\\rust\\library\\core\\src\\panic.rs:57:38\r\n   |\r\n57 |         $crate::panicking::panic_fmt($crate::const_format_args!($($t)+))\r\n   |                                      ^\r\nnote: called by `gpu::main`\r\n  --> gpu\\src\\lib.rs:10:5\r\n   |\r\n10 |     panic();\r\n   |     ^\r\nnote: called by `main`\r\n  --> gpu\\src\\lib.rs:8:1\r\n   |\r\n8  | #[spirv_std::spirv(fragment)]\r\n   | ^\r\n\r\nerror: cannot cast between pointer types\r\n       from `*struct ! {  }`\r\n         to `*[struct core::fmt::ArgumentV1<'_> { value: *struct core::fmt::Opaque {  }, formatter: *fn(*struct core::fmt::Opaque {  }, \r\n*struct core::fmt::Formatter<'_> { buf: struct &mut dyn core::fmt::Write { *struct dyn core::fmt::Write {  }, *[u32; 3] }, width: \r\nstruct core::option::Option<usize> { u32, u32 }, precision: struct core::option::Option<usize> { u32, u32 }, flags: u32, fill: u32, \r\nalign: u8 }) -> bool }]`\r\n  --> \r\nC:\\Users\\DrMeepster\\.rustup\\toolchains\\nightly-2023-03-04-x86_64-pc-windows-msvc\\lib\\rustlib\\src\\rust\\library\\core\\src\\panic.rs:57:38\r\n   |\r\n57 |         $crate::panicking::panic_fmt($crate::const_format_args!($($t)+))\r\n   |                                      ^\r\n   |\r\nnote: used from within `gpu::panic`\r\n  --> \r\nC:\\Users\\DrMeepster\\.rustup\\toolchains\\nightly-2023-03-04-x86_64-pc-windows-msvc\\lib\\rustlib\\src\\rust\\library\\core\\src\\panic.rs:57:38\r\n   |\r\n57 |         $crate::panicking::panic_fmt($crate::const_format_args!($($t)+))\r\n   |                                      ^\r\nnote: called by `gpu::main`\r\n  --> gpu\\src\\lib.rs:10:5\r\n   |\r\n10 |     panic();\r\n   |     ^\r\nnote: called by `main`\r\n  --> gpu\\src\\lib.rs:8:1\r\n   |\r\n8  | #[spirv_std::spirv(fragment)]\r\n   | ^\r\n```\r\n\r\n</p>\r\n</details>\r\n",
    "comments": [
      {
        "id": "IC_kwDOENG4485dwLZt",
        "author": {
          "login": "eddyb"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "I had to change some of the panic detection in the most recent `rustup` PR (due to changes upstream):\r\n* #1067\r\n\r\nYou may want to retest after that lands, in case it fixes this issue (but if so, don't close it, as we'd still want to add a test in that case).",
        "createdAt": "2023-06-01T23:19:18Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/1058#issuecomment-1572910701",
        "viewerDidAuthor": false
      },
      {
        "id": "IC_kwDOENG4485d89k_",
        "author": {
          "login": "beepster4096"
        },
        "authorAssociation": "NONE",
        "body": "It looks like this is fixed in 0.8",
        "createdAt": "2023-06-05T07:52:17Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/1058#issuecomment-1576261951",
        "viewerDidAuthor": false
      }
    ],
    "createdAt": "2023-05-03T02:22:13Z",
    "labels": [
      {
        "id": "MDU6TGFiZWwyMjI3MzM4ODEz",
        "name": "t: bug",
        "description": "Something isn't working",
        "color": "52E8A0"
      }
    ],
    "number": 1058,
    "reactionGroups": [],
    "state": "OPEN",
    "title": "Panicking in a #[track_caller] function fails to compile",
    "url": "https://github.com/EmbarkStudios/rust-gpu/issues/1058"
  },
  {
    "author": {
      "id": "MDQ6VXNlcjMwNDg5MzM=",
      "is_bot": false,
      "login": "kevinboulain",
      "name": "Kevin Boulain"
    },
    "body": "I'm barely getting started but since the [documentation](https://embarkstudios.github.io/rust-gpu/book/writing-shader-crates.html#writing-shader-crates) recommends to file issues, here is one.\r\n\r\n### Example & Steps To Reproduce\r\n\r\n- `cargo run --bin wgpu_runner` (I guess it should be renamed to `example-runner-wgpu` to match the [documentation](https://embarkstudios.github.io/rust-gpu/book/building-rust-gpu.html#getting-started)):\r\n  <details><summary>backtrace</summary><p>\r\n\r\n  ```\r\n  [2023-04-27T11:12:38Z ERROR wgpu_core::device] surface configuration failed: Native window is in use\r\n  thread 'main' panicked at 'Error in Surface::configure: Validation Error\r\n\r\n  Caused by:\r\n      Invalid surface\r\n  ', .../.cargo/git/checkouts/wgpu-53e70f8674b08dd4/a502282/wgpu/src/backend/direct.rs:734:18\r\n  stack backtrace:\r\n     0: rust_begin_unwind\r\n               at /rustc/44cfafe2fafe816395d3acc434663a45d5178c41/library/std/src/panicking.rs:579:5\r\n     1: core::panicking::panic_fmt\r\n               at /rustc/44cfafe2fafe816395d3acc434663a45d5178c41/library/core/src/panicking.rs:64:14\r\n     2: wgpu::backend::direct::Context::handle_error_fatal\r\n               at .../.cargo/git/checkouts/wgpu-53e70f8674b08dd4/a502282/wgpu/src/backend/direct.rs:308:9\r\n     3: <wgpu::backend::direct::Context as wgpu::context::Context>::surface_configure\r\n               at .../.cargo/git/checkouts/wgpu-53e70f8674b08dd4/a502282/wgpu/src/backend/direct.rs:734:13\r\n     4: <T as wgpu::context::DynContext>::surface_configure\r\n               at .../.cargo/git/checkouts/wgpu-53e70f8674b08dd4/a502282/wgpu/src/context.rs:2053:9\r\n     5: wgpu::Surface::configure\r\n               at .../.cargo/git/checkouts/wgpu-53e70f8674b08dd4/a502282/wgpu/src/lib.rs:4144:9\r\n     6: example_runner_wgpu::graphics::run::{{closure}}::{{closure}}\r\n               at ./examples/runners/wgpu/src/graphics.rs:108:13\r\n     7: example_runner_wgpu::graphics::run::{{closure}}::{{closure}}\r\n               at ./examples/runners/wgpu/src/graphics.rs:160:42\r\n     8: winit::platform_impl::platform::sticky_exit_callback\r\n               at .../.cargo/registry/src/github.com-1ecc6299db9ec823/winit-0.28.3/src/platform_impl/linux/mod.rs:884:9\r\n     9: winit::platform_impl::platform::x11::EventLoop<T>::run_return::single_iteration\r\n               at .../.cargo/registry/src/github.com-1ecc6299db9ec823/winit-0.28.3/src/platform_impl/linux/x11/mod.rs:334:17\r\n    10: winit::platform_impl::platform::x11::EventLoop<T>::run_return\r\n               at .../.cargo/registry/src/github.com-1ecc6299db9ec823/winit-0.28.3/src/platform_impl/linux/x11/mod.rs:443:31\r\n    11: winit::platform_impl::platform::x11::EventLoop<T>::run\r\n               at .../.cargo/registry/src/github.com-1ecc6299db9ec823/winit-0.28.3/src/platform_impl/linux/x11/mod.rs:498:25\r\n    12: winit::platform_impl::platform::EventLoop<T>::run\r\n               at .../.cargo/registry/src/github.com-1ecc6299db9ec823/winit-0.28.3/src/platform_impl/linux/mod.rs:792:56\r\n    13: winit::event_loop::EventLoop<T>::run\r\n               at .../.cargo/registry/src/github.com-1ecc6299db9ec823/winit-0.28.3/src/event_loop.rs:305:9\r\n    14: example_runner_wgpu::graphics::run::{{closure}}\r\n               at ./examples/runners/wgpu/src/graphics.rs:145:5\r\n    15: futures_executor::local_pool::block_on::{{closure}}\r\n               at .../.cargo/registry/src/github.com-1ecc6299db9ec823/futures-executor-0.3.19/src/local_pool.rs:315:23\r\n    16: futures_executor::local_pool::run_executor::{{closure}}\r\n               at .../.cargo/registry/src/github.com-1ecc6299db9ec823/futures-executor-0.3.19/src/local_pool.rs:90:37\r\n    17: std::thread::local::LocalKey<T>::try_with\r\n               at /rustc/44cfafe2fafe816395d3acc434663a45d5178c41/library/std/src/thread/local.rs:446:16\r\n    18: std::thread::local::LocalKey<T>::with\r\n               at /rustc/44cfafe2fafe816395d3acc434663a45d5178c41/library/std/src/thread/local.rs:422:9\r\n    19: futures_executor::local_pool::run_executor\r\n               at .../.cargo/registry/src/github.com-1ecc6299db9ec823/futures-executor-0.3.19/src/local_pool.rs:86:5\r\n    20: futures_executor::local_pool::block_on\r\n               at .../.cargo/registry/src/github.com-1ecc6299db9ec823/futures-executor-0.3.19/src/local_pool.rs:315:5\r\n    21: example_runner_wgpu::graphics::start\r\n               at ./examples/runners/wgpu/src/graphics.rs:433:13\r\n    22: example_runner_wgpu::main\r\n               at ./examples/runners/wgpu/src/lib.rs:171:5\r\n    23: wgpu_runner::main\r\n               at ./examples/runners/wgpu/src/bin/wgpu_runner.rs:9:5\r\n    24: core::ops::function::FnOnce::call_once\r\n               at /rustc/44cfafe2fafe816395d3acc434663a45d5178c41/library/core/src/ops/function.rs:250:5\r\n  note: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.\r\n  ```\r\n\r\n  </p></details>\r\n\r\n- here as a workaround:\r\n\r\n  ```patch\r\n  diff --git i/examples/runners/wgpu/src/graphics.rs w/examples/runners/wgpu/src/graphics.rs\r\n  index 9a5bd43263..ca0ceef4cb 100644\r\n  --- i/examples/runners/wgpu/src/graphics.rs\r\n  +++ w/examples/runners/wgpu/src/graphics.rs\r\n  @@ -154,16 +154,6 @@ async fn run(\r\n               Event::MainEventsCleared => {\r\n                   window.request_redraw();\r\n               }\r\n  -            Event::Resumed => {\r\n  -                let new_surface = unsafe { instance.create_surface(&window) }\r\n  -                    .expect(\"Failed to create surface from window (after resume)\");\r\n  -                surface_with_config = Ok(auto_configure_surface(\r\n  -                    &adapter,\r\n  -                    &device,\r\n  -                    new_surface,\r\n  -                    window.inner_size(),\r\n  -                ));\r\n  -            }\r\n               Event::Suspended => {\r\n                   if let Ok((_, surface_config)) = &surface_with_config {\r\n                       surface_with_config = Err(SurfaceCreationPending {\r\n  ```\r\n\r\n## System Info\r\n\r\n - Rust: rustc 1.69.0-nightly (44cfafe2f 2023-03-03)\r\n - OS: NixOS 23.05.20230422.6c43a34\r\n - GPU: `RUST_LOG=wgpu_hal=debug` tells me it's using the discrete GPU here: NVIDIA GeForce RTX 3080 Ti Laptop GPU with driver /nix/store/...-nvidia-x11-530.41.03-6.1.25/lib/libGLX_nvidia.so.0\r\n\r\nThat should run under Xwayland (setup is similar to your [default.nix](https://github.com/EmbarkStudios/rust-gpu/blob/a64857af0247dabdf08103b9c91ce0355c6530b8/default.nix#L24), without the Wayland stuff that crashes for other reasons).\r\n",
    "comments": [
      {
        "id": "IC_kwDOENG44856zC7J",
        "author": {
          "login": "LegNeato"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "I'm not too familiar with this stuff, but it looks like the example in the wgpu repo calls `surface.resume()` when `start_condition()` is met:\r\n\r\nhttps://github.com/gfx-rs/wgpu/blob/0dc9dd6becdfd69ab241169171c37428fefaa1da/examples/src/framework.rs#L395\r\n\r\nIt looks like `start_condition()` is only met on android:\r\n\r\nhttps://github.com/gfx-rs/wgpu/blob/0dc9dd6becdfd69ab241169171c37428fefaa1da/examples/src/framework.rs#L394\r\n\r\notherwise it doesn't do anything on resume, so your patch may be right? Well, after adding the android change.\r\n\r\nChanging this would match what the wgpu folks said (\"you are trying to use the same window more than once by different surfaces\").\r\n\r\nAgain, not sure, but at least those links might be a clue.",
        "createdAt": "2024-04-17T01:58:53Z",
        "includesCreatedEdit": true,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/1056#issuecomment-2060201673",
        "viewerDidAuthor": false
      }
    ],
    "createdAt": "2023-04-27T11:37:52Z",
    "labels": [
      {
        "id": "MDU6TGFiZWwyMjI3MzM4ODEz",
        "name": "t: bug",
        "description": "Something isn't working",
        "color": "52E8A0"
      }
    ],
    "number": 1056,
    "reactionGroups": [],
    "state": "OPEN",
    "title": "example-runner-wgpu: surface configuration failed: native window is in use",
    "url": "https://github.com/EmbarkStudios/rust-gpu/issues/1056"
  },
  {
    "author": {
      "id": "MDQ6VXNlcjcxOTcyOTg=",
      "is_bot": false,
      "login": "SiebenCorgie",
      "name": "Tendsin Mende"
    },
    "body": "SpirV allows defining `import` and `export` [[0](https://registry.khronos.org/SPIR-V/specs/unified1/SPIRV.html#Linkage_Type)] for linking separate Shader modules [[1](https://registry.khronos.org/SPIR-V/specs/unified1/SPIRV.html#_linkage)] post compilation.\r\n\r\nApparently SpirV linking is already used within rust-gpu, but not exposed. Therefore we can't use `extern \"C\"` as we usually would.\r\n\r\nThis functionality would be useful, for instance when building [shader](https://therealmjp.github.io/posts/shader-permutations-part2/) [permutation](https://therealmjp.github.io/posts/dxil-linking/) systems.\r\n\r\nThe enhancement would basically be allowing `extern C`, `#[no_mangle]` etc. to map to (possibly named) `import`/`export` decorated values whenever the `Linkage` capability on `spirv-builder` is enabled.\r\n",
    "comments": [
      {
        "id": "IC_kwDOENG4485akO8v",
        "author": {
          "login": "eddyb"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "Note that `extern \"C\"` *exports* in Rust only affect ABI.\r\n`#[no_mangle]` + `#[export_name = \"...\"]` is how you control symbol names for exports.\r\n\r\nAnyway, `Linkage` is really the only prerequisite, we remove our annotations today because it's not really supported anywhere I can think of. This is the relevant code: https://github.com/EmbarkStudios/rust-gpu/blob/c1b0b5de0054eb82ff817a45406f2fc0ca3e9edf/crates/rustc_codegen_spirv/src/linker/import_export_link.rs#L234-L247\r\n\r\nOh, right, that's kind of funny, there's already a `keep_link_exports` meant for testing.\r\n\r\nYou'll have to be careful tho, to not search for the `Capability::Linkage` in the SPIR-V `Module` (since it sounds like that one is always present, in the interest of keeping the module valid?), but rather determine \"did the user ask for the `Linkage` capability\" from however `target_features` (from `Session`) turn into capabilities.",
        "createdAt": "2023-04-24T06:13:57Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "users": {
              "totalCount": 1
            }
          }
        ],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/1042#issuecomment-1519447855",
        "viewerDidAuthor": false
      }
    ],
    "createdAt": "2023-04-21T16:42:49Z",
    "labels": [
      {
        "id": "MDU6TGFiZWwyMjI3MzM4ODE2",
        "name": "t: enhancement",
        "description": "A new feature or improvement to an existing one.",
        "color": "52E8A0"
      }
    ],
    "number": 1042,
    "reactionGroups": [],
    "state": "OPEN",
    "title": "Allow keeping linkage annotation",
    "url": "https://github.com/EmbarkStudios/rust-gpu/issues/1042"
  },
  {
    "author": {
      "id": "MDQ6VXNlcjIxMjQ1ODA2",
      "is_bot": false,
      "login": "TrueDoctor",
      "name": "Dennis Kobert"
    },
    "body": "<!-- Thank you for filing a bug report! üêõ -->\r\n\r\n### Expected Behaviour\r\n<!-- Please describe what you expected to happen. -->\r\nThe code should compile\r\n\r\n### Example & Steps To Reproduce\r\n<!-- \r\nDescribe what actually happened, including any relevant examples (smaller\r\nthe better), error messages, or the relevant SPIR-V binary. \r\n-->\r\n\r\ncode:\r\n```rust\r\n #[spirv(fragment)] \r\n pub fn main(x: (usize, ())) {\r\n    drop(&x.1); \r\n }\r\n ```\r\n\r\nresult:\r\n```\r\nerror: Cannot cast between pointer types\r\n  --> examples/shaders/simplest-shader/src/lib.rs:44:55\r\n   |\r\n44 | #[spirv(fragment)] pub fn main(x: (usize, ())) { drop(&x.1); }\r\n   |                                                       ^^^^\r\n   |\r\n   = note: from: *u32\r\n   = note: to: *u8\r\n\r\nerror: Cannot offset a pointer to an arbitrary element\r\n  --> examples/shaders/simplest-shader/src/lib.rs:44:55\r\n   |\r\n44 | #[spirv(fragment)] pub fn main(x: (usize, ())) { drop(&x.1); }\r\n   |                                                       ^^^^\r\n\r\nerror: Cannot cast between pointer types\r\n  --> examples/shaders/simplest-shader/src/lib.rs:44:50\r\n   |\r\n44 | #[spirv(fragment)] pub fn main(x: (usize, ())) { drop(&x.1); }\r\n   |                                                  ^^^^^^^^^^\r\n   |\r\n   = note: from: *u8\r\n   = note: to: *struct () {  }\r\n   ```\r\n   \r\n## System Info\r\n<!--\r\nHelpful commands:\r\n- Rustc version: `rustc -V`\r\n- SPIR-V version: `spirv-val --version`\r\n-->\r\n\r\n - Rust: [e.g. 1.49.0-nightly (1eaadebb3 2020-10-21)]\r\n - OS: linux  6.2.9-arch1-1\r\n - GPU: Intel Iris Plus Graphics G7\r\n\r\n\r\n</p>\r\n</details>\r\n",
    "comments": [
      {
        "id": "IC_kwDOENG4485aOcKa",
        "author": {
          "login": "eddyb"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "Noting Discord discussion outcome on here just so nobody wastes their time: the problem here *is not* that the SPIR-V type lacks the ZSTs, and the solution *is not* to add them.\r\n\r\nInstead, the thing to remember is that Rust ZSTs *are not data*, and pointers to them *cannot be used for memory accesses*. The only reason we even need to cast a pointer is because we're using SPIR-V pointer types.\r\n`qptr` (#1020 / https://github.com/EmbarkStudios/spirt/pull/24) should help a lot here.",
        "createdAt": "2023-04-18T20:07:37Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/1037#issuecomment-1513734810",
        "viewerDidAuthor": false
      }
    ],
    "createdAt": "2023-04-18T16:53:55Z",
    "labels": [
      {
        "id": "MDU6TGFiZWwyMjI3MzM4ODEz",
        "name": "t: bug",
        "description": "Something isn't working",
        "color": "52E8A0"
      },
      {
        "id": "LA_kwDOENG4488AAAABPXHqow",
        "name": "s: qptr may fix",
        "description": "This might be fixed by the \"qptr\" experiment (https://github.com/EmbarkStudios/spirt/pull/24)",
        "color": "CCCCCC"
      }
    ],
    "number": 1037,
    "reactionGroups": [],
    "state": "OPEN",
    "title": "ZST's in structs cause invalid pointer casts",
    "url": "https://github.com/EmbarkStudios/rust-gpu/issues/1037"
  },
  {
    "author": {
      "id": "MDQ6VXNlcjMxMjIyNzQw",
      "is_bot": false,
      "login": "Firestar99",
      "name": ""
    },
    "body": "<!-- Thank you for filing a bug report! üêõ -->\r\nAdd official documentation that one should have \r\n```toml\r\n[workspace]\r\nresolver = \"2\"\r\n``` \r\nin their root `cargo.toml` to make sure dependencies are resolved correctly and that crates compiled with different features on native and spirv don't get merged into one feature set. \r\n\r\nAn example can be `num-traits` which compiles with features `default,std` on native and `libm` on spirv target.\r\n\r\nFor a practical example see the issue below:\r\nhttps://github.com/EmbarkStudios/rust-gpu/issues/986",
    "comments": [
      {
        "id": "IC_kwDOENG4485ZDilB",
        "author": {
          "login": "eddyb"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "Official documentation: https://doc.rust-lang.org/cargo/reference/resolver.html#resolver-versions\r\n\r\nI'll also add that if you have *both* `[workspace]` *and* `[package]` in your root `Cargo.tool` (i.e. the workspace root is *not* a \"virtual manifest\"), then `edition = \"2021\"` inside `[package]` should \"just work\".\r\n\r\nSo there's 3 avenues to getting the resolver changes, but sadly Cargo doesn't warn users when they have e.g. virtual manifests with per-package `edition = \"2021\"` everywhere but still Rust 2015 behavior.",
        "createdAt": "2023-04-03T10:52:37Z",
        "includesCreatedEdit": true,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/1022#issuecomment-1494100289",
        "viewerDidAuthor": false
      },
      {
        "id": "IC_kwDOENG4485ZTEtt",
        "author": {
          "login": "Firestar99"
        },
        "authorAssociation": "NONE",
        "body": "I've previously mentioned that \r\n```toml\r\n[workspace.package]\r\nedition = \"2021\"\r\n``` \r\nis enough, but that's actually **wrong**. In this documentation it is stated that `resolver=\"2\"` is the only way to specify it in a virtual workspace:\r\n\r\n> The resolver is a global setting for a [workspace](https://doc.rust-lang.org/cargo/reference/workspaces.html), and the setting is ignored in dependencies. The setting is only honored for the top-level package of the workspace. If you are using a [virtual workspace](https://doc.rust-lang.org/cargo/reference/workspaces.html#virtual-manifest), you will still need to explicitly set the [resolver field](https://doc.rust-lang.org/cargo/reference/resolver.html#resolver-versions) in the [workspace] definition if you want to opt-in to the new resolver.\r\n- https://doc.rust-lang.org/edition-guide/rust-2021/default-cargo-resolver.html#details",
        "createdAt": "2023-04-05T21:15:32Z",
        "includesCreatedEdit": true,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/1022#issuecomment-1498172269",
        "viewerDidAuthor": false
      }
    ],
    "createdAt": "2023-04-03T10:47:39Z",
    "labels": [
      {
        "id": "MDU6TGFiZWwyMjI3MzM4ODEz",
        "name": "t: bug",
        "description": "Something isn't working",
        "color": "52E8A0"
      }
    ],
    "number": 1022,
    "reactionGroups": [],
    "state": "OPEN",
    "title": "Document resolver = \"2\" effective requirement for rust-gpu",
    "url": "https://github.com/EmbarkStudios/rust-gpu/issues/1022"
  },
  {
    "author": {
      "id": "MDQ6VXNlcjc3NDI0",
      "is_bot": false,
      "login": "eddyb",
      "name": "Eduard-Mihai Burtescu"
    },
    "body": "AFAICT, if we set `features = [\"span\"]` for `naga` in `examples/runners/wgpu/Cargo.toml`, we'll get more information on e.g. validation failures (which would've been nice this entire time, alas I didn't realize).\r\n\r\n---\r\n\r\n**EDIT**: nevermind, I got confused, [`span` is already enabled *by default*](https://github.com/gfx-rs/wgpu/blob/b330ff25a38a672e6753ff53f9592440f6b3fbb2/wgpu-core/Cargo.toml#L72), it just doesn't seem to do anything useful for SPIR-V input into Naga.",
    "comments": [],
    "createdAt": "2023-03-23T08:15:03Z",
    "labels": [
      {
        "id": "MDU6TGFiZWwyMjI3MzM4ODE2",
        "name": "t: enhancement",
        "description": "A new feature or improvement to an existing one.",
        "color": "52E8A0"
      },
      {
        "id": "MDU6TGFiZWwyNDQ2Mjg2MzU0",
        "name": "a: examples",
        "description": "Issues specific to the examples in the repository.",
        "color": "FCA492"
      },
      {
        "id": "MDU6TGFiZWwyNzkxOTU1MDc2",
        "name": "a: debugging",
        "description": "Issues related to debugging code generated from rust-gpu",
        "color": "FCA492"
      }
    ],
    "number": 1017,
    "reactionGroups": [],
    "state": "OPEN",
    "title": "We should figure out how to use Naga's `\"span\"` feature (for `example-runner-wgpu`).",
    "url": "https://github.com/EmbarkStudios/rust-gpu/issues/1017"
  },
  {
    "author": {
      "id": "MDQ6VXNlcjEwODk2MzY1",
      "is_bot": false,
      "login": "FuzzyLitchi",
      "name": "Polly"
    },
    "body": "In [this page](https://embarkstudios.github.io/rust-gpu/book/writing-shader-crates.html) the link to \"https://github.com/EmbarkStudios/rust-gpu/blob/main/rust-toolchain\" is broken, presumably missing `.toml` at the end.\r\n\r\nAlso, it recommends using `spirv-builder = \"0.4\"` but it seems that is incompatible with the current `rust-toolchain.toml` file as the compile error helpfully points out. `spirv-builder = \"0.6\"` seems to work.",
    "comments": [
      {
        "id": "IC_kwDOENG4485YQp9R",
        "author": {
          "login": "eddyb"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "cc @oisyn I guess these are some of the docs that lack any good way to automate generating/checking them.",
        "createdAt": "2023-03-23T08:16:33Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/1015#issuecomment-1480761169",
        "viewerDidAuthor": false
      }
    ],
    "createdAt": "2023-03-21T15:09:52Z",
    "labels": [
      {
        "id": "MDU6TGFiZWwyMjI3MzM4ODEz",
        "name": "t: bug",
        "description": "Something isn't working",
        "color": "52E8A0"
      }
    ],
    "number": 1015,
    "reactionGroups": [],
    "state": "OPEN",
    "title": "Outdated docs (suggesting now-obsoleted versions, linking to since-renamed files, etc.).",
    "url": "https://github.com/EmbarkStudios/rust-gpu/issues/1015"
  },
  {
    "author": {
      "id": "MDQ6VXNlcjc3NDI0",
      "is_bot": false,
      "login": "eddyb",
      "name": "Eduard-Mihai Burtescu"
    },
    "body": "We have a few different ways to extract results from `asm!`:\r\n* old unsound approach (UB because of `OpReturnValue`, so it's getting replaced)\r\n```rust\r\nasm! {\r\n    \"%result = ...\",\r\n    \"OpReturnValue %result\",\r\n    options(noreturn),\r\n}\r\n```\r\n* old approach (sound, but requires `T: Default`)\r\n```rust\r\nlet mut result = T::default();\r\nasm!(\r\n    \"%result = ...\",\r\n    \"OpStore {result} %result\",\r\n    result = in(reg) &mut result,\r\n);\r\nresult\r\n```\r\n* new approach (using `MaybeUninit<T>`), from #1006\r\n```rust\r\nlet mut result_slot = core::mem::MaybeUninit::uninit();\r\nasm! {\r\n    \"%result = ...\",\r\n    \"OpStore {result_slot} %result\",\r\n    result_slot = in(reg) result_slot.as_mut_ptr(),\r\n}\r\nresult_slot.assume_init()\r\n```\r\n\r\nIn #1006 only the unsound uses of `asm!(\"OpReturnValue\")` were fixed (i.e. when dealing with opaque handles or `&T`/`&mut T`, neither of which implement `Default`).\r\n\r\nHowever, it might be a good to transition everything uniformly, and maybe even provide a wrapper macro that allows uniformly using `asm!` with the result slot automatically handled (and even by-ref inputs as well?).",
    "comments": [],
    "createdAt": "2023-03-17T20:01:45Z",
    "labels": [
      {
        "id": "MDU6TGFiZWwyMjI3MzM4ODE2",
        "name": "t: enhancement",
        "description": "A new feature or improvement to an existing one.",
        "color": "52E8A0"
      },
      {
        "id": "MDU6TGFiZWwyODM2NzIzNzE1",
        "name": "a: asm",
        "description": "Issues related to inline assembly.",
        "color": "FCA492"
      }
    ],
    "number": 1007,
    "reactionGroups": [],
    "state": "OPEN",
    "title": "spirv-std inline `asm!` should use `MaybeUninit<T>` instead of `let mut result = T::default();`.",
    "url": "https://github.com/EmbarkStudios/rust-gpu/issues/1007"
  },
  {
    "author": {
      "id": "MDQ6VXNlcjEyNTMyMzk=",
      "is_bot": false,
      "login": "Shfty",
      "name": "Shfty"
    },
    "body": "### Expected Behaviour\r\nSuccessful compilation of [`bevy-pbr-rust`](https://github.com/bevy-rust-gpu/bevy-pbr-rust) with `--spirt-passes=reduce` enabled via `RUSTGPU_CODEGEN_ARGS`.\r\n\r\nThis was done using the `v0.5.0` tag as a preliminary test before upgrading to `v0.6.0`, under advisement of @eddyb.\r\n\r\n### Example & Steps To Reproduce\r\nCompile via `spirv-builder`, rustc panics with the attached backtrace.\r\n\r\nThe following minimal reproduction case illustrates the issue:\r\n```rust\r\n#![no_std]\r\n\r\nuse spirv_std::{\r\n    glam::{Mat3, Mat4, Vec4},\r\n    spirv,\r\n};\r\n\r\n#[spirv(vertex)]\r\npub fn vertex(foo: Vec4) {\r\n    // No panic if the add is removed\r\n    let bar = Mat4::IDENTITY + Mat4::IDENTITY;\r\n\r\n    // No panic if using Mat3::from_mat4\r\n    let _baz = Mat3 {\r\n        x_axis: bar.x_axis.truncate(),\r\n        y_axis: bar.y_axis.truncate(),\r\n        z_axis: bar.z_axis.truncate(),\r\n    }\r\n    // No panic if removing this mul\r\n    * foo.truncate();\r\n}\r\n```\r\n\r\n## System Info\r\n - Rust: 1.68.0-nightly (0468a00ae 2022-12-17)\r\n - OS: Artix Linux x86_64, Kernel 6.2.2-zen1-1-zen\r\n - GPU: AMD Radeon 6900XT\r\n - SPIR-V: SPIRV-Tools v2022.4 v2022.4 / SPIR-V 1.5\r\n\r\n\r\n## Backtrace\r\n<details><summary>Backtrace</summary>\r\n<p>\r\n\r\n```\r\n   Compiling shader v0.1.0 (/mnt/projects/personal/rust/Projects/bevy-rust-gpu-project/example-workspace/rust-gpu/crates/shader)\r\nthread 'rustc' panicked at 'no entry found for key', /home/user/.cargo/git/checkouts/spirt-9c237dd53f05c2cc/0fed5a9/src/spv/lift.rs:1185:44\r\nstack backtrace:\r\n   0:     0x7f45a4c0785a - std::backtrace_rs::backtrace::libunwind::trace::h51cb40f2f8f23f31\r\n                               at /rustc/0468a00ae3fd6ef1a6a0f9eaf637d7aa9e604acc/library/std/src/../../backtrace/src/backtrace/libunwind.rs:93:5\r\n   1:     0x7f45a4c0785a - std::backtrace_rs::backtrace::trace_unsynchronized::hebc3338ffed58a56\r\n                               at /rustc/0468a00ae3fd6ef1a6a0f9eaf637d7aa9e604acc/library/std/src/../../backtrace/src/backtrace/mod.rs:66:5\r\n   2:     0x7f45a4c0785a - std::sys_common::backtrace::_print_fmt::h136f982a4680ac7f\r\n                               at /rustc/0468a00ae3fd6ef1a6a0f9eaf637d7aa9e604acc/library/std/src/sys_common/backtrace.rs:65:5\r\n   3:     0x7f45a4c0785a - <std::sys_common::backtrace::_print::DisplayBacktrace as core::fmt::Display>::fmt::hd1514baae6e42eb6\r\n                               at /rustc/0468a00ae3fd6ef1a6a0f9eaf637d7aa9e604acc/library/std/src/sys_common/backtrace.rs:44:22\r\n   4:     0x7f45a4c6a36e - core::fmt::write::hfbed4b54a5eebfee\r\n                               at /rustc/0468a00ae3fd6ef1a6a0f9eaf637d7aa9e604acc/library/core/src/fmt/mod.rs:1208:17\r\n   5:     0x7f45a4bf7bd5 - std::io::Write::write_fmt::h9f6098b6a54a9a94\r\n                               at /rustc/0468a00ae3fd6ef1a6a0f9eaf637d7aa9e604acc/library/std/src/io/mod.rs:1682:15\r\n   6:     0x7f45a4c07625 - std::sys_common::backtrace::_print::h6e7a2bc7da6ecf73\r\n                               at /rustc/0468a00ae3fd6ef1a6a0f9eaf637d7aa9e604acc/library/std/src/sys_common/backtrace.rs:47:5\r\n   7:     0x7f45a4c07625 - std::sys_common::backtrace::print::h631b25ef82a0eea1\r\n                               at /rustc/0468a00ae3fd6ef1a6a0f9eaf637d7aa9e604acc/library/std/src/sys_common/backtrace.rs:34:9\r\n   8:     0x7f45a4c0a36f - std::panicking::default_hook::{{closure}}::h41299fc951b157c9\r\n                               at /rustc/0468a00ae3fd6ef1a6a0f9eaf637d7aa9e604acc/library/std/src/panicking.rs:267:22\r\n   9:     0x7f45a4c0a0ab - std::panicking::default_hook::hd317023abfdceaed\r\n                               at /rustc/0468a00ae3fd6ef1a6a0f9eaf637d7aa9e604acc/library/std/src/panicking.rs:286:9\r\n  10:     0x7f4597521b95 - rustc_codegen_spirv::__rustc_codegen_backend::{{closure}}::ha48d52bd426b74ce\r\n  11:     0x7f45a4c0abad - <alloc::boxed::Box<F,A> as core::ops::function::Fn<Args>>::call::h813f31c5cc72640d\r\n                               at /rustc/0468a00ae3fd6ef1a6a0f9eaf637d7aa9e604acc/library/alloc/src/boxed.rs:2032:9\r\n  12:     0x7f45a4c0abad - std::panicking::rust_panic_with_hook::h2e61684db9120e8e\r\n                               at /rustc/0468a00ae3fd6ef1a6a0f9eaf637d7aa9e604acc/library/std/src/panicking.rs:692:13\r\n  13:     0x7f45a4c0a929 - std::panicking::begin_panic_handler::{{closure}}::h63d39cc19c97d34a\r\n                               at /rustc/0468a00ae3fd6ef1a6a0f9eaf637d7aa9e604acc/library/std/src/panicking.rs:579:13\r\n  14:     0x7f45a4c07d0c - std::sys_common::backtrace::__rust_end_short_backtrace::h8da6b271e1c3c543\r\n                               at /rustc/0468a00ae3fd6ef1a6a0f9eaf637d7aa9e604acc/library/std/src/sys_common/backtrace.rs:137:18\r\n  15:     0x7f45a4c0a632 - rust_begin_unwind\r\n                               at /rustc/0468a00ae3fd6ef1a6a0f9eaf637d7aa9e604acc/library/std/src/panicking.rs:575:5\r\n  16:     0x7f45a4c66d53 - core::panicking::panic_fmt::h89c37196e57a859c\r\n                               at /rustc/0468a00ae3fd6ef1a6a0f9eaf637d7aa9e604acc/library/core/src/panicking.rs:64:14\r\n  17:     0x7f45a4c66ea1 - core::panicking::panic_display::h9291dff40a4a809f\r\n                               at /rustc/0468a00ae3fd6ef1a6a0f9eaf637d7aa9e604acc/library/core/src/panicking.rs:135:5\r\n  18:     0x7f45a4c66e4b - core::panicking::panic_str::h647e8fee22e5d4a5\r\n                               at /rustc/0468a00ae3fd6ef1a6a0f9eaf637d7aa9e604acc/library/core/src/panicking.rs:119:5\r\n  19:     0x7f45a4c66ad6 - core::option::expect_failed::hfb5fae7076a47926\r\n                               at /rustc/0468a00ae3fd6ef1a6a0f9eaf637d7aa9e604acc/library/core/src/option.rs:1923:5\r\n  20:     0x7f459766c9b4 - spirt::spv::lift::LazyInst::to_inst_and_attrs::{{closure}}::hf6e1b5db38327d33\r\n  21:     0x7f45977698db - <smallvec::SmallVec<A> as core::iter::traits::collect::Extend<<A as smallvec::Array>::Item>>::extend::h1736bb6dadb49a30\r\n  22:     0x7f459766be5c - spirt::spv::lift::LazyInst::to_inst_and_attrs::hdb8c034edb0fa0a0\r\n  23:     0x7f45976f91dd - spirt::spv::lift::<impl spirt::sealed::Module>::lift_to_spv_module_emitter::hed2e99131c8ead1c\r\n  24:     0x7f4597519a9c - rustc_codegen_spirv::linker::link::h376c672ae7aaefe3\r\n  25:     0x7f45973c9be5 - rustc_codegen_spirv::link::link::h21377f283e4c1a0a\r\n  26:     0x7f459751f52d - <rustc_codegen_spirv::SpirvCodegenBackend as rustc_codegen_ssa::traits::backend::CodegenBackend>::link::hf332f3cf7f1aa6b0\r\n  27:     0x7f45a2cd9c1a - <rustc_interface[58e4822cc60d2a6c]::queries::Linker>::link\r\n  28:     0x7f45a2cbc98b - rustc_span[fd000e025c1fef5b]::with_source_map::<core[486592e7c49a8aa]::result::Result<(), rustc_errors[5442e185e098f882]::ErrorGuaranteed>, rustc_interface[58e4822cc60d2a6c]::interface::run_compiler<core[486592e7c49a8aa]::result::Result<(), rustc_errors[5442e185e098f882]::ErrorGuaranteed>, rustc_driver[8fc339cf4408bec4]::run_compiler::{closure#1}>::{closure#0}::{closure#0}>\r\n  29:     0x7f45a2cbc3a5 - <scoped_tls[2f862aa259e87453]::ScopedKey<rustc_span[fd000e025c1fef5b]::SessionGlobals>>::set::<rustc_interface[58e4822cc60d2a6c]::interface::run_compiler<core[486592e7c49a8aa]::result::Result<(), rustc_errors[5442e185e098f882]::ErrorGuaranteed>, rustc_driver[8fc339cf4408bec4]::run_compiler::{closure#1}>::{closure#0}, core[486592e7c49a8aa]::result::Result<(), rustc_errors[5442e185e098f882]::ErrorGuaranteed>>\r\n  30:     0x7f45a2cbb992 - std[14b7645e29e8dad4]::sys_common::backtrace::__rust_begin_short_backtrace::<rustc_interface[58e4822cc60d2a6c]::util::run_in_thread_pool_with_globals<rustc_interface[58e4822cc60d2a6c]::interface::run_compiler<core[486592e7c49a8aa]::result::Result<(), rustc_errors[5442e185e098f882]::ErrorGuaranteed>, rustc_driver[8fc339cf4408bec4]::run_compiler::{closure#1}>::{closure#0}, core[486592e7c49a8aa]::result::Result<(), rustc_errors[5442e185e098f882]::ErrorGuaranteed>>::{closure#0}::{closure#0}, core[486592e7c49a8aa]::result::Result<(), rustc_errors[5442e185e098f882]::ErrorGuaranteed>>\r\n  31:     0x7f45a32f2c1a - <<std[14b7645e29e8dad4]::thread::Builder>::spawn_unchecked_<rustc_interface[58e4822cc60d2a6c]::util::run_in_thread_pool_with_globals<rustc_interface[58e4822cc60d2a6c]::interface::run_compiler<core[486592e7c49a8aa]::result::Result<(), rustc_errors[5442e185e098f882]::ErrorGuaranteed>, rustc_driver[8fc339cf4408bec4]::run_compiler::{closure#1}>::{closure#0}, core[486592e7c49a8aa]::result::Result<(), rustc_errors[5442e185e098f882]::ErrorGuaranteed>>::{closure#0}::{closure#0}, core[486592e7c49a8aa]::result::Result<(), rustc_errors[5442e185e098f882]::ErrorGuaranteed>>::{closure#1} as core[486592e7c49a8aa]::ops::function::FnOnce<()>>::call_once::{shim:vtable#0}\r\n  32:     0x7f45a4c14983 - <alloc::boxed::Box<F,A> as core::ops::function::FnOnce<Args>>::call_once::hdbff13d45d6b3b01\r\n                               at /rustc/0468a00ae3fd6ef1a6a0f9eaf637d7aa9e604acc/library/alloc/src/boxed.rs:2000:9\r\n  33:     0x7f45a4c14983 - <alloc::boxed::Box<F,A> as core::ops::function::FnOnce<Args>>::call_once::h1e5384a2b7a0037a\r\n                               at /rustc/0468a00ae3fd6ef1a6a0f9eaf637d7aa9e604acc/library/alloc/src/boxed.rs:2000:9\r\n  34:     0x7f45a4c14983 - std::sys::unix::thread::Thread::new::thread_start::h4b8540c4f94d9763\r\n                               at /rustc/0468a00ae3fd6ef1a6a0f9eaf637d7aa9e604acc/library/std/src/sys/unix/thread.rs:108:17\r\n  35:     0x7f45a0697bb5 - <unknown>\r\n  36:     0x7f45a0719d90 - <unknown>\r\n  37:                0x0 - <unknown>\r\nerror: internal compiler error: unexpected panic\r\n\r\nnote: the compiler unexpectedly panicked. this is a bug.\r\n\r\nnote: we would appreciate a bug report: https://github.com/EmbarkStudios/rust-gpu/issues/new\r\n\r\nnote: rustc 1.68.0-nightly (0468a00ae 2022-12-17) running on x86_64-unknown-linux-gnu\r\n\r\nnote: compiler flags: --crate-type dylib -C opt-level=3 -C embed-bitcode=no -Z unstable-options -Z codegen-backend=/mnt/projects/personal/rust/Projects/bevy-rust-gpu-project/example-workspace/rust-gpu/target/release/librustc_codegen_spirv.so -Z binary-dep-depinfo -C symbol-mangling-version=v0 -Z crate-attr=feature(register_tool) -Z crate-attr=register_tool(rust_gpu) -C llvm-args=--spirt --dump-spirt-passes=/mnt/projects/personal/rust/Projects/bevy-rust-gpu-project/example-workspace/rust-gpu/spirt-passes --spirt-passes=reduce,fuse_selects\r\n\r\nnote: some of the compiler flags provided by cargo are hidden\r\n\r\nquery stack during panic:\r\nend of query stack\r\nnote: `rust-gpu` version 0.5.0\r\n\r\nerror: could not compile `shader`\r\n```\r\n\r\n</p>\r\n</details>\r\n",
    "comments": [
      {
        "id": "IC_kwDOENG4485Xy0DB",
        "author": {
          "login": "Shfty"
        },
        "authorAssociation": "NONE",
        "body": "This is also reproducible on `v0.6.0`; corresponding SPIR-T HTML output can be found [here](https://htmlpreview.github.io/?https://gist.githubusercontent.com/Shfty/0769b2c22e740c3e5a3d64495e0b16a4/raw/c870e5f39fec784658f9515f1392730868e9ac33/shader.spirt.html&dark).",
        "createdAt": "2023-03-17T00:31:06Z",
        "includesCreatedEdit": true,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/1004#issuecomment-1472938177",
        "viewerDidAuthor": false
      },
      {
        "id": "IC_kwDOENG4485Xy0lI",
        "author": {
          "login": "Shfty"
        },
        "authorAssociation": "NONE",
        "body": "And [again](https://htmlpreview.github.io/?https://gist.githubusercontent.com/Shfty/05ab4a4d94c529a1babf4ff9761020e9/raw/f6989b54249e4ebcef608f8b1e9d72de9dc0bce9/shader.spirt.html&dark) with the SPIR-T `qptr` branch patched in for the sake of nicer pretty-printing.",
        "createdAt": "2023-03-17T00:34:38Z",
        "includesCreatedEdit": true,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/1004#issuecomment-1472940360",
        "viewerDidAuthor": false
      },
      {
        "id": "IC_kwDOENG4485iUhUS",
        "author": {
          "login": "eddyb"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "Can you test on `0.9.0`? I think I had to include a fix for this in #1083 IIRC.",
        "createdAt": "2023-07-25T10:20:14Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/1004#issuecomment-1649546514",
        "viewerDidAuthor": false
      }
    ],
    "createdAt": "2023-03-17T00:03:17Z",
    "labels": [
      {
        "id": "MDU6TGFiZWwyMjI3MzM4ODEz",
        "name": "t: bug",
        "description": "Something isn't working",
        "color": "52E8A0"
      }
    ],
    "number": 1004,
    "reactionGroups": [],
    "state": "OPEN",
    "title": "Panic when compiling `bevy-pbr-rust` with `--spirt-passes=reduce`",
    "url": "https://github.com/EmbarkStudios/rust-gpu/issues/1004"
  },
  {
    "author": {
      "id": "MDQ6VXNlcjI1NDE3OTAw",
      "is_bot": false,
      "login": "duplexsystem",
      "name": "Zo√´ Gidiere"
    },
    "body": "<!--\r\nThank you for your interest in the `rust-gpu` project! This template is for\r\nproposing a minor improvement, such as addig a new method, or improving \r\ndocumentation. Please try to provide a short high level overview of what you would\r\nlike you to add. Also be sure to check the existing and `wontfix` issues to see\r\nif it's already been proposed before posting.\r\n\r\nExisting Issues: https://github.com/EmbarkStudios/rust-gpu/issues?q=is%3Aopen+is%3Aissue+label%3A%22t%3A+enhancement%22\r\nClosed Issues: https://github.com/EmbarkStudios/rust-gpu/labels/s%3A%20wontfix\r\n\r\n-->\r\n16bit Floating point support has been a feature of GPUs since Nvidia's Pascal, AMD's RDNA2, and Adreno GPUs starting at some point (couldn't find out when). Copied from [this WebGPU suggestion](url) (because it's a good summary) fp16 provide the following, quite large benefits over fp32:\r\n\r\n> \r\n\r\n* It uses half the memory size (of course). This is particularly important on mobile devices where available memory is limited. Specifically, one of the most common / strongest request the Metal team gets from 3rd parties is for features which can help decrease their memory use.\r\n* Because it uses half the size, memory bandwidth is more effectively used.\r\n* Even without the bandwidth increase, devices often have increased ALU performance for half-precision operations.\r\n* Power consumption is decreased on some devices, leading to better battery life.\r\n\r\nIn addition fp16 support has been a, optional, core feature since Vulkan 1.2, see [VK_KHR_shader_float16_int8](https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VK_KHR_shader_float16_int8.html).\r\n\r\n\r\n\r\nSadly rust currently does not have an fp16 type, however there are crates such as [half](https://crates.io/crates/half/) which emulate fp16 and optionally compile down to native types/intrinsics when possible. However possibly other than directly writing inline SPIR-V, and even that may cause unintended side effects as to my knowledge rust-gpu was not written with fp16 support in mind, rust-gpu does not support fp16. Given glam also does not support fp16 ecosystem integration would not be trivial. However the performance gain and flexibility of allowing fp16 are quite large and fp16 would expand the amount of shaders that could be ported to rust in a performant way (see FSR 1.0, FSR 2.0, and NIS among others). \r\n\r\nAll that to preface: Is support for 16bit Floating point planned/in scope for rust-gpu, be that directly support or just exposing intrinsics and supporting 16bit storage?",
    "comments": [
      {
        "id": "IC_kwDOENG4485XqYaP",
        "author": {
          "login": "Cazadorro"
        },
        "authorAssociation": "NONE",
        "body": "fp16 also historically has had longer usage than pascal and RDNA2, since usage as an *input/output format* has been allowed/existed for much longer.  Half for example, has been a type in HLSL in DX9 nearly 15 years ago.   My understanding though from previous discussions on this topic, is that it's *rust* itself that is limiting fp16, as there's been a lot of discussion of adding it to rust, and there are limited architectures that know about bf16 and f16 on the CPU side of things.  Crates like half aren't ideal because you'd need them to support spir-v as a backend? I'm not sure the issues there.  Still, it's a bit of a strained argument given inline SPIR-V in rust-gpu.  I don't see why a temporary solution can't be put forward so peoples code doesn't arbitrarily end up being straight up not compatible with rust-gpu in the mean time. ",
        "createdAt": "2023-03-15T19:40:18Z",
        "includesCreatedEdit": true,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/1003#issuecomment-1470727823",
        "viewerDidAuthor": false
      },
      {
        "id": "IC_kwDOENG4485Xqebf",
        "author": {
          "login": "duplexsystem"
        },
        "authorAssociation": "NONE",
        "body": " >  Crates like half aren't ideal because you'd need them to support spir-v as a backend? I'm not sure the issues there.\r\n\r\nHalf would be a good solution but it lacks native spirv fp16 support, although ironically has support for using spirv some spirv extensions to emulating fp16 more perfomrant, but I was saying inline asm isn't ideal because presumably, espically for things like input and output, it would be super clumsy and likely not integrate well with existing rust-gpu syntax. I should have made it more clear my, proposed, stop gap solution is to provide intrinsics for fp16 which could be used by half, or directly by a shader, allowing you to, use fp16 without asm, and in the future if rust ever gets fp16 support it could be piped into this. This would be very similar to how rust exposes CPU fp16 intrinsics for different arches in core. But as far as I can tell this wouldn't really solve storing a fp16 in a vector. But I digress, I just feel like fp16 is a relatively important feature rust-gpu lacks and wanted to open the discussion on it (or be told its not planned or out of scope)",
        "createdAt": "2023-03-15T19:56:48Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/1003#issuecomment-1470752479",
        "viewerDidAuthor": false
      },
      {
        "id": "IC_kwDOENG4485wteOx",
        "author": {
          "login": "LegNeato"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "There is a RFC to add `f16` to Rust:\r\nhttps://rust-lang.github.io/rfcs/3453-f16-and-f128.html",
        "createdAt": "2024-01-14T14:29:53Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/1003#issuecomment-1890968497",
        "viewerDidAuthor": false
      }
    ],
    "createdAt": "2023-03-15T16:50:07Z",
    "labels": [
      {
        "id": "MDU6TGFiZWwyMjI3MzM4ODE2",
        "name": "t: enhancement",
        "description": "A new feature or improvement to an existing one.",
        "color": "52E8A0"
      }
    ],
    "number": 1003,
    "reactionGroups": [
      {
        "content": "THUMBS_UP",
        "users": {
          "totalCount": 2
        }
      }
    ],
    "state": "OPEN",
    "title": "Is support for 16bit Floating point planned/in scope?",
    "url": "https://github.com/EmbarkStudios/rust-gpu/issues/1003"
  },
  {
    "author": {
      "id": "MDQ6VXNlcjI2MTk0OTkx",
      "is_bot": false,
      "login": "charles-r-earp",
      "name": ""
    },
    "body": "The debug_printf and debug_printfln macros generate an invocation of the asm macro, which requires an unsafe block. However, the macro appears to validate it's input, so it could potentially add the unsafe block to it's output. If there are still outstanding issues, perhaps a safety section could be added to the docs to reduce confusion? This is a really useful tool, and it seems strange to require unsafe just to debug stuff. ",
    "comments": [],
    "createdAt": "2023-03-04T00:38:43Z",
    "labels": [
      {
        "id": "MDU6TGFiZWwyMjI3MzM4ODE2",
        "name": "t: enhancement",
        "description": "A new feature or improvement to an existing one.",
        "color": "52E8A0"
      }
    ],
    "number": 997,
    "reactionGroups": [],
    "state": "OPEN",
    "title": "debug_printf requires unsafe ",
    "url": "https://github.com/EmbarkStudios/rust-gpu/issues/997"
  },
  {
    "author": {
      "id": "MDQ6VXNlcjc3NDI0",
      "is_bot": false,
      "login": "eddyb",
      "name": "Eduard-Mihai Burtescu"
    },
    "body": "I was reviewing this nightly bump PR:\r\n* https://github.com/EmbarkStudios/rust-gpu/pull/982\r\n\r\nAnd its diff shows some nightly diagnostic improvements of the form:\r\n```diff\r\n 12  |     *output = image.query_levels();\r\n-    |               ^^^^^ ------------ required by a bound introduced by this call\r\n-    |               |\r\n-    |               the trait `HasQueryLevels` is not implemented for `Image<f32, 4, 2, 0, 0, 1, 0>`\r\n+    |                     ^^^^^^^^^^^^ the trait `HasQueryLevels` is not implemented for `Image<f32, 4, 2, 0, 0, 1, 0>`\r\n     |\r\n     = help: the following other types implement trait `HasQueryLevels`:\r\n               Image<SampledType, 0, DEPTH, ARRAYED, MULTISAMPLED, SAMPLED, FORMAT>\r\n```\r\n\r\nThat's definitely better, but the trait can't really explain itself and its connection to the types (i.e. \"`Image` types support `query_levels` only if such and such parameters have these values\" etc.).\r\n\r\n*Except*, in `core`/`std`, traits *can* and very much *do* do this, [using `#[rustc_on_unimplemented]`](https://rustc-dev-guide.rust-lang.org/diagnostics.html#rustc_on_unimplemented)!\r\n\r\nIt's perma-unstable, and there might be efforts to stabilize a subset of it, but even ignoring that, we can still use it under `#[cfg_attr(target_arch = \"spirv\", ...)]`, just like all the other rustc internals we rely on.",
    "comments": [],
    "createdAt": "2023-01-05T12:44:08Z",
    "labels": [
      {
        "id": "MDU6TGFiZWwyMjI3MzM4ODE2",
        "name": "t: enhancement",
        "description": "A new feature or improvement to an existing one.",
        "color": "52E8A0"
      }
    ],
    "number": 983,
    "reactionGroups": [],
    "state": "OPEN",
    "title": "We should consider using `#[rustc_on_unimplemented]` on `spirv-std` helper traits.",
    "url": "https://github.com/EmbarkStudios/rust-gpu/issues/983"
  },
  {
    "author": {
      "id": "MDQ6VXNlcjExNzg4OQ==",
      "is_bot": false,
      "login": "NiklasNummelin",
      "name": "Niklas Nummelin"
    },
    "body": "When using `MaybeUninit` to initialize variables one gets this issue:\r\n`error: Cannot cast between pointer types. From: [u8; 256]. To: *struct core::mem::ManuallyDrop<[Vec4; 16]> { value: [f32x4; 16] }.`\r\n\r\nWould be nice to allow, if possible, as it's often unnecessary to initialize variables in shaders and adds additional overhead.\r\n",
    "comments": [
      {
        "id": "IC_kwDOENG4485RpPXE",
        "author": {
          "login": "NiklasNummelin"
        },
        "authorAssociation": "NONE",
        "body": "I can also add that using `core::mem::uninitialized()` leads to the same issue.",
        "createdAt": "2023-01-03T13:23:11Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/981#issuecomment-1369765316",
        "viewerDidAuthor": false
      },
      {
        "id": "IC_kwDOENG4485VlOVp",
        "author": {
          "login": "LegNeato"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "Hmmm, from the tests it looks like this might already be supported?\r\n\r\nhttps://github.com/EmbarkStudios/rust-gpu/blob/main/tests/ui/lang/core/mem/create_unitialized_memory.rs",
        "createdAt": "2023-02-19T02:24:19Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/981#issuecomment-1435821417",
        "viewerDidAuthor": false
      },
      {
        "id": "IC_kwDOENG4485X3qsR",
        "author": {
          "login": "eddyb"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "@NiklasNummelin @LegNeato Sorry I forgot about this, but it looks like the issue here is *specifically* arrays?\r\n\r\nWhat were you using `MaybeUninit` for? It looks like `.as_mut_ptr()` is fine for inline `asm!` use and we should replace all our indirect-`asm!`-result patterns with it.\r\n\r\n**EDIT**: oh, I see, `MaybeUninit<T>` works already when `T` is an integer/float/pointer, because it bypasses the general case, will still need to implement the general case.",
        "createdAt": "2023-03-17T17:58:41Z",
        "includesCreatedEdit": true,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/981#issuecomment-1474210577",
        "viewerDidAuthor": false
      },
      {
        "id": "IC_kwDOENG4485X4TkB",
        "author": {
          "login": "eddyb"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "This PR has a fix (in its first commit) for `union`s that should handle all possible `MaybeUninit<T>`s:\r\n* #1006\r\n\r\nHowever, I haven't added tests, or even tried it out beyond the `spirv_std` changes, so even after that lands, this issue would be tracking making sure @NiklasNummelin's original usecase is addressed.",
        "createdAt": "2023-03-17T20:34:29Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/981#issuecomment-1474377985",
        "viewerDidAuthor": false
      },
      {
        "id": "IC_kwDOENG4485YJP0F",
        "author": {
          "login": "eddyb"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "Haven't looked into reproducing this yet but it's very likely that `MaybeUninit<&[T]>` (and scalar pairs in general) has a different layout than `&[T]`, which seems to be negatively impacting #1014.\r\n\r\nIt might be fine for fixed-length arrays, so your original usecase is probably fine, but `TypedBuffer` kind of *needs to* work with slices to be maximally useful.",
        "createdAt": "2023-03-22T02:01:51Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/981#issuecomment-1478819077",
        "viewerDidAuthor": false
      }
    ],
    "createdAt": "2023-01-03T13:14:43Z",
    "labels": [
      {
        "id": "MDU6TGFiZWwyMjI3MzM4ODE2",
        "name": "t: enhancement",
        "description": "A new feature or improvement to an existing one.",
        "color": "52E8A0"
      }
    ],
    "number": 981,
    "reactionGroups": [],
    "state": "OPEN",
    "title": "Allow using `MaybeUninit`",
    "url": "https://github.com/EmbarkStudios/rust-gpu/issues/981"
  },
  {
    "author": {
      "id": "MDQ6VXNlcjIxMjM4Nzc2",
      "is_bot": false,
      "login": "oisyn",
      "name": "Sylvester Hesp"
    },
    "body": "https://github.com/EmbarkStudios/rust-gpu/blob/main/docs/src/attributes.md seems very outdated.",
    "comments": [],
    "createdAt": "2022-12-21T13:36:58Z",
    "labels": [
      {
        "id": "MDU6TGFiZWwyMjI3MzM4ODE0",
        "name": "a: documentation",
        "description": "Improvements or additions to documentation",
        "color": "FCA492"
      }
    ],
    "number": 976,
    "reactionGroups": [],
    "state": "OPEN",
    "title": "Update attributes documentation",
    "url": "https://github.com/EmbarkStudios/rust-gpu/issues/976"
  },
  {
    "author": {
      "id": "MDQ6VXNlcjIxMjM4Nzc2",
      "is_bot": false,
      "login": "oisyn",
      "name": "Sylvester Hesp"
    },
    "body": "We support raytracing in shaders, but it appears we neither have proper documentation, nor a nice example in our codebase. We should add both.",
    "comments": [],
    "createdAt": "2022-12-21T13:35:39Z",
    "labels": [
      {
        "id": "MDU6TGFiZWwyMjI3MzM4ODE0",
        "name": "a: documentation",
        "description": "Improvements or additions to documentation",
        "color": "FCA492"
      },
      {
        "id": "MDU6TGFiZWwyNDQ2Mjg2MzU0",
        "name": "a: examples",
        "description": "Issues specific to the examples in the repository.",
        "color": "FCA492"
      }
    ],
    "number": 975,
    "reactionGroups": [
      {
        "content": "THUMBS_UP",
        "users": {
          "totalCount": 1
        }
      },
      {
        "content": "EYES",
        "users": {
          "totalCount": 1
        }
      }
    ],
    "state": "OPEN",
    "title": "Add raytracing documentation and examples",
    "url": "https://github.com/EmbarkStudios/rust-gpu/issues/975"
  },
  {
    "author": {
      "id": "MDQ6VXNlcjc3NDI0",
      "is_bot": false,
      "login": "eddyb",
      "name": "Eduard-Mihai Burtescu"
    },
    "body": "The main unique aspect of these tests is they take SPIR-V assembly *as an input*, *not* Rust code, e.g.:\r\nhttps://github.com/EmbarkStudios/rust-gpu/blob/acb05d379982f35e6d4fbd85ff28af3e9876cf4c/crates/rustc_codegen_spirv/src/linker/test.rs#L185-L202\r\n\r\nHowever, we might be able to use `module_asm!` to feed SPIR-V assembly into the compilation, and `compiletest` does have the ability to introduce dependencies to link against. The main weirdness we might need to deal with is all the definitions from e.g. `core` that we don't use, but DCE might be able to clean that up.\r\n\r\n(Or we could even use e.g. `extern \"C\"` FFI in Rust code to describe such situations without `module_asm!` at all!)\r\n\r\nIf we can do this transition, we wouldn't have to deal with weird artificial compiler sessions and e.g.:\r\n* #956",
    "comments": [],
    "createdAt": "2022-11-30T16:58:43Z",
    "labels": [
      {
        "id": "MDU6TGFiZWwyMjI3MzM4ODE2",
        "name": "t: enhancement",
        "description": "A new feature or improvement to an existing one.",
        "color": "52E8A0"
      },
      {
        "id": "MDU6TGFiZWwyNDQ4NzM0MTE1",
        "name": "a: test",
        "description": "Issues around testing rust-gpu.",
        "color": "FCA492"
      }
    ],
    "number": 957,
    "reactionGroups": [],
    "state": "OPEN",
    "title": "We should replace `rustc_codegen_spirv::linker::test` unit tests with compiletest ones.",
    "url": "https://github.com/EmbarkStudios/rust-gpu/issues/957"
  },
  {
    "author": {
      "id": "MDQ6VXNlcjMxMjIyNzQw",
      "is_bot": false,
      "login": "Firestar99",
      "name": ""
    },
    "body": "If you compile a crate with rust-gpu but **forget** to add \r\n```toml\r\n[lib]\r\ncrate-type = [\"lib\", \"dylib\"]\r\n```\r\nin it's `cargo.toml` rust-gpu will error out with: `Artifact created when compilation succeeded`.\r\nThis Error is outright wrong: What actually happened is that compilation succeeded but **NO** *.spv artifact was found. \r\n\r\nThe error is thrown in `crates/spirv-builder/src/lib.rs` line 538, at the end of the invoke_rustc() method. \r\nI'd like to suggest replacing this message with `Compilation succeeded but no .spv Artifact was created! Make sure the crate-type includes \\\"dylib\\\".`",
    "comments": [
      {
        "id": "IC_kwDOENG4485PfV58",
        "author": {
          "login": "oisyn"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "Thank you for reporting this.",
        "createdAt": "2022-12-01T11:24:50Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/955#issuecomment-1333616252",
        "viewerDidAuthor": false
      }
    ],
    "createdAt": "2022-11-30T14:32:49Z",
    "labels": [
      {
        "id": "MDU6TGFiZWwyMjI3MzM4ODE2",
        "name": "t: enhancement",
        "description": "A new feature or improvement to an existing one.",
        "color": "52E8A0"
      }
    ],
    "number": 955,
    "reactionGroups": [],
    "state": "OPEN",
    "title": "Minor Bug: Misleading error message when compile succeeds but no *.spv was found",
    "url": "https://github.com/EmbarkStudios/rust-gpu/issues/955"
  },
  {
    "author": {
      "id": "MDQ6VXNlcjc3NDI0",
      "is_bot": false,
      "login": "eddyb",
      "name": "Eduard-Mihai Burtescu"
    },
    "body": "I was writing up this SPIR-T issue when I realized we can do much better than I ever thought we can:\r\n* https://github.com/EmbarkStudios/spirt/issues/11\r\n\r\n### The \"subgroup reconvergence\"/\"loop merges\" problem statement\r\n\r\n> the fundamental ambiguity here (wrt reconvergence), that explicit merges solve, looks like this:\r\n> ```rust\r\n> loop {\r\n>     // ...\r\n>     if cond {  // the \"then\" edge *leaves the loop*\r\n>         A();   // !!! it might be important that this STAYS INSIDE the loop!\r\n>         break; // this is just a linear A -> B edge in the CFG (outside the loop's cycle)\r\n>     }\r\n> }\r\n> B(); // !!! it might be important that this STAYS OUTSIDE the loop!\r\n> ```\r\n> because the `A()` -> `B()` edge just looks like a redundant fusable edge (isomorphic to a single `A(); B();` basic block), structurizers will very likely either produce:\r\n> * `loop { ... if cond { break; } } A(); B();` (moving `A()` *out of* the `loop`)\r\n>   * `A()` no longer called for \"early finishers\" (losing a desired side-effect)\r\n> * `loop { ... if cond { A(); B(); break; } }` (moving `B()` *into* the `loop`)\r\n>    * `B()` now being called for \"early finishers\" (gaining an undesired side-effect)\r\n> \r\n> and they're both bad because a non-uniform `break` (i.e. an \"early finisher\") will *block on subgroup neighbors* (semantically, at least, in hardware the now-inactive lanes will likely stick around while loop instructions continue being executed for remaining lanes, until they all eventually `break`)\r\n\r\n### An actual reasonable solution for once (what prompted me to open this issue)\r\n\r\n> A better approach might be to \"just\" make up a SPIR-T instruction that acts as \"loop merge barrier\", i.e.:\r\n> ```rust\r\n> loop {\r\n>     // ...\r\n>     if cond {\r\n>         A();   // !!! definitely INSIDE the loop\r\n>         break; // just an edge to the `LoopMerge`, in the CFG\r\n>     }\r\n> }\r\n> asm!(\"spirt.ControlInst.LoopMerge\");\r\n> B(); // !!! definitely OUTSIDE the loop\r\n> ```\r\n> Each `LoopMerge` would be consumed by one loop structurization - if you have nested loops, you'd need to be careful not to forget to add them to each loop.\r\n> \r\n> But wait, even if we make this ergonomic with macros... we'd still want to check that you don't use any instructions that \"care\" about e.g. subgroups, right? That could be e.g. a MIR check pass, right? Which we can inject... just like...\r\n> \r\n> Yes, that's right, `rustc_codegen_spirv` has enough query overriding power that it could override `thir_body`, [which MIR construction uses as the source of truth](https://github.com/rust-lang/rust/blob/fd815a5091eb4d49cd317f8ad272f17b7a5f550d/compiler/rustc_mir_build/src/build/mod.rs#L67-L75), to introduce additional nodes around loops, allowing Rust to be on par with GLSL wrt structured control-flow guarantees.\r\n\r\n---\r\n\r\nAdditionally, this could be used to replace `#[spirv(unroll_loops)]` (once that's removed, see https://github.com/EmbarkStudios/rust-gpu/pull/940#issuecomment-1320004784 for more context), as it would allow us to check for a (new) `#[spirv(unroll)]` attribute on *the loop expression*, and then store that in the injected merge point.\r\n\r\nThat would be much nicer than fn-level catch-alls, and generally a good fit for SPIR-V expressivity.",
    "comments": [
      {
        "id": "IC_kwDOENG4485nlExA",
        "author": {
          "login": "eddyb"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "There might be a simpler way to do this, by placing, just before every `break`:\r\n```rust\r\nif black_box(false) { // or rather, some `asm!` equivalent\r\n    // This will never be reached, but the potential to continue looping\r\n    // would keep the `break`-ing block considered to be part of the loop.\r\n    continue;\r\n}\r\n```\r\n(with the condition being replaced by `false` *only after* SPIR-T structurization)\r\n\r\nThis does require SPIR-T structurization to do \"minimal loops\", but that's already the plan, given how unusual/unexpected/unwanted the \"maximal loops\" naturally produced by the structurization algorithom, are.\r\n\r\nThe only serious caveat I potentially foresee is this could impact borrow/move checking, and cause Rust errors that wouldn't be there if the loop was treated as \"definitely being exited\" from those `break`s.",
        "createdAt": "2023-09-27T17:01:51Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/944#issuecomment-1737772096",
        "viewerDidAuthor": false
      }
    ],
    "createdAt": "2022-11-24T08:17:49Z",
    "labels": [],
    "number": 944,
    "reactionGroups": [
      {
        "content": "THUMBS_UP",
        "users": {
          "totalCount": 1
        }
      }
    ],
    "state": "OPEN",
    "title": "We should override `thir_body` to inject loop merge points for structurization.",
    "url": "https://github.com/EmbarkStudios/rust-gpu/issues/944"
  },
  {
    "author": {
      "id": "MDQ6VXNlcjIxMjA0NzI3",
      "is_bot": false,
      "login": "watjurk",
      "name": "Wiktor Jurkiewicz"
    },
    "body": "# Summary\r\n`rustc_codegen_spirv` is compiled and discovered in a very hacky way. Cargo compiles `rustc_codegen_spirv` because it is inside `spirv-builder`'s Cargo.toml as a dependency, and then `spirv-builder` discovers the `rustc_codegen_spirv`'s dylib by this super hacky function: [`find_rustc_codegen_spirv`](https://github.com/EmbarkStudios/rust-gpu/blob/main/crates/spirv-builder/src/lib.rs#L378-L391). I think this should be avoided.\r\n\r\n# Motivation\r\nWhen I've tried to build something using `spirv-builder` this hacky discovery was not working for me.\nAlso `rustc_codegen_spirv` is compiled using the same profile as `spirv-builder` and we end up with `rustc_codegen_spirv` being build _without_ optimizations (if we are in debug mode). This is a big problem because compiling `rustc_codegen_spirv` is a one time cost, but while developing one would recompile thier shaders many times.\nProposed solution is much more elegant than current implemention.\r\n\r\n# Solution\r\nLet's move `rustc_codegen_spirv` into another trait witch will compile `rustc_codegen_spirv` and provide path to it's dylib file.\r\nI've crated an example of how this could be implements: https://github.com/watjurk/spirv-builder-alternative, here is a short summary:\r\n\r\nAll of this happens inside [crates/rustc_codegen_spirv](https://github.com/EmbarkStudios/rust-gpu/tree/main/crates/rustc_codegen_spirv):\r\n### `Cargo.toml`:\r\n```toml\r\n[package]\r\nname = \"rustc_codegen_spirv_compiler\"\r\n```\r\n### `src/lib.rs`:\r\n```rust\r\npub fn dylib_path() -> PathBuf {\r\n// Compile rustc_codegen_spirv using cargo and return path to it's dylib file.\r\n}\r\n```\r\n### `src/rustc_codegen_spirv`\r\n```\r\nFolder with the `rustc_codegen_spirv` crate.\r\n```\r\n\r\n# Future\r\nIn the future this approach could be modified without breaking code that relies on `dylib_path` function, for example we can serve pre-builed dylib's of rustc_codegen_spirv and `dylib_path` instead of building `rustc_codegen_spirv` will download one of the pre-build dylib's depending on user's hardware.",
    "comments": [
      {
        "id": "IC_kwDOENG4485IwBVx",
        "author": {
          "login": "eddyb"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "I agree it's *noticeably* suboptimal right now, and we have been wondering for a while about alternatives.\r\n\r\nHowever, there are more variations to what we could do (cc @repi @oisyn).\r\n\r\n#### How should `rustc_codegen_spirv` be built?\r\n*(:stop_sign: used below to represent \"downsides\" aka \"cons\" in a easy-to-spot way)*\r\n* **`D`ependency** **_(current)_**: by Cargo *only* because it's a dependency (of `spirv-builder`)\r\n  :stop_sign: copying `rust-toolchain` from Rust-GPU is mandatory (*and* your own code has to *also* be built with that nightly, if it depends on `spirv-builder`, *not* just the codegen backend dylib)\r\n  :stop_sign: unoptimized build by default, without changing `Cargo.toml` (esp. if `spirv-builder` is a build \r\n  * dependency **`kind`**:\r\n    * `normal` **_(current)_**\r\n      :stop_sign: if `spirv-builder` is used both as a normal and build dep itself, this will likely lead to multiple builds of `rustc_codegen_spirv`\r\n    * `build`\r\n      :stop_sign: always has the unoptimized issue (see above)\r\n* **`S`pirv-builder**: `spirv-builder` running `cargo build -p rustc_codegen_spirv` itself\r\n  :stop_sign: if `spirv-builder` is a build dependency, it's tricky (if even possible) to show *build progress*\r\n  * **`when`** to run the build:\r\n    * `dynamic`: when `spirv_builder::...` APIs are used\r\n      *(IIUC, @watjurk is suggesting specifically this choice)*\r\n      :stop_sign: extra \"is it fresh\" checks every time\r\n      :stop_sign: may be inadvertently affected by e.g. environment variables\r\n    * `build`: build script (`spirv_builder::...` refer to a path compiled-in via `env!`)\r\n      :stop_sign: exacerbates the progress issue (see above)\r\n  * how to determine the **`version`**:\r\n    * ~~`hardcoded`: every time we publish we change `spirv-builder` source code~~\r\n      :stop_sign: manual work or scripting required (pretty messy)\r\n    * `same`: get it from `env!(\"CARGO_PKG_VERSION\")` of `spirv-builder`\r\n      :stop_sign: have to assume either https://github.com/EmbarkStudios/rust-gpu or crates.io\r\n      :stop_sign: can't work for specific git revisions (since they're not part of the version)\r\n    * `unbuilt-dep`: make `spirv-builder` depend on `rustc_codegen_spirv` but with impossible conditions, or optional (could just make `spirv-builder/build.rs` error if enabled), so that Cargo fetches the dependency and we can find it through e.g. `cargo metadata` (or build it with `-p` etc.)\r\n      :stop_sign: may still pollute `Cargo.lock`, introduce versioning conflicts, etc.\r\n    * ~~`bundled`: have the packaging process archive all the relevant source code~~\r\n      :stop_sign: would skip relying on Cargo to fetch that source code, but it's still an additional step in a weird place, and so has all the problems of `hardcoded` *and* `same`\r\n      * **EDIT**: to be clear, this meant a \"manual archive\" step that we would need a shell script for, and to do before every `cargo publish` - in https://github.com/EmbarkStudios/rust-gpu/issues/911#issuecomment-1220624393 I finally understood that @watjurk had a much more interesting trick that \"just\" relies on putting *the entirety of `rustc_codegen_spirv`* inside the `src/` of another Cargo package, that should get its own entry here\r\n  * what **`toolchain`** to use:\r\n    * `rustup`: we rely on `rust-toolchain` and/or explicit `rustup` commands to run the build\r\n      :stop_sign: not everyone might have `rustup` installed, they might be running the outermost build with some pinned version scheme of their own choice etc.\r\n    * ~~`download`: we basically pretend to be `rustup` and do the above~~\r\n      :stop_sign: pretty much a bad idea across the board (e.g. distros can provide `rustup` that works slightly better, or at all, and this would just break in those cases)\r\n    * ~~`stable`: we abuse `RUSTC_BOOTSTRAP` and support specific stable versions~~\r\n      :stop_sign: I doubt we could even get `rustc-dev`, and very likely not from non-`rustup` distro packages either - and `RUSTC_BOOTSTRAP` is terrible to mess with anyway, let's not...\r\n  * where to **`cache`** the built backend dylib:\r\n    * `target-dir`: we nest it in `$OUT_DIR` or at most go up a bit from it (could use a temporary build dir, like `cargo install` does, then move the resulting dylib to `$OUT_DIR`)\r\n      :stop_sign: built once per Cargo workspace, potentially even profile\r\n    * `per-toolchain`: somewhere in `.rustup/toolchains/$our_current_nightly/...`\r\n      :stop_sign: we'd have to hash all the relevant version/source-path/etc. details to use as a \"cache key\", cache invalidation is hard, file locking, there's quota concerns, `rustup` might not like toolchain dirs being altered, etc.\r\n    * `per-user`: somewhere in [`$XDG_CACHE_HOME`](https://specifications.freedesktop.org/basedir-spec/latest/ar01s03.html) (i.e. `~/.cache`)\r\n      :stop_sign: same as `per-toolchain` above, except even less scoped (e.g. the files would be kept around even if the user removes the relevant `rustup` toolchain)\r\n* **`M`anually**: separate \"install Rust-GPU\" step (e.g. into `.rustup/toolchains/...`)\r\n  :stop_sign: like `spirv-build` automatic `per-toolchain`/`per-user` caching, but requiring **user interaction** outside of Cargo builds\r\n  * could be offered *in conjunction* with extra automation, to ensure `spirv-builder` doesn't itself *also* need to build the toolchain, but also allowing more direct usage?\r\n  * this also ties into artifact dependencies which would likely *always* require a modified toolchain if we want to use them\r\n  * (mostly included for completeness, it can't possibly be a full solution IMO, not without having a way to put something in `rust-toolchain`)\r\n\r\n<sub>(I tried using a table and it feels like I would need 3D or 4D tables to make it work well... in the end I opted to list mostly cons and not so much pros - also, I gave each aspect names so that I can refer to them later but it didn't end up being useful)</sub>\r\n\r\nYou may notice that I've even included \"really bad ideas\" in there (decided to use ~~strikethrough~~ to indicate them) - I really want to be clear about the *size* of the solution space, so that we don't make too many assumptions without realizing.\r\n\r\nEven ignoring the unviable options, there's still 14 combinations (12 if we assume `S`).\r\n\r\n<hr/>\r\n\r\nIf I had to pick one, `S` `when=build` `version=unbuilt-dep` `toolchain=rustup` `cache=per-toolchain` is probably a local optimum: it may upset Cargo and/or `rustup`, reporting progress may be annoying/hard/impossible, but it would ideally minimize configuration (use it directly from stable code or any toolchain!), maximize reuse between different build dirs, always have an optimized backend, be directly usable from runtime code for e.g. a hot reloading (without the hacks we need in-tree for all that), etc.\r\n\r\nBut hybrids are also interesting, e.g. `version=same` for published versions and something different when developing on Rust-GPU itself (to avoid storing a zillion unique dylibs, and also to enable incremental etc.).\r\n\r\nAlso, to be perfectly clear: I am not *strongly* attached to any one idea, all I want to is to present as much as possible so that we can choose knowing what we're deciding *against*. And it's also possible I missed things, I may edit this comment or try to figure out a better presentation for all the options (might be easier if we decide on *some* of them first).",
        "createdAt": "2022-08-19T11:10:22Z",
        "includesCreatedEdit": true,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/911#issuecomment-1220547953",
        "viewerDidAuthor": false
      },
      {
        "id": "IC_kwDOENG4485IwJtY",
        "author": {
          "login": "watjurk"
        },
        "authorAssociation": "NONE",
        "body": "I think that this is not what I meant, I'd like to decouple the process of compiling `rustc_codegen_spirv` from `spirv-builder`, so that for `spirv-builder` obtaining the dylib is just a matter of calling something like this:\r\n```rust\r\nlet path_to_dylib = rustc_codegen_spirv:: dylib_path();\r\n```\r\nIf you think about it `spirv-builder` should not be responsible for building  `rustc_codegen_spirv`, this logic should be contained inside `rustc_codegen_spirv` and. I'd opt for the `bundled` version, just like in my [example](https://github.com/watjurk/spirv-builder-alternative) the [target_crate](https://github.com/watjurk/spirv-builder-alternative/tree/master/src/target_crate) is contained within the `rust_cargo_build_nested` crate. In my opinion this option is the most correct one because then we get the version from the parent crate. \r\nThe unbuilt-dep poposition would still work in this scenario just that `rust_cargo_build_nested` would depend on the [target_crate](https://github.com/watjurk/spirv-builder-alternative/tree/master/src/target_crate).\r\n\r\nThe next question is, from what perspective are we looking at it? For example from user's perspective who is running `spirv-builder` inside thier's `build.rs` script the compilation of `rustc_codegen_spirv` is really happening at compiletime.\r\n",
        "createdAt": "2022-08-19T11:48:38Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/911#issuecomment-1220582232",
        "viewerDidAuthor": false
      },
      {
        "id": "IC_kwDOENG4485IwUAJ",
        "author": {
          "login": "eddyb"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "> I think that this is not what I meant, I'd like to decouple the process of compiling `rustc_codegen_spirv` from `spirv-builder`\r\n\r\nThis is orthogonal from pretty much everything I described, at least AFAICT. You can imagine that (almost) every time I said `spirv-builder` I meant some new `rustc_codegen_spirv-builder` crate that `spirv-builder` depends on, and which provides the `dylib_path` method you're thinking of (though really it should be a constant), it doesn't change almost anything about the solution space matrix (at most it's just another axis).\r\n<sub>(We really don't want to change what `rustc_codegen_spirv` is, i.e. it should remain the dylib that `rustc` loads when we pass `-Z codegen-backend=...`, you can use `-...` after its name to indicate some helper crate related to it, but not rename the crate itself)</sub>\r\n\r\n<hr/>\r\n\r\n> I'd opt for the `bundled` version\r\n\r\n`bundled` (**EDIT**: in its \"manual archive\" form I imagined, see below!) is not really workable because we would need some kind of shell script to make a `.tar.gz` or `.zip` or something with the contents of `crates/rustc_codegen_spirv` and then require that on every `cargo publish`, and there would be no easy way to use a git dependency, and it's so unidiomatic and an ops nightmare that you can just ignore it (even if you can trick `cargo publish` into bundling it for you as \"extra files\" in the crate, it's still a lot of trouble for something very fragile).\r\n\r\n> just like in my [example](https://github.com/watjurk/spirv-builder-alternative) the [target_crate](https://github.com/watjurk/spirv-builder-alternative/tree/master/src/target_crate) is contained within the `rust_cargo_build_nested` crate\r\n\r\nOh that's in an `src/` directory? So that would probably fit into \"trick `cargo publish` into including it\".\r\nI'm still not extremely confident it won't break in some weird way but I can see why you brought it up now.\r\n\r\nThis probably means we need to split up `bundled` into two (\"manual archive\" vs \"nested crates\"). My earlier confusion stems from thinking \"manual archive\" when I wrote the `bundled` entry, and also taking a while to notice the precise way you have placed a whole Cargo package directory inside the `src/` of another.\r\n\r\n<hr/>\r\n\r\n> The next question is, from what perspective are we looking at it? For example from user's perspective who is running `spirv-builder` inside thier's `build.rs` script the compilation of `rustc_codegen_spirv` is really happening at compiletime.\r\n\r\n\"What needs to run every time you change the shaders\" is how I see it (and this applies to both build scripts and hot reloading usecases) - there's no reason (IMO) to keep checking if we need to rebuild `rustc_codegen_spirv` every time the shaders change, if we can avoid it (and Cargo has various ways of minimizing the cost of checking if rebuilds are necessary, for the things that *it* is in control).\r\n\r\nBut that is a quite minor point compared to everything else, a microoptimization almost.\r\n\r\nGenerally, I'm trying to describe how `spirv-builder` (or `rustc_codegen_spirv-builder`, if you want) *work internally*, while still worrying about end-user UX like `rust-toolchain`/`Cargo.toml` configuration friction, how build progress is indicated, etc. (a bit like if an user of Rust-GPU had an \"xray view\" of the whole process).",
        "createdAt": "2022-08-19T12:36:22Z",
        "includesCreatedEdit": true,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/911#issuecomment-1220624393",
        "viewerDidAuthor": false
      },
      {
        "id": "IC_kwDOENG4485Ix-8b",
        "author": {
          "login": "watjurk"
        },
        "authorAssociation": "NONE",
        "body": "I'll point out some things:\r\n1. `rustc_codegen_spirv` _requires_ the following components to _compile_: [\"rustc-dev\", \"llvm-tools-preview\"], so in order to install them we are forced to use `rustup`, so as a consequence our users are forced to use `rustup`, so the issue of installing toolchain is gone because we must have `rustup`.\r\n2. `rustc_codegen_spirv` _should_ not have any features that user can enable/disable, I'd even argue that we should remove `use-installed-tools` and `use-compiled-tools`, for reasons I'll explain later.\r\n3. `rustc_codegen_spirv` _should_ be it's own fully self-contained crate that would not be influenced by user in any way.\r\n\r\nI'd like to have all of this to prepare `rustc_codegen_spirv` for the **Future**. By the **Future** I mean that we should not require users to _compile_ `rustc_codegen_spirv`, instead we should provide pre-build binaries that would be downloaded by `dylib_path` function. The overall interface would stay the same just that we would not _compile_ `rustc_codegen_spirv `, we would download it. In order to do this seamlessly `rustc_codegen_spirv` cannot depend on user input in any way, that's why I think we should remove `use-installed-tools` and `use-compiled-tools`. \r\nLastly, when you download rust are you compiling rustc's backend? No, you are getting it pre-build, I think the same should happen in rust-gpu's case.\r\n\r\nPs: The \"nested-creates\" approach (solution proposed by me) would satisfy the 3rd point.",
        "createdAt": "2022-08-19T20:19:36Z",
        "includesCreatedEdit": true,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/911#issuecomment-1221062427",
        "viewerDidAuthor": false
      },
      {
        "id": "IC_kwDOENG4485s6F5D",
        "author": {
          "login": "eddyb"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "Finally took a stab at something like this, in:\r\n- https://github.com/EmbarkStudios/rust-gpu/pull/1103\r\n\r\nIt's `S` `when=build` `version=unbuilt-dep` `toolchain=rustup` `cache=target-dir`, in my old taxonomy (i.e. the only difference from my previous thoughts is that I used to think `cache=per-toolchain` made sense - maybe it still does, but this stuff is awkward enough as-is within one target-dir, and would likely need custom locking and cache invalidation etc. to make it per-toolchain, not to mention the many rebuilds while *working on* Rust-GPU).\r\n\r\nWhile `version=unbuilt-dep` was possible in the end, it's pretty convoluted (even using `cargo_metadata`, Cargo doesn't really want to let you enable optional dependencies except if you have control of the the workspace).\r\n\r\nAlso, I've kept the dual features that @watjurk disliked, but I can kinda see how bad they are for this, I ended up having to treat them like they cause different `rustup` toolchains to be used (i.e. nothing is shared between `use-compiled-tools` builds and `use-installed-tools` builds) - it's a shame, but I'm not sure what we can do in the long term (other than stop needing `SPIRV-Tools` entirely, but that's not happening any time soon).",
        "createdAt": "2023-11-27T05:57:00Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/911#issuecomment-1827167811",
        "viewerDidAuthor": false
      },
      {
        "id": "IC_kwDOENG44851MR8o",
        "author": {
          "login": "eddyb"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "New (conceptual) development:\r\n- #1137\r\n\r\nThis is simultaneously very similar to existing setups (mostly only what decides the Rust-GPU version changes!), but also unlocks _a lot more_, because we can make a single version of some CLI tool work with many backend versions, _as long as it's picked up from the shader crate_ (whether `spirv-std` or `rust-gpu` etc.).\r\n\r\nAFAICT in the original nomenclature earlier in the thread, `S`/`version=` could only be one of:\r\n`hardcoded`, `same`, `unbuilt-dep`, `bundled` - but they all refer to `spirv-builder` + `rustc_codegen_spirv`, _whereas_ the new one would pull it from the shader itself (even if likely a lot like #1103).\r\n\r\nThe easiest thing we could try would be:\r\n`S` _`when=dynamic` `version=shader-*`_ `toolchain=rustup` `cache=target-dir`\r\n<sub>(not sure what `version=` names would even make sense. I denoted changes from #1103 in italics, but `build`->`dynamic` is not that big of the deal when you control the whole build, mostly an issue of being careful around env vars)</sub>\r\n\r\nAlso, if we get `-Z script` working for shaders, those _might_ end up having their `~/.cargo`-backed target dirs anyway, even if we don't come up with our own global caching (in fact, we could probably rely on `-Z script` to trigger the `rustc_codegen_spirv` build, so Cargo can both cache it globally and ideally reuse it).",
        "createdAt": "2024-02-27T09:41:36Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/911#issuecomment-1966153512",
        "viewerDidAuthor": false
      }
    ],
    "createdAt": "2022-08-18T14:51:57Z",
    "labels": [
      {
        "id": "MDU6TGFiZWwyMjI3MzM4ODE2",
        "name": "t: enhancement",
        "description": "A new feature or improvement to an existing one.",
        "color": "52E8A0"
      }
    ],
    "number": 911,
    "reactionGroups": [],
    "state": "OPEN",
    "title": "Refactor how rustc_codegen_spirv is compiled",
    "url": "https://github.com/EmbarkStudios/rust-gpu/issues/911"
  },
  {
    "author": {
      "id": "MDQ6VXNlcjIxMjM4Nzc2",
      "is_bot": false,
      "login": "oisyn",
      "name": "Sylvester Hesp"
    },
    "body": "From @hrydgard: The builtin `#[spirv(global_invocation_id)] id: UVec3` needs to be declared as an UVec3, and then truncated if you want a Vec2. In HLSL and GLSL it's common to declare it as a 2-vector instead (UVec2) if you only care about x and y.",
    "comments": [],
    "createdAt": "2022-07-13T09:45:42Z",
    "labels": [
      {
        "id": "MDU6TGFiZWwyMjg3MDgzNjM2",
        "name": "t: ergonomics",
        "description": "Language ergonomics discussions and experimentation",
        "color": "52E8A0"
      }
    ],
    "number": 885,
    "reactionGroups": [],
    "state": "OPEN",
    "title": "Be more lenient on the vector type used for global_invocation_id",
    "url": "https://github.com/EmbarkStudios/rust-gpu/issues/885"
  },
  {
    "author": {
      "id": "MDQ6VXNlcjIxMjM4Nzc2",
      "is_bot": false,
      "login": "oisyn",
      "name": "Sylvester Hesp"
    },
    "body": "Although we only support SpirV as a target right now and implementing a DXIL backend would still be a thing of the distant future, it doesn't make much sense to have the attribute that annotates generic gpu stuff be called \"spirv\". Changing it into a more platform agnostic name early on in the project would prevent breaking a lot of GPU code later on.",
    "comments": [],
    "createdAt": "2022-07-06T12:43:58Z",
    "labels": [],
    "number": 883,
    "reactionGroups": [
      {
        "content": "THUMBS_UP",
        "users": {
          "totalCount": 3
        }
      }
    ],
    "state": "OPEN",
    "title": "Rename spirv attribute",
    "url": "https://github.com/EmbarkStudios/rust-gpu/issues/883"
  },
  {
    "author": {
      "id": "MDQ6VXNlcjc3NDI0",
      "is_bot": false,
      "login": "eddyb",
      "name": "Eduard-Mihai Burtescu"
    },
    "body": "Cargo build scripts have the ability to produce output through Cargo via [`cargo:warning=MESSAGE`](https://doc.rust-lang.org/cargo/reference/build-scripts.html#cargo-warning) *even when successful*.\r\n\r\nWe should probably make `spirv-builder` transform `stderr` lines from its nested `cargo build` (of the shaders) into `cargo:warning`, but we may need to use the JSON output mode to be able to tell apart Cargo output from `rustc` output (as we presumably don't want to dump `Compiling ...` messages as \"warnings\").\r\n\r\nWe already pass `--message-format=json-render-diagnostics` to the nested `cargo build` though (to parse out \"artifact notifications\"), so it should be pretty easy to further rely on the JSON output.",
    "comments": [],
    "createdAt": "2022-07-04T06:48:36Z",
    "labels": [
      {
        "id": "MDU6TGFiZWwyMjI3MzM4ODE2",
        "name": "t: enhancement",
        "description": "A new feature or improvement to an existing one.",
        "color": "52E8A0"
      }
    ],
    "number": 880,
    "reactionGroups": [],
    "state": "OPEN",
    "title": "spirv-builder could show warnings from building shaders.",
    "url": "https://github.com/EmbarkStudios/rust-gpu/issues/880"
  },
  {
    "author": {
      "id": "MDQ6VXNlcjcxOTcyOTg=",
      "is_bot": false,
      "login": "SiebenCorgie",
      "name": "Tendsin Mende"
    },
    "body": "When trying to compile a shader with a runtime array descriptor without having `Capability::RuntimeDescriptorArray` enabled on `SpirvBuilder` emits an unintuitive error.\r\n\r\nFor instance the following main function:\r\n```rust\r\n#[spirv(fragment)]\r\npub fn main_fs(\r\n   ...,\r\n   #[spirv(push_constant)] push: &PushConst,\r\n    #[spirv(descriptor_set = 0, binding = 0)] sampled_images: &RuntimeArray<SampledImage<Image!(2D, type=f32, sampled)>>,\r\n    ...\r\n) {\r\n    //...\r\n    let img = unsafe { sampled_images.index(push.texture_indices[0] as usize) };\r\n    //...    \r\n}\r\n```\r\nemits this error:\r\n```\r\nerror: OpVariable, <id> '19[%sampled_images]', is attempting to create memory for an illegal type, OpTypeRuntimeArray.\r\n       For Vulkan OpTypeRuntimeArray can only appear as the final member of an OpTypeStruct, thus cannot be instantiated via OpVariable\r\n         %sampled_images = OpVariable %_ptr_UniformConstant__runtimearr_40 UniformConstant\r\n```\r\n\r\nWhile the error is correct without the capability, the use of `RuntimeArray` probably indicates that `RuntimeDescriptorArrays` is assumed to be present.\r\n\r\nA small hint like: \"Do you need to enabled the RuntimeDescriptorArray capability?\" would be appropriate,",
    "comments": [],
    "createdAt": "2022-06-07T13:28:24Z",
    "labels": [
      {
        "id": "MDU6TGFiZWwyMjI3MzM4ODE2",
        "name": "t: enhancement",
        "description": "A new feature or improvement to an existing one.",
        "color": "52E8A0"
      }
    ],
    "number": 879,
    "reactionGroups": [],
    "state": "OPEN",
    "title": "Declaring RuntimeArray without `Capability::RuntimeDescriptorArray` set on `SpirvBuilder` emits an unintuitive error message.",
    "url": "https://github.com/EmbarkStudios/rust-gpu/issues/879"
  },
  {
    "author": {
      "id": "MDQ6VXNlcjEzNzM4Mjk=",
      "is_bot": false,
      "login": "molikto",
      "name": ""
    },
    "body": "basically is it possible to have \r\n\r\n\r\n```\r\n\r\n#[repr(transparent)]\r\npub struct Test([u32]);\r\n\r\n#[spirv(compute(threads(8, 8)))]\r\npub fn entry(\r\n    #[spirv(storage_buffer, descriptor_set = 0, binding = 0)] data: &Test,\r\n) {\r\n}\r\n```",
    "comments": [],
    "createdAt": "2022-06-04T07:56:52Z",
    "labels": [
      {
        "id": "MDU6TGFiZWwyMjI3MzM4ODE2",
        "name": "t: enhancement",
        "description": "A new feature or improvement to an existing one.",
        "color": "52E8A0"
      },
      {
        "id": "LA_kwDOENG4488AAAABPXHqow",
        "name": "s: qptr may fix",
        "description": "This might be fixed by the \"qptr\" experiment (https://github.com/EmbarkStudios/spirt/pull/24)",
        "color": "CCCCCC"
      }
    ],
    "number": 878,
    "reactionGroups": [],
    "state": "OPEN",
    "title": "Drop the constraint \"only plain slices are supported as unsized types\"",
    "url": "https://github.com/EmbarkStudios/rust-gpu/issues/878"
  },
  {
    "author": {
      "id": "MDQ6VXNlcjEzNzM4Mjk=",
      "is_bot": false,
      "login": "molikto",
      "name": ""
    },
    "body": "<!-- Thank you for filing a bug report! üêõ -->\r\n\r\n### Expected Behaviour\r\n\r\nspriv-val should not fail. Looks it's because the bug mentioned here https://github.com/EmbarkStudios/rust-gpu/pull/690#pullrequestreview-719958024 . I will try to make a PR to fix it\r\n\r\n### Example & Steps To Reproduce\r\n\r\nThis shader fails with `spirv-val` error\r\n\r\nBut either:\r\n\r\n1. move out of the closure\r\n2. remove the rayquery\r\n\r\nMake it compile successfully.\r\n\r\n\r\n```rust\r\n// build-pass\r\n// compile-flags: -Ctarget-feature=+RayTracingKHR,+RayQueryKHR,+ext:SPV_KHR_ray_tracing,+ext:SPV_KHR_ray_query\r\n\r\n#[cfg(not(target_arch = \"spirv\"))]\r\nuse spirv_std::macros::spirv;\r\nuse spirv_std::ray_tracing::{AccelerationStructure, RayFlags, RayQuery};\r\nuse spirv_std::{glam::Vec3, ray_query};\r\nuse spirv_std::macros::spirv;\r\nuse spirv_std::ray_tracing::{AccelerationStructure, CommittedIntersection, RayFlags, RayQuery};\r\nuse spirv_std::{glam::Vec3, ray_query};\r\n\r\npub fn some_fun(mut c: impl FnMut() -> bool) {\r\n    let mut i = 0;\r\n    while i < 10 {\r\n        if c() {\r\n            return;\r\n        }\r\n        i += 1;\r\n    }\r\n}\r\n#[spirv(intersection)]\r\npub fn voxels_gbuffer_is(\r\n    #[spirv(storage_buffer, descriptor_set = 1, binding = 1)] vertices: &[u32],\r\n    #[spirv(descriptor_set = 1, binding = 3)] acceleration_structure: &AccelerationStructure,\r\n) {\r\n    some_fun(|| {\r\n        unsafe {\r\n            ray_query!(let mut handle);\r\n            handle.initialize(\r\n                acceleration_structure,\r\n                RayFlags::TERMINATE_ON_FIRST_HIT,\r\n                0xFF,\r\n                Vec3::new(0.0, 0.0, 0.0),\r\n                0.0,\r\n                Vec3::new(0.0, 0.0, 0.0),\r\n                10000.0,\r\n            );\r\n            unsafe {\r\n                // Indices of the triangle\r\n                let ind = vertices.index_unchecked(0);\r\n            };\r\n            true\r\n        }\r\n    });\r\n}\r\n\r\n\r\n```\r\n\r\n\r\n\r\n## System Info\r\n<!--\r\nHelpful commands:\r\n- Rustc version: `rustc -V`\r\n- SPIR-V version: `spirv-val --version`\r\n-->\r\n\r\n - Rust: rustc 1.62.0-nightly (1f7fb6413 2022-04-10)\r\n - OS: Windows 10  Version\t10.0.19044 Build 19044\r\n - GPU: RTX 3070 Ti\r\n - SPIR-V: SPIRV-Tools v2022.2-dev v2022.1-6-g45dd184c\r\n\r\n\r\n## Backtrace\r\n<!-- If relevant, please include a backtrace of the error below. -->\r\n\r\n<details><summary>Backtrace</summary>\r\n<p>\r\n\r\n```\r\nerror: error:0:0 - OpLoad Pointer <id> '58[%58]' is not a logical pointer.\r\n         %61 = OpLoad %20 %58\r\n  |\r\n  = note: spirv-val failed\r\n```\r\n\r\nspirv:\r\n```\r\n; SPIR-V\r\n; Version: 1.3\r\n; Generator: Embark Studios Rust GPU Compiler Backend; 0\r\n; Bound: 76\r\n; Schema: 0\r\n               OpCapability Int16\r\n               OpCapability Int64\r\n               OpCapability Int8\r\n               OpCapability RayQueryKHR\r\n               OpCapability RayTracingKHR\r\n               OpCapability Shader\r\n               OpExtension \"SPV_EXT_descriptor_indexing\"\r\n               OpExtension \"SPV_KHR_ray_query\"\r\n               OpExtension \"SPV_KHR_ray_tracing\"\r\n               OpMemoryModel Logical Simple\r\n               OpEntryPoint IntersectionNV %1 \"main\"\r\n          %2 = OpString \"C:\\\\Users\\\\molikto\\\\.cargo\\\\git\\\\checkouts\\\\rust-gpu-c5ec26e609830c67\\\\8609aab\\\\crates\\\\spirv-std\\\\src\\\\arch.rs\"\r\n          %3 = OpString \"crates\\\\mocraft-client\\\\shader\\\\src\\\\lib.rs\"\r\n          %4 = OpString \"C:\\\\Users\\\\molikto\\\\.cargo\\\\git\\\\checkouts\\\\rust-gpu-c5ec26e609830c67\\\\8609aab\\\\crates\\\\spirv-std\\\\src\\\\ray_tracing.rs\"\r\n          %5 = OpString \"C:\\\\Users\\\\molikto\\\\.cargo\\\\git\\\\checkouts\\\\glam-rs-ce970401f3f26dcb\\\\ef12fa7\\\\src\\\\vec3.rs\"\r\n          %6 = OpString \"C:\\\\Users\\\\molikto\\\\.cargo\\\\registry\\\\src\\\\github.com-1ecc6299db9ec823\\\\bitflags-1.3.2\\\\src\\\\lib.rs\"\r\n          %7 = OpString \"C:\\\\Users\\\\molikto\\\\.cargo\\\\git\\\\checkouts\\\\glam-rs-ce970401f3f26dcb\\\\ef12fa7\\\\src\\\\core\\\\scalar\\\\vector.rs\"\r\n               OpName %__u32_ \"&[u32]\"\r\n               OpMemberName %_closure_crates_mocraft_client_shader_src_lib_rs_30_14__47_6_ 0 \"0\"\r\n               OpMemberName %_closure_crates_mocraft_client_shader_src_lib_rs_30_14__47_6_ 1 \"1\"\r\n               OpMemberName %_closure_crates_mocraft_client_shader_src_lib_rs_30_14__47_6_ 2 \"2\"\r\n               OpName %_closure_crates_mocraft_client_shader_src_lib_rs_30_14__47_6_ \"[closure@crates\\\\mocraft-client\\\\shader\\\\src\\\\lib.rs:30:14: 47:6]\"\r\n               OpName %vertices \"vertices\"\r\n               OpName %acceleration_structure \"acceleration_structure\"\r\n               OpDecorate %_runtimearr_uint ArrayStride 4\r\n               OpMemberDecorate %__u32_ 0 Offset 0\r\n               OpMemberDecorate %__u32_ 1 Offset 4\r\n               OpMemberDecorate %_closure_crates_mocraft_client_shader_src_lib_rs_30_14__47_6_ 0 Offset 0\r\n               OpMemberDecorate %_closure_crates_mocraft_client_shader_src_lib_rs_30_14__47_6_ 1 Offset 4\r\n               OpMemberDecorate %_closure_crates_mocraft_client_shader_src_lib_rs_30_14__47_6_ 2 Offset 8\r\n               OpDecorate %_struct_13 Block\r\n               OpMemberDecorate %_struct_13 0 Offset 0\r\n               OpDecorate %vertices DescriptorSet 1\r\n               OpDecorate %vertices Binding 1\r\n               OpDecorate %acceleration_structure DescriptorSet 1\r\n               OpDecorate %acceleration_structure Binding 3\r\n       %uint = OpTypeInt 32 0\r\n%_runtimearr_uint = OpTypeRuntimeArray %uint\r\n%_ptr_StorageBuffer__runtimearr_uint = OpTypePointer StorageBuffer %_runtimearr_uint\r\n     %__u32_ = OpTypeStruct %_ptr_StorageBuffer__runtimearr_uint %uint\r\n     %uint_0 = OpConstant %uint 0\r\n       %void = OpTypeVoid\r\n         %18 = OpTypeRayQueryKHR\r\n%_ptr_Function_18 = OpTypePointer Function %18\r\n         %20 = OpTypeAccelerationStructureKHR\r\n%_ptr_UniformConstant_20 = OpTypePointer UniformConstant %20\r\n      %float = OpTypeFloat 32\r\n    %v3float = OpTypeVector %float 3\r\n%_closure_crates_mocraft_client_shader_src_lib_rs_30_14__47_6_ = OpTypeStruct %_ptr_Function_18 %_ptr_UniformConstant_20 %__u32_\r\n         %24 = OpTypeFunction %void\r\n %_struct_13 = OpTypeStruct %_runtimearr_uint\r\n%_ptr_StorageBuffer__struct_13 = OpTypePointer StorageBuffer %_struct_13\r\n   %vertices = OpVariable %_ptr_StorageBuffer__struct_13 StorageBuffer\r\n%acceleration_structure = OpVariable %_ptr_UniformConstant_20 UniformConstant\r\n       %bool = OpTypeBool\r\n        %int = OpTypeInt 32 1\r\n      %int_0 = OpConstant %int 0\r\n     %int_10 = OpConstant %int 10\r\n      %int_1 = OpConstant %int 1\r\n    %float_0 = OpConstant %float 0\r\n     %uint_4 = OpConstant %uint 4\r\n   %uint_255 = OpConstant %uint 255\r\n%float_10000 = OpConstant %float 10000\r\n       %true = OpConstantTrue %bool\r\n      %false = OpConstantFalse %bool\r\n         %37 = OpUndef %_closure_crates_mocraft_client_shader_src_lib_rs_30_14__47_6_\r\n          %1 = OpFunction %void None %24\r\n         %38 = OpLabel\r\n         %39 = OpVariable %_ptr_Function_18 Function\r\n               OpLine %3 26 4\r\n         %40 = OpAccessChain %_ptr_StorageBuffer__runtimearr_uint %vertices %uint_0\r\n         %41 = OpArrayLength %uint %vertices 0\r\n               OpLine %3 30 13\r\n         %42 = OpCompositeInsert %_closure_crates_mocraft_client_shader_src_lib_rs_30_14__47_6_ %39 %37 0\r\n               OpLine %3 30 13\r\n         %43 = OpCompositeInsert %_closure_crates_mocraft_client_shader_src_lib_rs_30_14__47_6_ %acceleration_structure %42 1\r\n               OpLine %3 30 13\r\n         %44 = OpCompositeInsert %_closure_crates_mocraft_client_shader_src_lib_rs_30_14__47_6_ %40 %43 2 0\r\n         %45 = OpCompositeInsert %_closure_crates_mocraft_client_shader_src_lib_rs_30_14__47_6_ %41 %44 2 1\r\n               OpLine %3 17 4\r\n               OpBranch %46\r\n         %46 = OpLabel\r\n               OpBranch %47\r\n         %47 = OpLabel\r\n         %48 = OpPhi %int %int_0 %46 %49 %50\r\n         %51 = OpPhi %bool %true %46 %52 %50\r\n               OpLoopMerge %53 %50 None\r\n               OpBranchConditional %51 %54 %53\r\n         %54 = OpLabel\r\n               OpLine %3 17 10\r\n         %55 = OpSLessThan %bool %48 %int_10\r\n               OpLine %3 17 10\r\n               OpSelectionMerge %56 None\r\n               OpBranchConditional %55 %57 %58\r\n         %57 = OpLabel\r\n               OpLine %3 32 12\r\n         %59 = OpCompositeExtract %_ptr_Function_18 %45 0\r\n               OpLine %3 33 16\r\n         %60 = OpCompositeExtract %_ptr_UniformConstant_20 %45 1\r\n               OpLine %7 745 8\r\n         %61 = OpCompositeConstruct %v3float %float_0 %float_0 %float_0\r\n               OpLine %7 745 8\r\n         %62 = OpCompositeConstruct %v3float %float_0 %float_0 %float_0\r\n               OpLine %4 246 8\r\n         %63 = OpLoad %20 %60\r\n               OpRayQueryInitializeKHR %59 %63 %uint_4 %uint_255 %61 %float_0 %62 %float_10000\r\n               OpLine %3 18 11\r\n               OpSelectionMerge %64 None\r\n               OpBranchConditional %true %65 %66\r\n         %65 = OpLabel\r\n               OpLine %3 23 0\r\n               OpBranch %64\r\n         %66 = OpLabel\r\n               OpLine %3 21 8\r\n         %67 = OpIAdd %int %48 %int_1\r\n               OpLine %3 17 4\r\n               OpBranch %64\r\n         %64 = OpLabel\r\n         %68 = OpPhi %int %48 %65 %67 %66\r\n         %69 = OpPhi %bool %true %65 %false %66\r\n         %70 = OpPhi %bool %false %65 %true %66\r\n               OpBranch %56\r\n         %58 = OpLabel\r\n               OpLine %3 23 0\r\n               OpBranch %56\r\n         %56 = OpLabel\r\n         %49 = OpPhi %int %68 %64 %48 %58\r\n         %71 = OpPhi %bool %69 %64 %true %58\r\n         %72 = OpPhi %bool %70 %64 %false %58\r\n               OpSelectionMerge %73 None\r\n               OpBranchConditional %71 %74 %75\r\n         %74 = OpLabel\r\n               OpLine %3 48 1\r\n               OpReturn\r\n         %75 = OpLabel\r\n               OpBranch %73\r\n         %73 = OpLabel\r\n         %52 = OpPhi %bool %72 %75\r\n               OpBranch %50\r\n         %50 = OpLabel\r\n               OpBranch %47\r\n         %53 = OpLabel\r\n               OpUnreachable\r\n               OpFunctionEnd\r\n\r\n```\r\n</p>\r\n</details>\r\n\r\n",
    "comments": [
      {
        "id": "IC_kwDOENG4485Yuv3e",
        "author": {
          "login": "oisyn"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "This is the relevant error:\n```\nerror: OpLoad Pointer <id> '58[%58]' is not a logical pointer.\n           %61 = OpLoad %21 %58\n```",
        "createdAt": "2023-03-29T13:47:11Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/873#issuecomment-1488649694",
        "viewerDidAuthor": false
      },
      {
        "id": "IC_kwDOENG4485e-c9T",
        "author": {
          "login": "kevinboulain"
        },
        "authorAssociation": "NONE",
        "body": "FWIW I've hit this with nested closures, here's the smallest repro I could get (tested on b2e5eb7):\r\n```rust\r\n#![cfg_attr(target_arch = \"spirv\", no_std)]\r\nuse spirv_std::{glam::UVec3, spirv};\r\n\r\npub fn inner(i: u32, callback: impl Fn()) {\r\n    callback()\r\n}\r\n\r\npub fn outer(callback: impl Fn()) {\r\n    callback();\r\n}\r\n\r\n#[spirv(compute(threads(1, 1, 1)))]\r\npub fn compute(\r\n    #[spirv(global_invocation_id)] id: UVec3,\r\n    #[spirv(storage_buffer, descriptor_set = 0, binding = 0)] buffer: &[u32],\r\n) {\r\n    outer(|| {\r\n        inner(id.x, || {\r\n            buffer[0];\r\n        })\r\n    });\r\n}\r\n```\r\n\r\n```\r\nerror: OpLoad Pointer <id> '30[%30]' is not a logical pointer.                                                                                                                                                                                                                    \r\n         %31 = OpLoad %uint %30\r\n```",
        "createdAt": "2023-06-15T17:00:08Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/873#issuecomment-1593429843",
        "viewerDidAuthor": false
      }
    ],
    "createdAt": "2022-05-16T06:30:35Z",
    "labels": [
      {
        "id": "MDU6TGFiZWwyMjI3MzM4ODEz",
        "name": "t: bug",
        "description": "Something isn't working",
        "color": "52E8A0"
      },
      {
        "id": "LA_kwDOENG4488AAAABPXHqow",
        "name": "s: qptr may fix",
        "description": "This might be fixed by the \"qptr\" experiment (https://github.com/EmbarkStudios/spirt/pull/24)",
        "color": "CCCCCC"
      }
    ],
    "number": 873,
    "reactionGroups": [],
    "state": "OPEN",
    "title": "Closure capture acceleration structure fails spirv-val",
    "url": "https://github.com/EmbarkStudios/rust-gpu/issues/873"
  },
  {
    "author": {
      "id": "MDQ6VXNlcjE2Njc3NDY=",
      "is_bot": false,
      "login": "hatoo",
      "name": ""
    },
    "body": "<!-- Thank you for filing a bug report! üêõ -->\r\n\r\n### Expected Behaviour\r\n<!-- Please describe what you expected to happen. -->\r\n\r\n`cargo clippy` works without a crash in [this](https://github.com/hatoo/zenn-content/tree/a1a2a28885b970f4ec5934bed96944ea50eadec5/rasterization-example) project.\r\n\r\nIt worked fine in older `rust-gpu`.\r\n\r\n### Example & Steps To Reproduce\r\n<!-- \r\nDescribe what actually happened, including any relevant examples (smaller\r\nthe better), error messages, or the relevant SPIR-V binary. \r\n-->\r\n\r\n1. Clone [this](https://github.com/hatoo/zenn-content/tree/a1a2a28885b970f4ec5934bed96944ea50eadec5/rasterization-example)\r\n2. `cargo clippy`\r\n3. Got error\r\n\r\n```\r\nPS C:\\Users\\hato2\\Desktop\\zenn-content\\rasterization-example> cargo clippy\r\n   Compiling rasterization-example v0.1.0 (C:\\Users\\hato2\\Desktop\\zenn-content\\rasterization-example)\r\nerror: failed to run custom build command for `rasterization-example v0.1.0 (C:\\Users\\hato2\\Desktop\\zenn-content\\rasterization-example)`\r\n\r\nCaused by:\r\n  process didn't exit successfully: `C:\\Users\\hato2\\Desktop\\zenn-content\\rasterization-example\\target\\debug\\build\\rasterization-example-bf4f4e1cfd480af7\\build-script-build` (exit code: 1)\r\n  --- stderr\r\n     Compiling core v0.0.0 (C:\\Users\\hato2\\.rustup\\toolchains\\nightly-2022-04-11-x86_64-pc-windows-msvc\\lib\\rustlib\\src\\rust\\library\\core)\r\n     Compiling rustc-std-workspace-core v1.99.0 (C:\\Users\\hato2\\.rustup\\toolchains\\nightly-2022-04-11-x86_64-pc-windows-msvc\\lib\\rustlib\\src\\rust\\library\\rustc-std-workspace-core)\r\n     Compiling compiler_builtins v0.1.70\r\n     Compiling libm v0.2.1\r\n     Compiling bitflags v1.3.2\r\n     Compiling spirv-types v0.4.0-alpha.12 (https://github.com/EmbarkStudios/rust-gpu.git#11e21c64)\r\n     Compiling num-traits v0.2.14\r\n     Compiling glam v0.20.2\r\n     Compiling spirv-std v0.4.0-alpha.12 (https://github.com/EmbarkStudios/rust-gpu.git#11e21c64)\r\n     Compiling shader v0.1.0 (C:\\Users\\hato2\\Desktop\\zenn-content\\rasterization-example\\shader)\r\n  thread 'rustc' panicked at 'not yet implemented', C:\\Users\\hato2\\.cargo\\git\\checkouts\\rust-gpu-e0a37a82a46176e6\\116bf9c\\crates\\rustc_codegen_spirv\\src\\codegen_cx\\mod.rs:564:9\r\n  note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\r\n  error: internal compiler error: unexpected panic\r\n\r\n  note: the compiler unexpectedly panicked. this is a bug.\r\n\r\n  note: we would appreciate a bug report: https://github.com/EmbarkStudios/rust-gpu/issues/new\r\n\r\n  note: rustc 1.62.0-nightly (1f7fb6413 2022-04-10) running on x86_64-pc-windows-msvc\r\n\r\n  note: compiler flags: --crate-type lib --crate-type dylib -C opt-level=3 -C embed-bitcode=no -Z unstable-options -Z codegen-backend=C:\\Users\\hato2\\Desktop\\zenn-content\\rasterization-example\\target\\debug\\rustc_codegen_spirv.dll -C symbol-mangling-version=v0\r\n\r\n  note: some of the compiler flags provided by cargo are hidden\r\n\r\n  query stack during panic:\r\n  end of query stack\r\n  note: `rust-gpu` version 0.4.0-alpha.12\r\n\r\n  error: could not compile `shader`\r\n  Error: BuildFailed\r\n```\r\n\r\n\r\n## System Info\r\n<!--\r\nHelpful commands:\r\n- Rustc version: `rustc -V`\r\n- SPIR-V version: `spirv-val --version`\r\n-->\r\n\r\n - Rust: rustc 1.62.0-nightly (1f7fb6413 2022-04-10)\r\n - OS: Windows 11\r\n - GPU: RTX 2080ti\r\n - SPIR-V: SPIRV-Tools v2022.2-dev v2022.1-4-g20b122b2\r\n\r\n\r\n## Backtrace\r\n<!-- If relevant, please include a backtrace of the error below. -->\r\n\r\n<details><summary>Backtrace</summary>\r\n<p>\r\n\r\n```\r\n<backtrace>\r\n```\r\n\r\n</p>\r\n</details>\r\n",
    "comments": [
      {
        "id": "IC_kwDOENG4485BnaGT",
        "author": {
          "login": "repi"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "Looks like that rust-gpu panic was on this:\r\n\r\n```rust\r\n    fn eh_personality(&self) -> Self::Value {\r\n        todo!()\r\n    }\r\n```\r\n\r\nWhich for this type of no-std builds one has to implement oneself ([docs](https://docs.rust-embedded.org/embedonomicon/smallest-no-std.html#eh_personality)). \r\n\r\nWe do this in `spirv-std` but looks like your dependency is not including that so in that case you'll have to do some of that set up manually. https://github.com/EmbarkStudios/rust-gpu/blob/132b960e8320d7e607fd912142cff7da05d49d92/crates/spirv-std/src/lib.rs#L128-L129\r\n\r\nWe should improve the rust-gpu todo panic though to be clear about this rather than crashing",
        "createdAt": "2022-04-17T10:35:27Z",
        "includesCreatedEdit": true,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/864#issuecomment-1100849555",
        "viewerDidAuthor": false
      },
      {
        "id": "IC_kwDOENG4485BuD5D",
        "author": {
          "login": "eddyb"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "<del>We can probably return a zombie (or even a non-function instead of panicking, since we don't actually do any kind of exception handling, so `rust_eh_personality` shouldn't actually be necessary.</del>\r\n\r\nWait, no, any use of `.eh_personality()`'s result is itself a `todo!()`, and I'm not sure we even need `#[lang = \"eh_personality\"]` ourselves...\r\n\r\nWe force `-C panic=abort` in the target spec: https://github.com/EmbarkStudios/rust-gpu/blob/132b960e8320d7e607fd912142cff7da05d49d92/crates/rustc_codegen_spirv/src/target.rs#L93\r\n\r\nThe relevance of `cargo clippy` is also suspect, since it's invoking a build script that *should* be using `spirv-builder` (and seems to, by all accounts), maybe it's caused by Clippy inserting itself as a `rustc` proxy?\r\n\r\n<hr/>\r\n\r\nA quick look around found that clippy indeed [turns off MIR optimizations](https://github.com/rust-lang/rust-clippy/blob/cbdf17c884116f17b1efe8c6dd3c41eb45d1342c/src/driver.rs#L115-L119) (which are likely needed for `panic=abort` to remove unwinding logic from MIR).\r\n\r\nThe [decision logic](https://github.com/rust-lang/rust-clippy/blob/cbdf17c884116f17b1efe8c6dd3c41eb45d1342c/src/driver.rs#L332-L349) for whether or not to run in \"clippy mode\" doesn't seem to consider build scripts?\r\n\r\nWe may need to unset the `RUSTC_WRAPPER` env var in `spirv-builder` to avoid clippy interference.\r\n\r\nThough ideally clippy should check for `--emit=rmeta` to tell whether the `cargo check` invocation (started by `cargo clippy`) is actually doing a \"check\" build, or something else is going on (like a nested build script build).\r\n\r\n<hr/>\r\n\r\nWe can probably start by adding this assert to `rustc_codegen_spirv`:\r\n```rust\r\nassert_ne!(\r\n    sess.opts.debugging_opts.mir_opt_level, Some(0),\r\n    \"`-Z mir-opt-level=0` not supported \\\r\n     (if using `cargo clippy`, it may have added the flag automatically)\"\r\n);\r\n```",
        "createdAt": "2022-04-19T12:38:26Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/864#issuecomment-1102593603",
        "viewerDidAuthor": false
      },
      {
        "id": "IC_kwDOENG4485BuFc8",
        "author": {
          "login": "eddyb"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "Was able to reproduce in-tree like this:\r\n```\r\nrustup target add wasm32-unknown-unknown\r\ncargo clippy -p example-runner-wgpu --target=wasm32-unknown-unknown\r\n```\r\nThe reason it doesn't repro for the host target is the hotloading support.\r\n\r\nAlternatively, commenting out these lines should also repro:\r\nhttps://github.com/EmbarkStudios/rust-gpu/blob/685c79a9725f9fb68ce17dd00e742b98a03f3870/examples/runners/wgpu/build.rs#L15-L17",
        "createdAt": "2022-04-19T12:45:34Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/864#issuecomment-1102599996",
        "viewerDidAuthor": false
      },
      {
        "id": "IC_kwDOENG4485YuSjb",
        "author": {
          "login": "oisyn"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "Can't really repro on `0.6.1` with above instructions. This needs further investigation whether this is indeed fixed now, and why.",
        "createdAt": "2023-03-29T12:40:48Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "users": {
              "totalCount": 1
            }
          }
        ],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/864#issuecomment-1488529627",
        "viewerDidAuthor": false
      },
      {
        "id": "IC_kwDOENG4485Yu-PM",
        "author": {
          "login": "eddyb"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "Adding the assert from https://github.com/EmbarkStudios/rust-gpu/issues/864#issuecomment-1102593603 does get tripped with the repro instructions (the ones about commenting out the android/wasm check), but I don't understand why that doesn't break anything.\r\n\r\nProbably requires going back to see which nightly made `-C panic=abort` not require MIR optimizations.\r\n\r\nWhat clippy is doing here is still sketchy (AFAICT the relevant parts of its code haven't changed since I investigated a year ago above), but it sounds like it maybe no longer breaks Rust-GPU?",
        "createdAt": "2023-03-29T14:14:41Z",
        "includesCreatedEdit": true,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/864#issuecomment-1488708556",
        "viewerDidAuthor": false
      }
    ],
    "createdAt": "2022-04-16T15:06:01Z",
    "labels": [
      {
        "id": "MDU6TGFiZWwyMjI3MzM4ODEz",
        "name": "t: bug",
        "description": "Something isn't working",
        "color": "52E8A0"
      }
    ],
    "number": 864,
    "reactionGroups": [],
    "state": "OPEN",
    "title": "`cargo clippy` breaks the nested `cargo build` from `spirv-builder`.",
    "url": "https://github.com/EmbarkStudios/rust-gpu/issues/864"
  },
  {
    "author": {
      "id": "MDQ6VXNlcjEyNjI2OTI=",
      "is_bot": false,
      "login": "repi",
      "name": "Johan Andersson"
    },
    "body": "We should look into improve our clean build times of when building `spriv-builder` & `rustc_codegen_spirv` as that is the main scenario in CI and also useful for users if our crates rebuild fast.\r\n\r\nRight now it looks like we have a couple of quite unfortunate serial dependencies that significantly increases the wall time. Here is the current results with `cargo build --release -p spirv-builder -Z timings` on my AMD 5950x (32 vCPU):\r\n\r\n![image](https://user-images.githubusercontent.com/1262692/162613624-66cd6fec-6455-4569-976d-33ca9f3ee80c.png)\r\n\r\n## Potential optimizations\r\n\r\n- [ ] Could `spirv-builder` be the one depending on `spirv-tools` instead of `rustc_codegen_spirv`?\r\n    - I.e. move the responsibility of running spirv-opt/spirv-val and final linking to the builder. \r\n    - Does that sound like it could be doable @eddyb ?\r\n- [ ] Remove/replace `serde`, quite crazy it takes 20 seconds to compile\r\n    - Think we only have two use cases, our `ModuleResult` output and then the internal decorations that is using more complex serde implementation (`CustomDecoration`).\r\n    - have no idea how `serde`+`serde_json` is taking such a crazy long time to build here though, can't see any other crates enabling tons of types that serde derive macros are used on or similar\r\n    - `ModuleResult` would be trivial to replace serde with `nanoserde`, could work for `CustomDecoration` also?\r\n    - #860\r\n- [ ] Remove/replace `sanitize-filename` dependency that compiles and uses `regex` crate for super trivial things\r\n- [ ] Optimize builds of `rspirv` itself somehow? \r\n    - Unfortunate that it is so slow to build by itself but could be hard to fix and tons of types in it. No open issues on it in the `rspirv` repo as far as I could see \r\n- [x] ~Determine why `rustc_codegen_spirv` is not split in frontend/codegen sections in the profile~ report.\r\n    - This would enable `spriv-builder` itself to start building earlier and before the codegen of `rustc_codegen_spirv` is done.\r\n    - Update: This is not possible as it it needs to be built as a `dylib`\r\n\r\n---\r\n\r\nIf we do get rid of serde and manage to make sure `rustc_codegen_spirv` doesn't have to wait for the `spirv-tools-sys` build, we could get get a 15+ second wall time improvement here as `rustc_codegen_spirv` could start as soon as frontend section of `rspirv` has been built:\r\n      -  ![image](https://user-images.githubusercontent.com/1262692/162613819-e0b53cb2-3cec-4b42-8241-98f00ee40486.png)\r\n",
    "comments": [
      {
        "id": "IC_kwDOENG4485BOPvs",
        "author": {
          "login": "repi"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "Did an experiment to switch to `nanoserde` and it seems to work fine, there are some contraints and type/format output changes that one have to figure out (no `PathBuf` support), and does get rid of all the long serde compilation, 20 sec -> 1.7 sec.\r\n\r\nWall time benefit was just ~1 second though, but would enable real gains if one also finds a way not have `rustc_codegen_spirv` stall and wait for `spirv-tools-sys` build.\r\n\r\n![image](https://user-images.githubusercontent.com/1262692/162616546-87b6103e-4718-43d6-a507-9fa80602e419.png)\r\n",
        "createdAt": "2022-04-10T11:47:02Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/858#issuecomment-1094253548",
        "viewerDidAuthor": false
      },
      {
        "id": "IC_kwDOENG4485BORRT",
        "author": {
          "login": "repi"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "> Determine why rustc_codegen_spirv is not split in frontend/codegen sections in the profile report. This would enable spriv-builder itself to start building earlier and before the codegen of rustc_codegen_spirv is done.\r\n\r\nFound the source of this, `rustc_codegen_spirv` was set as a `dylib` crate instead of standard `lib`.\r\n\r\nFixing this, together with the above experimental `nanoserde` switch does reduce build time from original 46.3s to 41.9s, one can see in the report that `rustc_codegen_spirv` is now split in frontend and codegen sections which enables `spirv-builder` to build earlier.\r\n\r\n![image](https://user-images.githubusercontent.com/1262692/162617635-2b66493e-0aa7-46bd-989e-b6bd1a021b3b.png)\r\n",
        "createdAt": "2022-04-10T12:16:51Z",
        "includesCreatedEdit": false,
        "isMinimized": true,
        "minimizedReason": "OUTDATED",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/858#issuecomment-1094259795",
        "viewerDidAuthor": false
      },
      {
        "id": "IC_kwDOENG4485IAzP1",
        "author": {
          "login": "bjorn3"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "You could split rustc_codegen_spirv into an rlib containing the actual implementation and a dylib which only depends on the rlib. The rlib will participate in pipelined compilation and the dylib will wait for all dependencies to have fully compiled before doing the final link. It may also be possible to move just the code using spirv-tools to the dylib, allowing most of the code of cg_spirv to be compiled at the same time as spirv-tools-sys.",
        "createdAt": "2022-08-08T14:00:13Z",
        "includesCreatedEdit": true,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/858#issuecomment-1208169461",
        "viewerDidAuthor": false
      },
      {
        "id": "IC_kwDOENG4485ICV6I",
        "author": {
          "login": "repi"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "ah that is an interesting idea and approach, what do you think of the feasibility of that @eddyb ?",
        "createdAt": "2022-08-08T20:23:43Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/858#issuecomment-1208573576",
        "viewerDidAuthor": false
      },
      {
        "id": "IC_kwDOENG4485IC6VU",
        "author": {
          "login": "eddyb"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "Ahh I always forget about how dylibs behave just like executables, and the current state of pipelining - it makes sense in the grand scheme of there being no good way (yet) to block `rustc` invoking the linker, on the linker inputs actually being present, but it's basically a Cargo<->`rustc` communicative deficiency AFAIK, not even something limited by platform tooling.\r\n\r\nWhat @bjorn3 is suggesting is basically \"emulate what *should* happen, with today's tools\" and we should probably do that.\r\n\r\nIf @oisyn wants to tackle this, a first approximation could be as simple as:\r\n* rename `crates/rustc_codegen_spirv` (e.g. add a suffix like `-impl`), and the name in its `Cargo.toml`, and take away any `dylib`-specific settings\r\n* create a minimal `crates/rustc_codegen_spirv`\r\n  * `Cargo.toml` pretty much identical to what's currently there today (modulo deps?) and with an extra dependency on the new (e.g. `rustc_codegen_spirv-impl`) crate\r\n  * `src/lib.rs` containing only `extern crate rustc_codegen_spirv_impl;` - in theory that *should* be enough to allow any exported symbols from the `-impl` crate to surface up to to the dylib and allow it to function\r\n\r\nFor @bjorn3's complete suggestion, I'm guessing this needs to go in the dylib: https://github.com/EmbarkStudios/rust-gpu/blob/105cbcc6184ac78fcb954a525895d49f39733159/crates/rustc_codegen_spirv/src/lib.rs#L515-L561\r\n\r\nWith that `Box::new(SpirvCodegenBackend)` at the very end being changed to `Box::new(SpirvCodegenBackend { spirv_tools: ... })` (i.e. `rustc_codegen_spirv-impl`'s definition of `SpirvCodegenBackend` needs a new field that holds some kind of trait object, function pointers, etc. - some mechanism to dynamically get access to the functionality we need from `spirv_tools` *without* it being statically accessed from `rustc_codegen_spirv-impl`).",
        "createdAt": "2022-08-08T23:29:41Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/858#issuecomment-1208722772",
        "viewerDidAuthor": false
      }
    ],
    "createdAt": "2022-04-10T11:01:16Z",
    "labels": [],
    "number": 858,
    "reactionGroups": [],
    "state": "OPEN",
    "title": "Optimize `spirv-builder` clean build wall time",
    "url": "https://github.com/EmbarkStudios/rust-gpu/issues/858"
  },
  {
    "author": {
      "id": "MDQ6VXNlcjE2Njc3NDY=",
      "is_bot": false,
      "login": "hatoo",
      "name": ""
    },
    "body": "<!-- Thank you for filing a bug report! üêõ -->\r\nThis issue is from Discord conversation https://discordapp.com/channels/750717012564770887/750717499737243679/943879544006381638\r\n\r\n### Expected Behaviour\r\n<!-- Please describe what you expected to happen. -->\r\nI want to compile [my shader](https://github.com/hatoo/rene) faster.\r\n\r\n### Example & Steps To Reproduce\r\n<!-- \r\nDescribe what actually happened, including any relevant examples (smaller\r\nthe better), error messages, or the relevant SPIR-V binary. \r\n-->\r\n\r\n1. clone my repo https://github.com/hatoo/rene\r\n2. `cargo build --release -Z timings`\r\n3. See compile duration\r\n\r\nI tested on [af3cf2b74e8ef4f4bd98a3cd2cda64b9379d20d7](https://github.com/hatoo/rene/commit/af3cf2b74e8ef4f4bd98a3cd2cda64b9379d20d7).\r\n\r\n```\r\nCompleted rene v0.1.0 build script (run) in 263.2s\r\n```\r\n\r\nIn console in VSCode and rust-analyzer plugin. It takes more time.\r\n\r\n```\r\nCompleted rene v0.1.0 build script (run) in 407.3s\r\n```\r\n\r\n## System Info\r\n<!--\r\nHelpful commands:\r\n- Rustc version: `rustc -V`\r\n- SPIR-V version: `spirv-val --version`\r\n-->\r\n\r\n - Rust: rustc 1.60.0-nightly (1bd4fdc94 2022-01-12)\r\n - OS: Windows 11\r\n - CPU: 3950X\r\n - GPU: RTX2080ti\r\n - SPIR-V: SPIRV-Tools v2021.4-dev v2021.3-86-g21e3f681\r\n",
    "comments": [
      {
        "id": "IC_kwDOENG4484-VwMV",
        "author": {
          "login": "hatoo"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "After I added codes to my shader, it takes very longer time to compile.\r\nIn [this commit](https://github.com/hatoo/rene/tree/bfcccbb661d97c80cb9783b847f4c802277fa769), it takes about 1000s.\r\n```\r\nCompleted rene v0.1.0 build script (run) in 1009.6s\r\n```\r\n\r\nAnd I added one commit to this in [this branch](https://github.com/hatoo/rene/tree/mix).\r\nI've waited for few hours and the build didn't end.",
        "createdAt": "2022-02-19T06:40:44Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/851#issuecomment-1045889813",
        "viewerDidAuthor": false
      },
      {
        "id": "IC_kwDOENG4484-W36f",
        "author": {
          "login": "hatoo"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "I enabled `-Zself-profile` and build it and I found `rustc` is spending almost all time to link (`link_block_ordering_pass_and_mem2reg`).\r\n\r\n## Procedure\r\n\r\n1. Enable `-Zself-profile` on spirv-builder. It can be done by like https://github.com/hatoo/rust-gpu/commit/e34bda56b12cc86533e92ae57a754f6ae896e0b1\r\n2. Change `rene`'s `spirv-builder` dependency to use it.\r\n3. `cargo install --git https://github.com/rust-lang/measureme crox flamegraph summarize`\r\n4. `cargo build --release` on `rene`\r\n5. `crox .\\rene_shader-xxxx.mm_profdata` and `chrome_profiler.json` will be produced.\r\n6. Open Chrome Developper tool and click the Performance tab. And upload `chrome_profiler.json` by clicking ‚¨ÜÔ∏è button.\r\n\r\n![image](https://user-images.githubusercontent.com/1667746/154833809-92f5a06b-b3dc-46bc-9ea2-d04fe5858bce.png)\r\n",
        "createdAt": "2022-02-20T08:00:00Z",
        "includesCreatedEdit": true,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/851#issuecomment-1046183583",
        "viewerDidAuthor": false
      },
      {
        "id": "IC_kwDOENG4485g-KHd",
        "author": {
          "login": "eddyb"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "I've been working on a `mem2reg` replacement recently, relying on SPIR-T `qptr`s (based on https://github.com/EmbarkStudios/spirt/pull/29 / https://github.com/EmbarkStudios/spirt/pull/41 - no PR yet for the `mem2reg` replacement though, but I really hope I can get it into Rust-GPU 0.9, behind the `qptr` opt-in).\r\n```console\r\n$ rg mem2reg 2023-07-08-spirt-disagg-baseline \r\n512:time:   0.011; rss:  187MB ->  187MB (   +0MB)      link_block_ordering_pass_and_mem2reg-before-inlining\r\n515:time: 126.704; rss:  189MB ->  158MB (  -31MB)      link_block_ordering_pass_and_mem2reg-after-inlining\r\n$ rg qptr::partition_and_propagate 2023-07-08-spirt-disagg-qptr-pnp \r\n538:time:   0.570; rss:  220MB ->  221MB (   +1MB)      qptr::partition_and_propagate\r\n```\r\nso that's **a 222x speed-up** (for the same version of `rene-shader` I used to demo the initial impact from SPIR-T, over a year ago)\r\n\r\n(`RUSTGPU_CODEGEN_ARGS=\"--spirt-passes=qptr --no-infer-storage-classes --no-legacy-mem2reg\"` is the opt-in, at least on my local branch, ~~I'm hoping we can at least simplify it to `RUSTGPU_CODEGEN_ARGS=--qptr` for `0.9`~~)\r\n\r\n**EDIT**: to be perfectly clear: those flags are not useful without the necessary combination of SPIR-T + Rust-GPU changes and I don't even have an up-to-date Rust-GPU branch anywhere comparable to that one.",
        "createdAt": "2023-07-08T08:15:01Z",
        "includesCreatedEdit": true,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [
          {
            "content": "HOORAY",
            "users": {
              "totalCount": 2
            }
          }
        ],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/851#issuecomment-1626907101",
        "viewerDidAuthor": false
      }
    ],
    "createdAt": "2022-02-17T21:44:07Z",
    "labels": [
      {
        "id": "MDU6TGFiZWwyMjI3MzM4ODEz",
        "name": "t: bug",
        "description": "Something isn't working",
        "color": "52E8A0"
      }
    ],
    "number": 851,
    "reactionGroups": [
      {
        "content": "THUMBS_UP",
        "users": {
          "totalCount": 1
        }
      }
    ],
    "state": "OPEN",
    "title": "`rustc_codegen_spirv` taking a long time processing my (large) shader",
    "url": "https://github.com/EmbarkStudios/rust-gpu/issues/851"
  },
  {
    "author": {
      "id": "MDQ6VXNlcjYyODMwNDE3",
      "is_bot": false,
      "login": "Icelk",
      "name": "Icelk"
    },
    "body": "<!-- Thank you for filing a bug report! üêõ -->\r\n\r\n### Expected Behaviour\r\n<!-- Please describe what you expected to happen. -->\r\n\r\nReassigning to a variable should work, just as it does with f32s.\r\n\r\n### Example & Steps To Reproduce\r\n<!-- \r\nDescribe what actually happened, including any relevant examples (smaller\r\nthe better), error messages, or the relevant SPIR-V binary. \r\n-->\r\n\r\nRun the compute example (just used as it's already set up).\r\nThen, add the following lines to the shader code:\r\n\r\n```rust\r\nlet mut test: f64 = 1.0;\r\ntest = 2.0;\r\n```\r\n\r\nYou have to remove the `#[deny(warnings)]` at the top.\r\n\r\nThe shader will fail to compile. This also applies to when the value is read.\r\n\r\n\r\n## System Info\r\n<!--\r\nHelpful commands:\r\n- Rustc version: `rustc -V`\r\n- SPIR-V version: `spirv-val --version`\r\n-->\r\n\r\n - Rust: nightly-2022-01-13\r\n - OS: Arch Linux\r\n - GPU: Nvidia 1060\r\n - SPIR-V: no clue, but using latest commit from this repo to build\r\n\r\n## Compiler error\r\n\r\n<details>\r\n\r\n```rust\r\nerror: f64 without OpCapability Float64\r\n   --> /home/icelk/.rustup/toolchains/nightly-2022-01-13-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/num/f64.rs:451:5\r\n    |\r\n451 |     pub(crate) const fn abs_private(self) -> f64 {\r\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n    |\r\n    = note: Stack:\r\n            main_cs\r\n\r\nerror: No OpEntryPoint instruction was found. This is only allowed if the Linkage capability is being used.\r\n  |\r\n  = note: module `/home/icelk/dev/Rust/fractal-renderer/target/spirv-unknown-vulkan1.1/release/deps/compute_shader.spv.dir/module`\r\n\r\nwarning: an unknown error occurred\r\n  |\r\n  = note: spirv-opt failed, leaving as unoptimized\r\n  = note: module `/home/icelk/dev/Rust/fractal-renderer/target/spirv-unknown-vulkan1.1/release/deps/compute_shader.spv.dir/module`\r\n\r\nerror: error:0:0 - No OpEntryPoint instruction was found. This is only allowed if the Linkage capability is being used.\r\n  |\r\n  = note: spirv-val failed\r\n  = note: module `/home/icelk/dev/Rust/fractal-renderer/target/spirv-unknown-vulkan1.1/release/deps/compute_shader.spv.dir/module`\r\n\r\nwarning: `compute-shader` (lib) generated 1 warning\r\nerror: could not compile `compute-shader` due to 3 previous errors; 1 warning emitted\r\n```\r\n\r\n</details>\r\n",
    "comments": [
      {
        "id": "IC_kwDOENG4485GCiKI",
        "author": {
          "login": "repi"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "thanks for reporting! \r\n\r\ntalked to @oisyn which will try and repo and see can get this, sounded like the float64 capability was not enabled",
        "createdAt": "2022-07-05T13:35:50Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "users": {
              "totalCount": 2
            }
          }
        ],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/850#issuecomment-1175069320",
        "viewerDidAuthor": false
      }
    ],
    "createdAt": "2022-02-10T20:34:17Z",
    "labels": [
      {
        "id": "MDU6TGFiZWwyMjI3MzM4ODEz",
        "name": "t: bug",
        "description": "Something isn't working",
        "color": "52E8A0"
      },
      {
        "id": "LA_kwDOENG4488AAAABHkF3zA",
        "name": "s: needs update",
        "description": "This issue needs a follow up or investigation whether it still applies.",
        "color": "CCCCCC"
      }
    ],
    "number": 850,
    "reactionGroups": [],
    "state": "OPEN",
    "title": "Reassigning to f64s doesn't work",
    "url": "https://github.com/EmbarkStudios/rust-gpu/issues/850"
  },
  {
    "author": {
      "id": "MDQ6VXNlcjc3NDI0",
      "is_bot": false,
      "login": "eddyb",
      "name": "Eduard-Mihai Burtescu"
    },
    "body": "The [description from the spec](https://www.khronos.org/registry/SPIR-V/specs/unified1/SPIRV.html#_memory_operands) of `NonPrivatePointer` is:\r\n> **NonPrivatePointer**\r\n> The memory access obeys inter-thread ordering, as specified by the client API.\r\n>\r\n> Missing before version 1.5.\r\n\r\nMy understanding is that with `NonPrivatePointer`, unsynchronized accesses can be used to access the same memory from different threads, as long as there is a barrier (or an equivalent atomic access) separating them - AFAICT, this matches Rust's concurrency semantics (likely rooted in the C++11 memory model, but I'm far from an expert).\r\n\r\nTo give a practical example, this is what allows `Mutex<SomeData>` to work, as well as passing `Box<SomeData>` between threads (or even `&mut SomeData`, with scoped threads - `rayon` relies on this a lot) - all accesses to `SomeData` will be unsynchronized, but they can't race between threads because of the synchronization used to get access to the pointer in the first place.\r\n\r\nWithout `NonPrivatePointer`, however, opting into the Vulkan memory model isn't enough to make anything other than atomic accesses thread-safe. Even something as potentially-common as reading data written per-invocation, from a single chosen invocation (i.e. the \"join\" step in a \"fork-join\" model), would be UB unless the per-invocation writes *and* the single-chosen-invocation read, are all atomic (and the data would only be considered available *after* the shader completes, to the Vulkan host, i.e. the CPU).\r\n\r\nOverall it seems like a strange historical accident, but the default in SPIR-V doesn't seem compatible with Rust semantics.\r\n\r\nThe safest thing would probably be to always add `NonPrivatePointer`, and remove it only for `Function` and `Private` accesses (and maybe anything that's read-only memory?) in a pass - that way, it's conservative if that pass misses anything, instead of the opposite.\r\n\r\nThere's probably also a similar issue involving `NonPrivateTexel` and writable images, but I haven't looked closer.",
    "comments": [],
    "createdAt": "2022-01-09T14:30:48Z",
    "labels": [
      {
        "id": "MDU6TGFiZWwyMjI3MzM4ODEz",
        "name": "t: bug",
        "description": "Something isn't working",
        "color": "52E8A0"
      },
      {
        "id": "LA_kwDOENG4488AAAABPXHqow",
        "name": "s: qptr may fix",
        "description": "This might be fixed by the \"qptr\" experiment (https://github.com/EmbarkStudios/spirt/pull/24)",
        "color": "CCCCCC"
      }
    ],
    "number": 838,
    "reactionGroups": [],
    "state": "OPEN",
    "title": "Unsynchronized memory accesses outside of `Function`/`Private` need to use `NonPrivatePointer`.",
    "url": "https://github.com/EmbarkStudios/rust-gpu/issues/838"
  },
  {
    "author": {
      "id": "MDQ6VXNlcjg4NzcxMQ==",
      "is_bot": false,
      "login": "fu5ha",
      "name": "Gray Olson"
    },
    "body": "Currently, if we create an image type with the image macro as such:\r\n\r\n```rust\r\nImage!(2D, type=f32, sampled=false),\r\n```\r\n\r\nthe image will still be able to be `.read`/`.fetch`ed, and the spirv Image object won't be decorated as `NonReadable`. However, according to vulkan spec, \"If shaderStorageImageReadWithoutFormat is not enabled, any variable created with a \"Type\" of OpTypeImage that has a \"Sampled\" operand of 2 and an \"Image Format\" operand of Unknown must be decorated with NonReadable.\"\r\n\r\nThis can be solved for now by just using an explicit `format=blah` in the `Image` macro instead of `type`, but I think we could also handle this/validate it in the macro automatically. I think the best way forward would be:\r\n\r\n* Make a `readable` flag in the macro which gets auto-disabled under the above conditions, and when disabled, decorates the `OpTypeImage` with `NonReadable` and doesn't allow to do `.read`/`.fetch` on the Image.\r\n* However, if it is manually enabled, then we do the current behavior, allowing `read` etc. (assuming `shaderStorageImageReadWithoutFormat` is enabled).",
    "comments": [
      {
        "id": "IC_kwDOENG44846iVYK",
        "author": {
          "login": "khyperia"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "Just for some context here, I've looked into adding `NonReadable` before and there's some issues with the spec that I would like clarified before implementing anything - I don't want to make guesses on what the \"intended\" behavior is.\r\n\r\nFeel free to ping me if anyone would like to look into those issues and drive that discussion with khronos - for example, one issue is that it's unspecified behavior when an object decorated with `NonReadable` is passed to a function whose argument is _not_ decorated with `NonReadable` (as the decoration is on values, not types)",
        "createdAt": "2021-11-29T22:23:45Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [
          {
            "content": "HEART",
            "users": {
              "totalCount": 2
            }
          }
        ],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/812#issuecomment-982078986",
        "viewerDidAuthor": false
      },
      {
        "id": "IC_kwDOENG44846kw3S",
        "author": {
          "login": "khyperia"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "Just did some investigation (made annoying by the fact that [my little wgpu test loader](https://github.com/khyperia/spirv-loader) doesn't seem to trigger the validation error), and it seems like while `spirv-val` is silent about everything related to this issue, vulkan validation layers behaves like so. I have a helper function that takes a storage image pointer and OpImageWrites some dummy value inside the function.\r\n\r\n- Image OpVariable not marked with NonReadable: error (as this issue reports)\r\n- Image OpVariable marked with NonReadable: no error, as expected\r\n- Image OpVariable not marked with NonReadable, calling function whose parameter is not marked with NonReadable: error (as expected)\r\n- Image OpVariable marked with NonReadable, calling function whose parameter is marked with NonReadable: totally fine, as expected\r\n- Image OpVariable marked with NonReadable, calling function whose parameter is not marked with NonReadable: totally fine, according to validation layers!\r\n- Image OpVariable not marked with NonReadable, calling function whose parameter is marked with NonReadable: error around \"thing needs NonReadable pls\", but totally fine with the presumably-sketchy call.\r\n\r\nSo, it looks like validation layers only cares about the global OpVariable being decorated with NonReadable, and is totes fine with garbage annotations on functions where that global OpVariable is passed into. I am guessing this is a quirk of validation layers, and not intended behavior (especially considering this error was implemented in validation layers extremely recently).\r\n\r\nAs an aside, using `glslang`, with variants on this shader, this is the result:\r\n```glsl\r\n#version 460\r\nlayout (binding = 0) uniform writeonly image2D tex;\r\nvoid f(writeonly image2D t) { imageStore(t, ivec2(0, 0), vec4(0)); }\r\nvoid main() { f(tex); }\r\n```\r\n- both writeonly: fine\r\n- neither writeonly: error, \"must be declared writeonly, or have a format\"\r\n- global writeonly, function without: error, \"argument cannot drop memory qualifier when passed to formal parameter\"\r\n- global without, function writeonly: error, \"must be declared writeonly, or have a format\"\r\n\r\nMeanwhile, this program compiles\r\n```glsl\r\n#version 460\r\nlayout (binding = 0, rgba32f) uniform image2D tex;\r\nvoid f(writeonly image2D t) { imageStore(t, ivec2(0, 0), vec4(0)); }\r\nvoid main() { f(tex); }\r\n```\r\nwhile this one does not (\"image format arguments must match\" - which uh, what? how does the above compile but this doesn't? some context, you [can't specify image formats on function parameters](https://github.com/KhronosGroup/GLSL/issues/57))\r\n```glsl\r\n#version 460\r\nlayout (binding = 0, rgba32f) uniform image2D tex;\r\nvoid f(image2D t) { imageStore(t, ivec2(0, 0), vec4(0)); }\r\nvoid main() { f(tex); }\r\n```\r\n\r\nSo, assuming the (not without precedent) that SPIR-V intended to copy GLSL here, that means:\r\n- There should be a SPIR-V rule saying you cannot call a function with a variable marked as NonReadable to a function whose parameter is not marked as NonReadable\r\n- There should be a SPIR-V rule saying that you _can_ call a function with a variable with no decoration to a function whose parameter is marked as NonReadable\r\n- There should be a SPIR-V rule saying you can call a function whose parameter has image format=unknown with an image whose format _is_ known (haven't dug through the spec too much to check if this is already present). Maybe the other way around, too, but AFAIK that's not a constructable situation in GLSL.\r\n\r\nI assume a similar investigation should happen for NonWritable.",
        "createdAt": "2021-11-30T14:58:52Z",
        "includesCreatedEdit": true,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "users": {
              "totalCount": 3
            }
          }
        ],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/812#issuecomment-982715858",
        "viewerDidAuthor": false
      }
    ],
    "createdAt": "2021-11-29T20:17:40Z",
    "labels": [
      {
        "id": "MDU6TGFiZWwyMjI3MzM4ODEz",
        "name": "t: bug",
        "description": "Something isn't working",
        "color": "52E8A0"
      },
      {
        "id": "MDU6TGFiZWwyNDM3NjkwNTU0",
        "name": "s: blocked",
        "description": "PRs blocked on external factors.",
        "color": "CCCCCC"
      }
    ],
    "number": 812,
    "reactionGroups": [],
    "state": "OPEN",
    "title": "Image macro doesn't fully enforce valid use of non-sampled storage images",
    "url": "https://github.com/EmbarkStudios/rust-gpu/issues/812"
  },
  {
    "author": {
      "id": "MDQ6VXNlcjE2Njc3NDY=",
      "is_bot": false,
      "login": "hatoo",
      "name": ""
    },
    "body": "<!-- Thank you for filing a bug report! üêõ -->\r\n\r\n### Expected Behaviour\r\n\r\nCodes that uses `core::mem::swap`\r\n\r\n```rust\r\n#![cfg_attr(\r\n    target_arch = \"spirv\",\r\n    no_std,\r\n    feature(register_attr),\r\n    register_attr(spirv)\r\n)]\r\n\r\n#[cfg(not(target_arch = \"spirv\"))]\r\nuse spirv_std::macros::spirv;\r\n\r\nuse spirv_std as _;\r\n\r\n#[spirv(vertex)]\r\npub fn test_vs() {\r\n    let mut x1 = 0.0f32;\r\n    let mut x2 = 1.0f32;\r\n\r\n    core::mem::swap(&mut x1, &mut x2);\r\n}\r\n```\r\n\r\nwill compile. it's OK in previous version at least b9867d0e84d29d6e60ad62427f453b4829abda56.\r\n\r\n### Example & Steps To Reproduce\r\n<!-- \r\nDescribe what actually happened, including any relevant examples (smaller\r\nthe better), error messages, or the relevant SPIR-V binary. \r\n-->\r\n\r\n1. Clone https://github.com/hatoo/rust-gpu-issue/tree/swap-fail (note: swap-fail branch)\r\n2. cargo build and error\r\n\r\n```\r\n> cargo build\r\n   Compiling builder v0.1.0 (C:\\Users\\hato2\\Desktop\\rust-gpu-issue\\builder)\r\nerror: failed to run custom build command for `builder v0.1.0 (C:\\Users\\hato2\\Desktop\\rust-gpu-issue\\builder)`\r\n\r\nCaused by:\r\n  process didn't exit successfully: `C:\\Users\\hato2\\Desktop\\rust-gpu-issue\\target\\debug\\build\\builder-caf084bc583adeed\\build-script-build` (exit code: 1)\r\n  --- stderr\r\n     Compiling shader v0.1.0 (C:\\Users\\hato2\\Desktop\\rust-gpu-issue\\shader)\r\n  error: Cannot memcpy dynamically sized data\r\n      --> C:\\Users\\hato2\\.rustup\\toolchains\\nightly-2021-10-26-x86_64-pc-windows-msvc\\lib\\rustlib\\src\\rust\\library\\core\\src\\intrinsics.rs:2057:14\r\n       |\r\n  2057 |     unsafe { copy_nonoverlapping(src, dst, count) }\r\n       |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n\r\n  error: could not compile `shader` due to previous error\r\n  Error: BuildFailed\r\n```\r\n\r\nIt's OK in the previous version. Please see https://github.com/hatoo/rust-gpu-issue/tree/swap-succ.\r\n\r\n## System Info\r\n<!--\r\nHelpful commands:\r\n- Rustc version: `rustc -V`\r\n- SPIR-V version: `spirv-val --version`\r\n-->\r\n\r\n - Rust: rustc 1.58.0-nightly (29b124802 2021-10-25)\r\n - OS: Windows 11\r\n - GPU: RTX2080ti\r\n - SPIR-V: SPIRV-Tools v2021.3 v2021.3\r\n\r\n\r\n## Backtrace\r\n<!-- If relevant, please include a backtrace of the error below. -->\r\n\r\n<details><summary>Backtrace</summary>\r\n<p>\r\n\r\n```\r\n<backtrace>\r\n```\r\n\r\n</p>\r\n</details>\r\n",
    "comments": [
      {
        "id": "IC_kwDOENG44846Jk3B",
        "author": {
          "login": "eddyb"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "In #716 we updated to a version that supports `mem::replace` again, thanks to https://github.com/rust-lang/rust/pull/87827, but `mem::swap` indeed did not get fixed the same way - if someone wants to try and land upstream something like that PR but for `mem::swap`, feel free to.\r\n\r\nI gave up on it because of how rare `mem::swap` is compared to `mem::replace` (which gets used everywhere in `core`, e.g. `Option::take(self)` is `mem::replace(self, None)` and range iterators also depend on it).\r\n\r\nThere's a more general fix at https://github.com/rust-lang/rust/pull/86699 but it requires a bunch of unstable feature-gating stuff I haven't gone back to for.",
        "createdAt": "2021-11-22T14:33:16Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "users": {
              "totalCount": 1
            }
          }
        ],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/804#issuecomment-975588801",
        "viewerDidAuthor": false
      },
      {
        "id": "IC_kwDOENG4485YuotN",
        "author": {
          "login": "oisyn"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "Closing as won't fix, it's very unlikely we will address this in the forseeable future.",
        "createdAt": "2023-03-29T13:32:12Z",
        "includesCreatedEdit": true,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/804#issuecomment-1488620365",
        "viewerDidAuthor": false
      },
      {
        "id": "IC_kwDOENG4485n1v47",
        "author": {
          "login": "eddyb"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "This actually works in Rust-GPU 0.4, and more specifically since `nightly-2022-02-28`, thanks to:\r\n* https://github.com/rust-lang/rust/pull/94412\r\n<sub>(the function being modified there, `swap_simple`, is always used on SPIR-V, and the change that actually unblocked it was `ptr::copy_nonoverlapping(y, x, 1)` being replaced with a `ptr::{read,write}` pair)</sub>\r\n\r\nBut at the same time, I wanted to propose to upstream that they can remove the `target_arch = \"spirv\"` hack, as it got brought up in this issue:\r\n* https://github.com/rust-lang/unsafe-code-guidelines/issues/461\r\n\r\n~~Now I'm worried that people may be relying on it, since it works, but I'm not sure how to check.~~\r\n~~`core` itself seems to mostly use for sorting/partitioning-like tasks.~~\r\n\r\nOh, [according to sourcegraph, it's definitely gotten used](https://sourcegraph.com/search?q=context:global+language:rust+spirv_std+AND+/swap%5C%28/&patternType=standard&case=yes&sm=1&groupBy=path), oh well.\r\n\r\nSo we might want to do nothing for now, and only remove the upstream hack if `qptr` can supersede it.",
        "createdAt": "2023-10-01T17:15:11Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/804#issuecomment-1742143035",
        "viewerDidAuthor": false
      }
    ],
    "createdAt": "2021-11-21T13:05:53Z",
    "labels": [
      {
        "id": "MDU6TGFiZWwyMjI3MzM4ODEz",
        "name": "t: bug",
        "description": "Something isn't working",
        "color": "52E8A0"
      },
      {
        "id": "MDU6TGFiZWwyNDgxOTAxNzc3",
        "name": "a: rust-lang",
        "description": "Issues specific to rust-lang/rust.",
        "color": "FCA492"
      },
      {
        "id": "LA_kwDOENG4487X7nyy",
        "name": "t: external",
        "description": "Issues not about rust-gpu itself, but related enough to be tracked.",
        "color": "52e8a0"
      },
      {
        "id": "LA_kwDOENG4488AAAABPXHqow",
        "name": "s: qptr may fix",
        "description": "This might be fixed by the \"qptr\" experiment (https://github.com/EmbarkStudios/spirt/pull/24)",
        "color": "CCCCCC"
      }
    ],
    "number": 804,
    "reactionGroups": [],
    "state": "OPEN",
    "title": "`core::mem::swap` used to work, then broke (and later accidentally got unbroken again).",
    "url": "https://github.com/EmbarkStudios/rust-gpu/issues/804"
  },
  {
    "author": {
      "id": "MDQ6VXNlcjk1MzE1MQ==",
      "is_bot": false,
      "login": "khyperia",
      "name": "Ashley Hauck"
    },
    "body": "For a while, we've been talking about trying to take our absolutely horrifying, fragile, confusing hacks that let users embed rust-gpu programs in host programs and putting them into cargo itself. For example, [this discussion (unfortunately in a private section of our discord)](https://discord.com/channels/750717012564770887/781563027660079124/874621438869532672).\r\n\r\nThe high-level goal is to basically remove `spirv-builder` and make its functionality part of cargo itself.\r\n\r\nThe extremely high level view of how it works, right now, is: \"The user writes x86 crate, with a build.rs. There's a build-dependency on spirv-builder, which itself depends on rustc_codegen_spirv. Spirv-builder then invokes a nested cargo process (within the user's build.rs), passing in rustc_codegen_spirv as the backend to use, and using `--target spirv-xyz`. It then takes the resulting binary and spews it out of the user's build.rs to make it embeddable in the host x86 crate\". We've spent countless, countless hours finding an extremely narrow, fragile path that makes it just barely work on most days, but when thursdays roll around, Thor sneezes and an undecipherable error from halfway around the world comes shooting out.\r\n\r\nMy theory of how this would be integrated into cargo (only a theory, could be implemented in some other way) is to make cargo aware of building multiple targets in a single cargo process invocation. That means that an x86 crate could declare a dependency on a SPIR-V crate (or a wasm crate, too!), and that dependency would get built, binary blob result gathered, and embedded into the host x86 crate. How those dependencies are specified and configured, how it's embedded, how everything works, are very very open questions.\r\n\r\nThis issue is for the high-level tracking of investigating what design work should be done, and how to go about implementing it - mainly so that this idea doesn't get lost in the depths of chat logs (again). I don't expect detailed design docs to be in this thread or whatever, I mostly intend this as a sticky note of \"do this!!\" :sparkles:\r\n\r\nKey Cargo issues tracking the development of new functionality to support this:\r\n- [ ] https://github.com/rust-lang/cargo/issues/9096\r\n- [ ] https://github.com/rust-lang/cargo/issues/10030\r\n- [x] https://github.com/rust-lang/cargo/issues/8176 - probably not needed\r\n- [x] https://github.com/rust-lang/cargo/pull/9992\r\n- [ ] https://github.com/rust-lang/cargo/pull/10061",
    "comments": [
      {
        "id": "IC_kwDOENG44845M_-e",
        "author": {
          "login": "repi"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "Thanks for filing and detailing! Great to have this as a tracking and coordination issue for this work. Can discuss in posts here (or linked separate issues) while keeping your top post up to date with links and current state of this as we find out (and hopefully) progress more towards this.\r\n\r\nHave been a few related RFCs and partial support in Cargo for building crates for multiple targets and dependencies across targets. Added a few links in the top post. Don't know enough about them to know how far they get vs what we need here though but that feels like a good start to investigate also for someone that knows more on the Cargo side (and for us to describe and show the use case here in rust-gpu more).\r\n\r\nOn another related note, we want this type of \"Cargo multi target support\" for WASM in a quite similar way also; to be able to have a crate built for native that depends on another crate which is built for `wasm32-unknown-unknown` and be able to build all of them with a single `cargo build`. Today for our WASM modules we have them in a separate workspace and manually build both instead.   That said, the WASM use case is not as important as the SPIRV / rust-gpu use case we have here, but thought I should mention it.\r\n\r\nAnother related note and Cargo feature we've been wanting to have that is a minimal building block for this also is to be able to specify which targets a crate can be built for (also wanted both for shaders and for wasm):\r\n- https://github.com/EmbarkStudios/rust-ecosystem/issues/41\r\n- https://github.com/rust-lang/cargo/issues/6179",
        "createdAt": "2021-11-03T16:45:51Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/791#issuecomment-959709086",
        "viewerDidAuthor": false
      }
    ],
    "createdAt": "2021-11-03T11:10:13Z",
    "labels": [
      {
        "id": "MDU6TGFiZWwyNDQzMjY4NzAw",
        "name": "t: tracking issue",
        "description": "An issue tracking the progress of a specific feature or change.",
        "color": "52E8A0"
      },
      {
        "id": "LA_kwDOENG4487X7nyy",
        "name": "t: external",
        "description": "Issues not about rust-gpu itself, but related enough to be tracked.",
        "color": "52e8a0"
      }
    ],
    "number": 791,
    "reactionGroups": [],
    "state": "OPEN",
    "title": "External tracking: multiple targets in single cargo process",
    "url": "https://github.com/EmbarkStudios/rust-gpu/issues/791"
  },
  {
    "author": {
      "id": "MDQ6VXNlcjEzNTY2MTM1",
      "is_bot": false,
      "login": "expenses",
      "name": "Ashley"
    },
    "body": "I started looking into how `OpConvertUToPtr` can be implemented - initially for `RuntimeArray`s. Something like this works well, but is not generic:\r\n\r\n```rust\r\nunsafe fn load_f32_runtime_array_from_handle(handle: u64) -> &'static mut RuntimeArray<f32> {\r\n    asm!(\r\n        \"%f32 = OpTypeFloat 32\",\r\n        \"%runtime_array = OpTypeRuntimeArray %f32\",\r\n        \"%runtime_array_ptr = OpTypePointer Generic %runtime_array\",\r\n        \"%result = OpConvertUToPtr %runtime_array_ptr {handle}\",\r\n        \"OpReturnValue %result\",\r\n        handle = in(reg) handle,\r\n        options(noreturn)\r\n    )\r\n}\r\n```\r\n\r\nI know that @msiglreith implemented loading resources from handles in https://github.com/EmbarkStudios/rust-gpu/compare/main...msiglreith:glace, but it looks like that requires a lot of codegen changes - ideally we should keep things at the `asm!` layer if possible.\r\n\r\nIs there a way to make the above function generic over `T`, or will this require a few codegen changes?\r\n",
    "comments": [
      {
        "id": "IC_kwDOENG44844J165",
        "author": {
          "login": "khyperia"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "I believe this will work:\r\n\r\n```rust\r\nunsafe fn load_runtime_array_from_handle<T>(handle: u64) -> &'static mut RuntimeArray<T> {\r\n    let result: *mut RuntimeArray<T>;\r\n    asm!(\r\n        \"{result} = OpConvertUToPtr typeof{result} {handle}\",\r\n        handle = in(reg) handle,\r\n        result = out(reg) result,\r\n    );\r\n    &mut *result\r\n}\r\n```\r\n\r\nHowever, this runs into the issue that ConvertUToPtr requires non-Logical addressing, which will require (significant?) compiler changes to support. Also, I know at least the Addresses capability is not supported on Vulkan, and I'm not sure about PhysicalStorageBufferAddresses, would have to check (one of those two things needs to be supported for ConvertUToPtr to work). But, this is at least the way to write such a thing.\r\n\r\n(I think you could probably just straight up return `&'static mut T` instead of RuntimeArray, doesn't have to be specialized to RuntimeArray - and probably should return `*mut T` for saftey, `&'static mut T` is a little spooky to me~)",
        "createdAt": "2021-10-13T09:23:02Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/767#issuecomment-942104249",
        "viewerDidAuthor": false
      },
      {
        "id": "IC_kwDOENG44844J2VY",
        "author": {
          "login": "khyperia"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "Here's a compiletest, in case we need it in the future (currently fails with \"OpConvertUToPtr not supported in Logical addressing\")\r\n\r\n```rust\r\n// build-pass\r\n// compile-flags: -C target-feature=+PhysicalStorageBufferAddresses,+ext:SPV_KHR_physical_storage_buffer\r\n\r\nuse spirv_std::*;\r\n\r\nunsafe fn convert_u_to_ptr<T>(handle: u64) -> *mut T {\r\n    let result: *mut T;\r\n    asm!(\r\n        \"{result} = OpConvertUToPtr typeof{result} {handle}\",\r\n        handle = in(reg) handle,\r\n        result = out(reg) result,\r\n    );\r\n    result\r\n}\r\n\r\n#[spirv(fragment)]\r\npub fn main(out: &mut u32) {\r\n    unsafe {\r\n        let x: *mut RuntimeArray<u32> = convert_u_to_ptr(100);\r\n        *out = *(*x).index(0);\r\n    }\r\n}\r\n```",
        "createdAt": "2021-10-13T09:25:05Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/767#issuecomment-942105944",
        "viewerDidAuthor": false
      },
      {
        "id": "IC_kwDOENG44844KBsm",
        "author": {
          "login": "expenses"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "Utgh, I forgot I was on @msiglreith's branch when I tested that üòÖ\r\n\r\nI've been making some progress here: https://github.com/EmbarkStudios/rust-gpu/compare/main...expenses:convert-u-to-ptr\r\n\r\nit now fails with alignment issues.",
        "createdAt": "2021-10-13T10:22:57Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/767#issuecomment-942152486",
        "viewerDidAuthor": false
      },
      {
        "id": "IC_kwDOENG44844KBxG",
        "author": {
          "login": "msiglreith"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "One issue I had with physical storage addresses was the pointer storage class inference. Afaik the current inference algorithm assumes/requires every pointer being `Generic` and `OpConvertUToPtr ` requires generating a `OpTypePointer` out of thin-air in the asm. The default type would be `Function` which conflicts with the requested pointer type.",
        "createdAt": "2021-10-13T10:23:17Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/767#issuecomment-942152774",
        "viewerDidAuthor": false
      },
      {
        "id": "IC_kwDOENG44844KLt4",
        "author": {
          "login": "expenses"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "> \r\n> \r\n> Utgh, I forgot I was on @msiglreith's branch when I tested that üòÖ\r\n> \r\n> I've been making some progress here: [main...expenses:convert-u-to-ptr](https://github.com/EmbarkStudios/rust-gpu/compare/main...expenses:convert-u-to-ptr)\r\n> \r\n> it now fails with alignment issues.\r\n\r\nOkay, most issues have been resolved, but I'm still getting alignment errors with some struct fields:\r\n\r\n```rust\r\n#[repr(C)]\r\npub struct Struct {\r\n    pub a: Mat4,\r\n    pub b: Mat4,\r\n    pub c: Vec3,\r\n    pub d: f32,\r\n    pub e: u32,\r\n    pub f: u32,\r\n    pub g: u32,\r\n    pub h: bool,\r\n}\r\n\r\n#[spirv(fragment)]\r\npub fn main(out: &mut u32) {\r\n    unsafe {\r\n        let x: *mut RuntimeArray<u32> = arch::convert_u_to_ptr(100);\r\n        let y: *mut Struct = arch::convert_u_to_ptr(200);\r\n\r\n        let mat = (*y).a;\r\n\r\n        *out = *(*x).index(0) + (*y).g;\r\n    }\r\n}\r\n```\r\nIt's happy with `(*y).g` but not `(*y).a`:\r\n```rust\r\nerror: error:0:0 - Memory accesses with PhysicalStorageBufferEXT must use Aligned.\r\n```",
        "createdAt": "2021-10-13T11:15:12Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/767#issuecomment-942193528",
        "viewerDidAuthor": false
      },
      {
        "id": "IC_kwDOENG44844KXCE",
        "author": {
          "login": "expenses"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "Solved that problem as well - just had to `OpCopyMemory` instructions. https://github.com/EmbarkStudios/rust-gpu/compare/main...expenses:convert-u-to-ptr now works well for my purposes. It'd be good to see how we can get it to a mergeable state.",
        "createdAt": "2021-10-13T12:13:27Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/767#issuecomment-942239876",
        "viewerDidAuthor": false
      },
      {
        "id": "IC_kwDOENG44844KfMb",
        "author": {
          "login": "msiglreith"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "Nice! Memory access instructions in asm blocks accessing physical storage buffers also need handling for the `Aligned` attribute. Unfortunately these are not covered by the `load`/`memcpy` interface. ",
        "createdAt": "2021-10-13T12:52:27Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/767#issuecomment-942273307",
        "viewerDidAuthor": false
      },
      {
        "id": "IC_kwDOENG44844KgaX",
        "author": {
          "login": "khyperia"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "> It'd be good to see how we can get it to a mergeable state.\r\n\r\nUnfortunately I think it's pretty far from being mergeable:\r\n\r\n1) We probably want to use an integrated-into-the-language version of casting (e.g. `as`) rather than a function intrinsic. For example, [making this work](https://github.com/EmbarkStudios/rust-gpu/blob/f8a1130377a4a500ff05d1058b29c8f1a42f2d80/crates/rustc_codegen_spirv/src/builder/builder_methods.rs#L1243). Still, a function intrinsic is useful for use in user libraries for now, until if/when we get the more integrated version implemented.\r\n2) We need a better way of specifying `Aligned` on loads than putting them on everything unconditionally.\r\n3) Quite a bit of investigation needs to go into figuring out what non-Logical addressing modes actually imply about what assumptions can be made in the compiler - I'm fairly sure that quite a few places we assume Logical to simplify things. Similarly, assumptions around 32 vs. 64 bit pointers are important - e.g. right now, the branch is using 64 bit pointers with PhysicalStorageBuffer64, except the rust compiler is using 32 bit pointers in the target config.\r\n4) There's a few questionable changes signaling significant underlying problems that need to be investigated and resolved - for example, changing the specializer to default to PhysicalStorageBuffer instead of Function, and changing integer/floats to default to 1-byte alignment.\r\n\r\nSadly, I don't think this is very high on Embark's priority list, so I'm not sure how much help on the above I'll be able to provide :(",
        "createdAt": "2021-10-13T12:58:08Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/767#issuecomment-942278295",
        "viewerDidAuthor": false
      },
      {
        "id": "IC_kwDOENG44844Llck",
        "author": {
          "login": "AidanConnelly"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "> 3. Quite a bit of investigation needs to go into figuring out what non-Logical addressing modes actually imply about what assumptions can be made in the compiler - I'm fairly sure that quite a few places we assume Logical to simplify things\r\n\r\nTo clarify, the [memory model](https://www.khronos.org/registry/SPIR-V/specs/unified1/SPIRV.html#OpMemoryModel) is assumed to _be_ logical, or it's assumed to _possibly be_ logical?",
        "createdAt": "2021-10-13T17:40:24Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/767#issuecomment-942561060",
        "viewerDidAuthor": false
      },
      {
        "id": "IC_kwDOENG44844NfeG",
        "author": {
          "login": "khyperia"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "Assumed to be logical - as in, \"ah, there's a really complicated to deal with situation here that's difficult to implement, but, this situation can never happen with logical, only physical, so we're not going to deal with it right now\"",
        "createdAt": "2021-10-14T06:51:07Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "users": {
              "totalCount": 1
            }
          }
        ],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/767#issuecomment-943060870",
        "viewerDidAuthor": false
      },
      {
        "id": "IC_kwDOENG44844N7RS",
        "author": {
          "login": "expenses"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "https://www.khronos.org/registry/SPIR-V/specs/unified1/SPIRV.html#Addressing_Model\r\n\r\n> PhysicalStorageBuffer64\r\n>\r\n> Indicates that pointers with a storage class of PhysicalStorageBuffer are physical pointer types with an address width of 64 bits, while pointers to all other storage classes are logical.\r\n\r\nThis seems to imply that we only need to worry about non-logical pointers in the context of `PhysicalStorageBuffer`s, which might make things easier (or not).\r\n",
        "createdAt": "2021-10-14T09:20:44Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/767#issuecomment-943174738",
        "viewerDidAuthor": false
      },
      {
        "id": "IC_kwDOENG44844f_4u",
        "author": {
          "login": "eddyb"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "> One issue I had with physical storage addresses was the pointer storage class inference. Afaik the current inference algorithm assumes/requires every pointer being `Generic` and `OpConvertUToPtr ` requires generating a `OpTypePointer` out of thin-air in the asm. The default type would be `Function` which conflicts with the requested pointer type.\r\n\r\nI think the fix for that would be to add an inference rule for `OpConvertUToPtr` that basically claims that the only storage class it can output is e.g. `PhysicalStorageBuffer32` - seems like that would require:\r\n\r\n1. adding a new variant to `StorageClassPat`: https://github.com/EmbarkStudios/rust-gpu/blob/0e0304a2328a1de65e2a6745e6042ea7c03ddb58/crates/rustc_codegen_spirv/src/spirv_type_constraints.rs#L31-L36\r\n  * and an import here: https://github.com/EmbarkStudios/rust-gpu/blob/0e0304a2328a1de65e2a6745e6042ea7c03ddb58/crates/rustc_codegen_spirv/src/spirv_type_constraints.rs#L185-L192\r\n2. splitting `Op::ConvertUToPtr` out of this arm: https://github.com/EmbarkStudios/rust-gpu/blob/0e0304a2328a1de65e2a6745e6042ea7c03ddb58/crates/rustc_codegen_spirv/src/spirv_type_constraints.rs#L427\r\n```rust\r\nOp::ConvertUToPtr =>  sig! { (_) -> Pointer(PhysicalStorageBuffer32, _) }\r\n```\r\n3. handle `StorageClassPat::PhysicalStorageBuffer32` here: https://github.com/EmbarkStudios/rust-gpu/blob/0e0304a2328a1de65e2a6745e6042ea7c03ddb58/crates/rustc_codegen_spirv/src/linker/specializer.rs#L1224-L1225\r\n```rust\r\n            StorageClassPat::PhysicalStorageBuffer32 => {\r\n                let mut m = Match::default();\r\n                // HACK(eddyb) choice of `0` makes this potentially overlap\r\n                // with `Var(0)` and a different mechanism should be added.\r\n                let found = m.storage_class_var_found\r\n                    .get_mut_or_default(0);\r\n                found.push(storage_class);\r\n                found.push(InferOperand::Concrete(CopyOperand::StorageClass(StorageClass::PhysicalStorageBuffer32)));\r\n                m\r\n            }\r\n```\r\n(this effectively emulates something like `{S} (_) -> Pointer(S, _)`, where the instruction has a storage class operand, that happens to contain `PhysicalStorageBuffer32`, and there's also a storage class inference variable in the resulting pointer type, and the use of `S` in both places links them during inference - but in this case, the instruction itself doesn't have a storage class operand, so we have to fake it)\r\n\r\n<hr/>\r\n\r\nAlternatively, we could hack around this with e.g. `OpGenericCastToPtrExplicit` to specify the storage class to infer, but then we'd have to remove that instruction since it's `Kernel`-only.",
        "createdAt": "2021-10-20T18:06:37Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/767#issuecomment-947912238",
        "viewerDidAuthor": false
      },
      {
        "id": "IC_kwDOENG4485Yun40",
        "author": {
          "login": "eddyb"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "I've talked about this elsewhere, but my current approach to dealing with pointers is this:\r\n* https://github.com/EmbarkStudios/spirt/pull/24\r\n\r\n(there's a lot there you could read, but the short version is that the \"storage class inference\" in Rust-GPU is a dead-end, and erasing pointer types can be far more effective and flexible)\r\n\r\nWith the `qptr` passes replacing the storage class inference, you could use `OpTypePointer PhysicalStorageBuffer64 ...` in `asm!` and it should \"just\" work (with no need for the types to exactly \"match up\" elsewhere).",
        "createdAt": "2023-03-29T13:30:04Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/767#issuecomment-1488617012",
        "viewerDidAuthor": false
      }
    ],
    "createdAt": "2021-10-13T09:10:25Z",
    "labels": [
      {
        "id": "MDU6TGFiZWwyMjI3MzM4ODE2",
        "name": "t: enhancement",
        "description": "A new feature or improvement to an existing one.",
        "color": "52E8A0"
      },
      {
        "id": "LA_kwDOENG4488AAAABPXHqow",
        "name": "s: qptr may fix",
        "description": "This might be fixed by the \"qptr\" experiment (https://github.com/EmbarkStudios/spirt/pull/24)",
        "color": "CCCCCC"
      }
    ],
    "number": 767,
    "reactionGroups": [],
    "state": "OPEN",
    "title": "`OpConvertUToPtr` support",
    "url": "https://github.com/EmbarkStudios/rust-gpu/issues/767"
  },
  {
    "author": {
      "id": "MDQ6VXNlcjEzNTY2MTM1",
      "is_bot": false,
      "login": "expenses",
      "name": "Ashley"
    },
    "body": "Occasionally, a shader variable requires the `NonUniform` decoration. One example of this is when doing a texture lookup in a ray-tracing shader, where the texture index might not be uniform with the neighbouring rays. See: https://github.com/expenses/ray-tracing-gallery/blob/cb0cb06cc60a5632150e606261a02ba26862ac09/shaders/closesthit.glsl#L136-L138.\r\n\r\nI've attempted to do this with `asm!`:\r\n```rust\r\n#[spirv(descriptor_set = 0, binding = 1)] textures: &RuntimeArray<SampledImage<\r\n    Image!(2D, type=f32, sampled=true),\r\n>>,\r\n...\r\n\r\nunsafe {\r\n    asm! {\r\n        \"OpDecorate {} NonUniform\",\r\n        in(reg) &texture_index\r\n    }\r\n};\r\n\r\nlet uv = Vec2::splat(0.0);\r\nlet texture = unsafe {\r\n    textures.index(texture_index as usize)\r\n};\r\nlet colour: Vec4 = unsafe { texture.sample_by_lod(uv, 0.0) };\r\n```\r\n\r\nbut the decoration wasn't included in the final SPIR-V module. Perhaps it was optimized out? The `u32` -> `usize` conversion that is needed for accessing indexing `RuntimeArray`s could be a problem as well.\r\n\r\n<!--\r\nThank you for your interest in the `rust-gpu` project! This template is for\r\nproposing a minor improvement, such as addig a new method, or improving \r\ndocumentation. Please try to provide a short high level overview of what you would\r\nlike you to add. Also be sure to check the existing and `wontfix` issues to see\r\nif it's already been proposed before posting.\r\n\r\nExisting Issues: https://github.com/EmbarkStudios/rust-gpu/issues?q=is%3Aopen+is%3Aissue+label%3A%22t%3A+enhancement%22\r\nClosed Issues: https://github.com/EmbarkStudios/rust-gpu/labels/s%3A%20wontfix\r\n\r\n-->\r\n\r\n",
    "comments": [
      {
        "id": "IC_kwDOENG44845TiZo",
        "author": {
          "login": "DJMcNab"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "I mentioned this on discord, but I believe the reason that the decoration is optimised out here is because the entry point is generated, which calls the actual function; this call of the function then gets inlined, removing the decoration.\r\n\r\nThat is, within the function context, your decoration is applying to the function argument, not the entry point variable.\r\n\r\nI however don't have a good suggestion for how this could be worked around, at least not without some support in rust-gpu.",
        "createdAt": "2021-11-04T21:07:28Z",
        "includesCreatedEdit": true,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "users": {
              "totalCount": 1
            }
          }
        ],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/756#issuecomment-961422952",
        "viewerDidAuthor": false
      },
      {
        "id": "IC_kwDOENG44845T38P",
        "author": {
          "login": "expenses"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "@DJMcNab Right, thanks for investigating! And to clarify, this inlining happens in rust-gpu and not via the `spirv-opt` passes, correct? ",
        "createdAt": "2021-11-04T23:37:48Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/756#issuecomment-961511183",
        "viewerDidAuthor": false
      },
      {
        "id": "IC_kwDOENG44845UkaH",
        "author": {
          "login": "DJMcNab"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "I haven't checked it through either way. I'd be inclined to think it's a `rust-gpu` pass, but I can't be sure.\n\nI suppose one algorithm we could use is to decorate entry point variables with any variables which apply to the entry point function arguments in entry point decoration. This would make the `asm!` workaround work, without having to try and work out a safe interface to these parts. ",
        "createdAt": "2021-11-05T07:59:03Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/756#issuecomment-961693319",
        "viewerDidAuthor": false
      },
      {
        "id": "IC_kwDOENG44845U5tH",
        "author": {
          "login": "expenses"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "I did some testing by writing out the module between each pass. It seems that the DCE pass is removing the decoration. It's possible that it would get removed in other places as well. ",
        "createdAt": "2021-11-05T10:26:03Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/756#issuecomment-961780551",
        "viewerDidAuthor": false
      },
      {
        "id": "IC_kwDOENG44845U64h",
        "author": {
          "login": "expenses"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "Oh but before that, the inlining pass inlines the variable being decorated without updating the decoration. That should be the first thing to fix.",
        "createdAt": "2021-11-05T10:33:39Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/756#issuecomment-961785377",
        "viewerDidAuthor": false
      },
      {
        "id": "IC_kwDOENG44846IK55",
        "author": {
          "login": "khyperia"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "Just a quick note, I don't think decorating `NonUniform` via `asm!` is the way we want to support `NonUniform` - `asm!` is intended to be an internal implementation detail, rather than something users write. We probably want to look into properly designing something instead of trying to hack up `asm!` to do something it was not intended to do.",
        "createdAt": "2021-11-22T08:00:46Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/756#issuecomment-975220345",
        "viewerDidAuthor": false
      },
      {
        "id": "IC_kwDOENG4484694Jg",
        "author": {
          "login": "expenses"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "> Just a quick note, I don't think decorating `NonUniform` via `asm!` is the way we want to support `NonUniform` - `asm!` is intended to be an internal implementation detail, rather than something users write. We probably want to look into properly designing something instead of trying to hack up `asm!` to do something it was not intended to do.\r\n\r\nYeah, I guess you want `fn non_uniform<T>(value: T) -> T`, similar to https://github.com/KhronosGroup/GLSL/blob/master/extensions/ext/GL_EXT_nonuniform_qualifier.txt.",
        "createdAt": "2021-12-08T23:06:38Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/756#issuecomment-989299296",
        "viewerDidAuthor": false
      },
      {
        "id": "IC_kwDOENG44847AaD2",
        "author": {
          "login": "ElectronicRU"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "What about uniformity analysis? We already do rather heavy block-graph analyses in linker\r\nAssigning nonuniform automatically could be pretty useful wrt Just Working (will also help catch errors in places where non-uniform values are not actually supported)",
        "createdAt": "2021-12-09T15:33:36Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/756#issuecomment-989962486",
        "viewerDidAuthor": false
      },
      {
        "id": "IC_kwDOENG44847BLWU",
        "author": {
          "login": "expenses"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "I looked into implemented the support via an intrinsic and `emit_global`: https://github.com/EmbarkStudios/rust-gpu/compare/main...expenses:non-uniform-intrinsic but it seems that the decoration is still being silently ignored/removed. I don't know what I'm doing though and this could still be the right approach.",
        "createdAt": "2021-12-09T19:28:48Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/756#issuecomment-990164372",
        "viewerDidAuthor": false
      },
      {
        "id": "IC_kwDOENG44847HEBG",
        "author": {
          "login": "Jasper-Bekkers"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "> What about uniformity analysis? We already do rather heavy block-graph analyses in linker\n> Assigning nonuniform automatically could be pretty useful wrt Just Working (will also help catch errors in places where non-uniform values are not actually supported)\n\nFor that please see #49",
        "createdAt": "2021-12-11T16:44:15Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/756#issuecomment-991707206",
        "viewerDidAuthor": false
      },
      {
        "id": "IC_kwDOENG4485YvUcC",
        "author": {
          "login": "SiebenCorgie"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "I tried to find out why @expenses decoration was removed before. For that, I added a `index_nonuniform` function to [`RuntimeArray`](https://github.com/EmbarkStudios/rust-gpu/blob/39cbc6764805a6632b4cd1e6054c1bc8c9c5ad4d/crates/spirv-std/src/runtime_array.rs#L74).\r\n\r\nApparently, the `Inliner` was responsible for removing the decoration. Since the decoration happens in an inlined function, the decoration's IDs need to be rewritten as well, not just the inlined part of the function. This is implemented [here](https://github.com/EmbarkStudios/rust-gpu/blob/39cbc6764805a6632b4cd1e6054c1bc8c9c5ad4d/crates/rustc_codegen_spirv/src/linker/inline.rs#L289).\r\n\r\nHowever, this does not fix everything. Unfortunately it is not enough to keep the `NonUniform` decoration just for the result of `OpAccessChain`. `Image::sample` does an [`OpLoad`](https://github.com/EmbarkStudios/rust-gpu/blob/main/crates/spirv-std/src/image.rs#L204) for the `Image`'s ID. In our non-uniform case, this ID must be decorated with `NonUniform` as well. However, it seems non-trivial to find out when to decorate this load and when not. In my experience, the `Image::sample` function is often not inlined. So you'd need one version with a non-uniform decorated `%image` and one without. I'm not sure how that would be implemented. For now, I just added a *special* `sample_nonuniform` function [here](https://github.com/EmbarkStudios/rust-gpu/blob/39cbc6764805a6632b4cd1e6054c1bc8c9c5ad4d/crates/spirv-std/src/image.rs#L221).\r\n\r\nWith all that in place, the correctly decorated code gets emitted for the following Rust code:\r\n```rust\r\nfn some_function(..., image_array: &mut RuntimeArray<Image!(2D, type = f32, sampled = true)>){\r\n\tlet nonuniformly_calculated_index = ...;\r\n\tlet value = image_array\r\n\t\t.index_nonuniform(nonuniformly_calculated_index)\r\n\t\t.sample_nonuniform(\r\n\t\t    some_sampler,\r\n\t\t    some_vec2,\r\n\t\t);\r\n}\r\n```\r\n\r\nA fix *for now* could be to just decorate that `OpLoad` in all `Image::sample`-like functions. Together with the Inliner-fix that would enable some non-uniform access. AFAIK SpirT will track decorations better later anyway.\r\n\r\nI didn't test RuntimeArrays of buffers (`RuntimeArray<T>` and `RuntimeArray<TypedBuffer<T>>` / `RuntimeArray<TypedBuffer<[T]>>`) but I think I could come up with a similar workaround for those.\r\n",
        "createdAt": "2023-03-29T15:02:35Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/756#issuecomment-1488799490",
        "viewerDidAuthor": false
      }
    ],
    "createdAt": "2021-09-25T11:44:25Z",
    "labels": [
      {
        "id": "MDU6TGFiZWwyMjI3MzM4ODE2",
        "name": "t: enhancement",
        "description": "A new feature or improvement to an existing one.",
        "color": "52E8A0"
      },
      {
        "id": "LA_kwDOENG4488AAAABPXHqow",
        "name": "s: qptr may fix",
        "description": "This might be fixed by the \"qptr\" experiment (https://github.com/EmbarkStudios/spirt/pull/24)",
        "color": "CCCCCC"
      }
    ],
    "number": 756,
    "reactionGroups": [],
    "state": "OPEN",
    "title": "`NonUniform` decoration support",
    "url": "https://github.com/EmbarkStudios/rust-gpu/issues/756"
  },
  {
    "author": {
      "id": "MDQ6VXNlcjcxOTcyOTg=",
      "is_bot": false,
      "login": "SiebenCorgie",
      "name": "Tendsin Mende"
    },
    "body": "When calling a function with a sub-slice of some other slice, the compiler throws a strange error:\r\n\r\nSmall example: \r\n```\r\npub fn t1(main: &[f32]){\r\n    let a = t2(&main[10..13]);\r\n}\r\n\r\nfn t2(sub: &[f32]) -> u32{\r\n    1\r\n}\r\n```\r\nthrows\r\n```\r\n  error: Cannot cast between pointer types\r\n    --> /.../rustup/toolchains/nightly-2021-08-27-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/const_ptr.rs:49:6\r\n     |\r\n  49 |     }\r\n     |      ^\r\n     |\r\n     = note: from: *f32\r\n     = note: to: *struct () {  }\r\n\r\n  error: Cannot cast between pointer types\r\n     --> /.../.rustup/toolchains/nightly-2021-08-27-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/metadata.rs:117:14\r\n      |\r\n  117 |     unsafe { PtrRepr { components: PtrComponents { data_address, metadata } }.const_ptr }\r\n      |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n      |\r\n      = note: from: *[u8; 8]\r\n      = note: to: *struct core::ptr::metadata::PtrComponents<[f32]> { *struct () {  }, u32 }\r\n\r\n  error: Cannot cast between pointer types\r\n     --> /.../.rustup/toolchains/nightly-2021-08-27-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/metadata.rs:117:14\r\n      |\r\n  117 |     unsafe { PtrRepr { components: PtrComponents { data_address, metadata } }.const_ptr }\r\n      |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n      |\r\n      = note: from: *[u8; 8]\r\n      = note: to: *struct *const [f32] { *[f32], u32 }\r\n\r\n  error: Cannot offset a pointer to an arbitrary element\r\n     --> /.../.rustup/toolchains/nightly-2021-08-27-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/const_ptr.rs:235:18\r\n      |\r\n  235 |         unsafe { intrinsics::offset(self, count) }\r\n      |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n```\r\n\r\nThis is probably a similar problem like [this](https://github.com/EmbarkStudios/rust-gpu/issues/329), however, under different circumstances. If this is viewed as a duplicate, just close the Issue please.\r\n\r\n",
    "comments": [
      {
        "id": "IC_kwDOENG44842xWTR",
        "author": {
          "login": "khyperia"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "Unfortunately yeah, SPIR-V does not have an easy representation of subslices - we would need to tack on a `(offset, length)` pair to all regular arrays to support slicing, which then would change the ABI of the generated SPIR-V to be significantly different than what rustc tells us to do, which we've managed to avoid doing so far (it gets really, really complicated).\r\n\r\nHopefully at some point we can support slicing, though!",
        "createdAt": "2021-09-14T07:56:24Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "users": {
              "totalCount": 1
            }
          }
        ],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/752#issuecomment-918906065",
        "viewerDidAuthor": false
      },
      {
        "id": "IC_kwDOENG44842xb43",
        "author": {
          "login": "SiebenCorgie"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "I see, I'll track the start and end of my sub-slice via additional arguments, works in glsl too! Good luck with finding a way to do that! I'd help, but I do not understand compilers enough to be a real help to you :(.",
        "createdAt": "2021-09-14T08:25:07Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/752#issuecomment-918928951",
        "viewerDidAuthor": false
      },
      {
        "id": "IC_kwDOENG4485Oov6M",
        "author": {
          "login": "oisyn"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "We probably won't be supporting slices any time soon",
        "createdAt": "2022-11-17T22:44:16Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/752#issuecomment-1319304844",
        "viewerDidAuthor": false
      }
    ],
    "createdAt": "2021-09-13T18:50:11Z",
    "labels": [
      {
        "id": "MDU6TGFiZWwyMjI3MzM4ODE2",
        "name": "t: enhancement",
        "description": "A new feature or improvement to an existing one.",
        "color": "52E8A0"
      },
      {
        "id": "LA_kwDOENG4488AAAABPXHqow",
        "name": "s: qptr may fix",
        "description": "This might be fixed by the \"qptr\" experiment (https://github.com/EmbarkStudios/spirt/pull/24)",
        "color": "CCCCCC"
      }
    ],
    "number": 752,
    "reactionGroups": [],
    "state": "OPEN",
    "title": "Can not call function with sub-slice as argument",
    "url": "https://github.com/EmbarkStudios/rust-gpu/issues/752"
  },
  {
    "author": {
      "id": "MDQ6VXNlcjEzMDkyOQ==",
      "is_bot": false,
      "login": "hrydgard",
      "name": "Henrik Rydg√•rd"
    },
    "body": "I and some others have been porting a body of HLSL code to rust-gpu. Here's some notes about unexpected differences, pitfalls, and hard-to-port things.\r\n\r\n### Fixable issues (doesn't mean they're easy!)\r\n\r\n - [ ] For loops compile to a mess that spirv-cross can't quite handle, so we're sticking to while loops\r\n - [x] .abs() and .sign() don't work (cause 64-bit int code gen). See https://github.com/EmbarkStudios/rust-gpu/issues/468\r\n - [ ]  .saturate doesn't behave like HLSL's saturate with regards to NaNs. (glam issue?)\r\n - [ ] `#derive(Debug)` on a struct really weirds the compiler out, no way to see what you did wrong\r\n - [x] Need to use `#[rustfmt::skip]` on shader entry points, since [rustfmt eats long attributes](https://github.com/rust-lang/rustfmt/issues/4579)! \r\n      For example, this line gets mangled from: \r\n```\r\n    #[spirv(storage_buffer, descriptor_set = 0, binding = 1)] instance_constants_dyn: &[InstanceDynamicParameters],\r\n```\r\n   into:\r\n```\r\n    instance_constants_dyn: &[InstanceDynamicParameters],\r\n```\r\n - [x] Nothing corresponding to HLSL's any() and all() ?\r\n - [x] Bitwise operators missing from integer vector types\r\n - [ ] Can't use named constants to control thread group size: https://github.com/EmbarkStudios/rust-gpu/issues/697\r\n - [x] barriers are very difficult to use and need wrappers (https://github.com/EmbarkStudios/rust-gpu/issues/696)\r\n - [ ] The builtin #[spirv(global_invocation_id)] id: UVec3 needs to be declared as an UVec3, and then truncated if you want a Vec2. In HLSL and GLSL it's common to declare it as a 2-vector instead (UVec2) if you only care about x and y. #885\r\n\r\n### Unintuitive behavior mismatches\r\n\r\n - #895\r\n - ~~const_mat3! is equivalent to the transpose of HLSL's float3x3. Same goes for the other matrix constructors, of course. Dangerous trap! But probably the right way around, really.~~ `const_mat3!` is no longer supported in latest `glam`.\r\n - (macaw problem) step function is unintuitive:   x.step(y) = step(y, x).\r\n\r\n### Inconveniences that may not be fixable\r\n\r\n* The mix of uint3 for global_invocation_id and int2/int3 for texture fetches is a lot more painful in rust than in HLSL.\r\n  - This currently seems to just work? ~@oisyn\r\n* a.max(b) instead of max(a, b) is sometimes kinda laborious. though rust-style. \r\n* Sometimes need to do a lot more parameter passing since inputs are not global. Not necessarily a bad thing though.\r\n\r\n### Documentation issues\r\n\r\n - shared memory not properly documented, very hard to find the correct syntax. (https://github.com/EmbarkStudios/rust-gpu/issues/695)",
    "comments": [],
    "createdAt": "2021-09-02T11:14:16Z",
    "labels": [
      {
        "id": "MDU6TGFiZWwyMjI3MzM4ODE0",
        "name": "a: documentation",
        "description": "Improvements or additions to documentation",
        "color": "FCA492"
      },
      {
        "id": "MDU6TGFiZWwyNDQzMjY4NzAw",
        "name": "t: tracking issue",
        "description": "An issue tracking the progress of a specific feature or change.",
        "color": "52E8A0"
      }
    ],
    "number": 744,
    "reactionGroups": [],
    "state": "OPEN",
    "title": "Tracking: Collection of issues found when porting HLSL to rust-gpu",
    "url": "https://github.com/EmbarkStudios/rust-gpu/issues/744"
  },
  {
    "author": {
      "id": "MDQ6VXNlcjEzMDkyOQ==",
      "is_bot": false,
      "login": "hrydgard",
      "name": "Henrik Rydg√•rd"
    },
    "body": "Due to how for loops over a range work in Rust, a lot of scaffolding code is generated that is then expected to be optimized away, but in rust-gpu, that doesn't happen enough yet. We had a case where I had to change a for i in 0..8 {} to a while i < 8 { ...; i++ } loop to work around SPIRV-Cross making a right mess out of it.\r\n\r\nFiling this issue to have something to point to from the code comment, mainly, not expectations for a quick resolution as I know it's a thorny one.",
    "comments": [
      {
        "id": "IC_kwDOENG44842JFAs",
        "author": {
          "login": "khyperia"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "Some repro steps: this rust-gpu program\r\n\r\n```rust\r\n#![cfg_attr(\r\n    target_arch = \"spirv\",\r\n    no_std,\r\n    feature(register_attr, lang_items),\r\n    register_attr(spirv)\r\n)]\r\n\r\n#[cfg(not(target_arch = \"spirv\"))]\r\nuse spirv_std::macros::spirv;\r\n\r\nuse spirv_std as _;\r\n\r\n#[spirv(fragment)]\r\npub fn main_fs(input: i32, output: &mut i32) {\r\n    let mut result = 0;\r\n    for _ in 0..10 {\r\n        result += input;\r\n    }\r\n    *output = result;\r\n}\r\n```\r\n\r\nwhen compiled and ran through `spirv-cross -V` (compile to GLSL), spits out this GLSL:\r\n\r\n```glsl\r\n#version 450\r\n\r\nstruct _14\r\n{\r\n    uint _m0;\r\n    int _m1;\r\n};\r\n\r\nstruct _15\r\n{\r\n    int _m0;\r\n    int _m1;\r\n};\r\n\r\nlayout(location = 0) in int _2;\r\nlayout(location = 0) out int _3;\r\n\r\n_14 _26;\r\nint _31;\r\n\r\nvoid main()\r\n{\r\n    bool _76 = false;\r\n    do\r\n    {\r\n        _15 _33;\r\n        _33._m0 = 0;\r\n        _33._m1 = 10;\r\n        _14 _41;\r\n        _41 = _26;\r\n        int _45;\r\n        _14 _42;\r\n        bool _79;\r\n        int _44 = 0;\r\n        for (;;)\r\n        {\r\n            if (_33._m0 < _33._m1)\r\n            {\r\n                int _34;\r\n                _34 = _33._m0;\r\n                int _35 = _33._m0 + int(1u);\r\n                _33._m0 = _35;\r\n                _42 = _14(1u, _34);\r\n            }\r\n            else\r\n            {\r\n                _14 _65 = _41;\r\n                _65._m0 = 0u;\r\n                _42 = _65;\r\n            }\r\n            bool _55_ladder_break = false;\r\n            switch (int(_42._m0))\r\n            {\r\n                case 0:\r\n                {\r\n                    _3 = _44;\r\n                    _76 = true;\r\n                    _79 = true;\r\n                    _55_ladder_break = true;\r\n                    break;\r\n                }\r\n                default:\r\n                {\r\n                    _79 = false;\r\n                    _55_ladder_break = true;\r\n                    break;\r\n                }\r\n            }\r\n            if (_55_ladder_break)\r\n            {\r\n                break;\r\n            }\r\n            _45 = _44 + _2;\r\n            _41 = _42;\r\n            _44 = _45;\r\n            continue;\r\n        }\r\n        if (_79)\r\n        {\r\n            break;\r\n        }\r\n        break;\r\n    } while(false);\r\n}\r\n```\r\n\r\nnote how `_45 = _44 + _2;` is dead code! (due to `_55_ladder_break` always being true)",
        "createdAt": "2021-08-30T13:36:05Z",
        "includesCreatedEdit": true,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/739#issuecomment-908349484",
        "viewerDidAuthor": false
      },
      {
        "id": "IC_kwDOENG44842MCQN",
        "author": {
          "login": "khyperia"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "I've filed a SPIRV-Cross issue at https://github.com/KhronosGroup/SPIRV-Cross/issues/1731 - unfortunately I wasn't able to narrow down the repro any more, hopefully something actionable still comes out of it :(",
        "createdAt": "2021-08-31T10:51:55Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/739#issuecomment-909124621",
        "viewerDidAuthor": false
      }
    ],
    "createdAt": "2021-08-30T12:50:21Z",
    "labels": [
      {
        "id": "MDU6TGFiZWwyMjI3MzM4ODE2",
        "name": "t: enhancement",
        "description": "A new feature or improvement to an existing one.",
        "color": "52E8A0"
      },
      {
        "id": "LA_kwDOENG4488AAAABFvMTdA",
        "name": "a: codegen",
        "description": "Issues related to code generation",
        "color": "FCA492"
      }
    ],
    "number": 739,
    "reactionGroups": [],
    "state": "OPEN",
    "title": "For loops need more optimizations",
    "url": "https://github.com/EmbarkStudios/rust-gpu/issues/739"
  },
  {
    "author": {
      "id": "MDQ6VXNlcjQ5NTk0",
      "is_bot": false,
      "login": "Jasper-Bekkers",
      "name": "Jasper Bekkers"
    },
    "body": "Now that the full bindless mode has been stripped (#710), I would like to open up this issue so that we can all get on the same page and see if we can support the Traverse use case as well. I'd like to inquire about near-term steps forward when it comes to bindless.\r\n\r\n- What are the plans for the equivalent of bindless ByteAddressBuffers going forward?\r\n- What is the current trajectory for specifying bindings as globals in rust-gpu?\r\n\r\nIn the remove code there was a bunch of stuff supporting the equivalent of ByteAddressBuffer/RWByteAddressBuffer (meaning, no the buffer type gets decided in `Load` and multiple datastructures can be loaded from the same buffer at same / different offsets).\r\n\r\nIf there are no plans for this near term, could we look at reverting the code-removal while we get a plan together? Currently we'll have to straddle behind releases or fork the project which is really unfortunate.",
    "comments": [
      {
        "id": "IC_kwDOENG448410_nO",
        "author": {
          "login": "hrydgard"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "I think there's a lot of confusion from multiple uses of the word bindless with different meanings. Flexible ByteAddressBuffer support  itself doesn't really have anything to do with bindless mode, does it? I wasn't aware they were part of the removal, in fact I had intended to file a feature request for them. ByteAddressBuffers can be useful regardless of how they are bound.\r\n\r\nWe'll discuss all these things more next week",
        "createdAt": "2021-08-21T08:48:48Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/733#issuecomment-903084494",
        "viewerDidAuthor": false
      },
      {
        "id": "IC_kwDOENG448411HSb",
        "author": {
          "login": "Jasper-Bekkers"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "> Flexible ByteAddressBuffer support itself doesn't really have anything to do with bindless mode, does it? \r\n\r\nNot really - however all of that code got axed as well. It was as-implemented tied into the way buffers are bound simply to figure out which BAB was supposed to be indexed into in the bindless table. However, without it we can't set up the bindless system for buffers in a sensible way - if it's not there we need the equivalent of a StructuredBuffer bound /for each buffer/ which quickly becomes really painful.",
        "createdAt": "2021-08-21T13:22:51Z",
        "includesCreatedEdit": true,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/733#issuecomment-903115931",
        "viewerDidAuthor": false
      },
      {
        "id": "IC_kwDOENG448412tZ3",
        "author": {
          "login": "repi"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "Let's discuss in person now soon and follow up, that is the easiest and best.",
        "createdAt": "2021-08-23T08:02:47Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/733#issuecomment-903534199",
        "viewerDidAuthor": false
      }
    ],
    "createdAt": "2021-08-20T22:42:07Z",
    "labels": [
      {
        "id": "MDU6TGFiZWwyMjI3MzM4ODEz",
        "name": "t: bug",
        "description": "Something isn't working",
        "color": "52E8A0"
      }
    ],
    "number": 733,
    "reactionGroups": [
      {
        "content": "EYES",
        "users": {
          "totalCount": 1
        }
      }
    ],
    "state": "OPEN",
    "title": "Bindless support clarification",
    "url": "https://github.com/EmbarkStudios/rust-gpu/issues/733"
  },
  {
    "author": {
      "id": "MDQ6VXNlcjk1MzE1MQ==",
      "is_bot": false,
      "login": "khyperia",
      "name": "Ashley Hauck"
    },
    "body": "[See the vulkan spec](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#spirvenv-capabilities)\r\n\r\nFor example, when compiling for vulkan1.0 or higher, `OpCapability ImageQuery` should be included by default.",
    "comments": [
      {
        "id": "IC_kwDOENG4485YvEoI",
        "author": {
          "login": "eddyb"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "Better link: https://registry.khronos.org/vulkan/specs/1.3-extensions/html/chap50.html#spirvenv-capabilities.\n\nThere's similarly also extensions, like `SPV_KHR_16bit_storage` for 1.1, and `SPV_KHR_8bit_storage` for 1.2.\n(note that those don't imply anything by themselves, they just allow requesting certain new capabilities)",
        "createdAt": "2023-03-29T14:28:35Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/725#issuecomment-1488734728",
        "viewerDidAuthor": false
      }
    ],
    "createdAt": "2021-08-18T07:19:44Z",
    "labels": [
      {
        "id": "MDU6TGFiZWwyMjI3MzM4ODE2",
        "name": "t: enhancement",
        "description": "A new feature or improvement to an existing one.",
        "color": "52E8A0"
      }
    ],
    "number": 725,
    "reactionGroups": [],
    "state": "OPEN",
    "title": "When compiling for vulkan, the default capabilities for the vulkan version should be enabled",
    "url": "https://github.com/EmbarkStudios/rust-gpu/issues/725"
  },
  {
    "author": {
      "id": "MDQ6VXNlcjc0MTgwNw==",
      "is_bot": false,
      "login": "dvc94ch",
      "name": "David Craven"
    },
    "body": "These are things that I keep getting hung up on. It is clear how gdb/perf work for example, by using the ptrace/open_perf_event syscalls in the linux kernel. However when it comes to gpu programming there seems to be few tools that aren't vendor specific and it is completely unclear how they work to a non-gpu expert. To open up gpu programming to a larger audience, how to perform debugging/profiling tasks should be documented better.\r\n\r\nI presume there is some sort of synchronizing primitive in vulkan that could be used for debugging to step through the code, but how would you sample the gpu stack for example?",
    "comments": [
      {
        "id": "IC_kwDOENG44849hr2N",
        "author": {
          "login": "follower"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "### Tool 1: Renderdoc\r\n\r\nIn case it's helpful, I'll mention that I've recently (again) found [Renderdoc](https://renderdoc.org) to be helpful with regard to debugging--in my case, specifically in relation to Vulkan Compute shaders.\r\n\r\nIt supports multiple platforms & multiple APIs: https://github.com/baldurk/renderdoc/blob/v1.x/README.md#api-support\r\n\r\nThe home page also specifically mentions a focus on usability:\r\n\r\n> Usability Focus\r\n>\r\n> Usability matters. Tools should have a low barrier to entry and be easy to use and understand.\r\n>  RenderDoc makes the process of getting started as smooth as possible, and simplifies common workflows.\r\n\r\nOne useful starting point is probably the [Window (i.e. UI) reference](https://renderdoc.org/docs/window/index.html)\r\n\r\nApparently the Vulkan Compute shader debugging support is \"experimental\" but I found it useful when trying to understand some unexpected behaviour & could e.g. single-step & live edit/reload: https://renderdoc.org/docs/how/how_debug_shader.html#debugging-a-compute-thread\r\n\r\n### Tool 2: `printf`\r\n\r\nAlso, Renderdoc supports the e.g. [Vulkan \"debug `printf`\" functionality](https://renderdoc.org/docs/window/shader_messages.html#adding-shader-prints) and one thing that wasn't obvious is that it can even provide `printf` support even if the underlying driver/GPU doesn't support all the extensions which the Vulkan Validation layers `printf` version requires. (Because Renderdoc has its own implementation.)\r\n\r\nThe Renderdoc documentation also makes reference to performance counters, callstacks & timeline/timing.\r\n\r\nAnd while Renderdoc provides a tool-focused approach to problem solving initially, I imagine the source code would also go some way to showing you how it interacts with the GPU in order to do so.\r\n\r\n### Tool 3: Vulkan Layers, especially Validation\r\n\r\nAs a general Vulkan observation, my impression is that there's a focus on the use of their \"layers\" architecture to provide necessary debugging support, e.g. for Validation, performance or other properties and insight into what is happening on the GPU, via various layers configured e.g. via the Vulkan SDK's `vkconfig` GUI: https://github.com/LunarG/VulkanTools/blob/a7ab1708549a11bbff3eddc0d70d63859ca93948/vkconfig/README.md#using-the-vulkan-configurator\r\n\r\n### Tool 4: Vulkan \"debug utils\" extension\r\n\r\nAnd, then, building on that, an approach of encouraging use of their more recent \"debug utils\" extension by applications in order to annotate objects & automatically \"mark\" progress through various pipelines, e.g. see PDF linked from: https://www.lunarg.com/new-tutorial-for-vulkan-debug-utilities-extension/\r\n\r\nAlthough also, based on their ecosystem survey analysis it does seem like Vulkan/Khronos/LunarG do acknowledge there's a lot more that could be done to make Vulkan development more accessible.\r\n\r\n### Wrapping up\r\n\r\nAnyway, I've read far too much about all this over the past couple of days, so hopefully there's something useful in these pointers for someone. :D\r\n\r\nDefinitely check out Renderdoc if you haven't already though--it can display debugging information in many pretty colours. :)",
        "createdAt": "2022-02-08T05:55:17Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "users": {
              "totalCount": 3
            }
          }
        ],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/578#issuecomment-1032240525",
        "viewerDidAuthor": false
      }
    ],
    "createdAt": "2021-04-05T21:18:54Z",
    "labels": [
      {
        "id": "MDU6TGFiZWwyMjI3MzM4ODE0",
        "name": "a: documentation",
        "description": "Improvements or additions to documentation",
        "color": "FCA492"
      },
      {
        "id": "MDU6TGFiZWwyMjI3MzM4ODE2",
        "name": "t: enhancement",
        "description": "A new feature or improvement to an existing one.",
        "color": "52E8A0"
      }
    ],
    "number": 578,
    "reactionGroups": [
      {
        "content": "THUMBS_UP",
        "users": {
          "totalCount": 2
        }
      }
    ],
    "state": "OPEN",
    "title": "Document best practices for debugging/profiling.",
    "url": "https://github.com/EmbarkStudios/rust-gpu/issues/578"
  },
  {
    "author": {
      "id": "MDQ6VXNlcjc3NDI0",
      "is_bot": false,
      "login": "eddyb",
      "name": "Eduard-Mihai Burtescu"
    },
    "body": "Sadly, it's hard/impossible to account for `#[cfg]`s in e.g. `glam`, and vector types in general tend to have weirder alignment rules than scalars (and aggregates thereof).\r\n\r\nBut we should at the very least require `#[repr(C)]`, and maybe even disallow any interior padding or wildly varying alignments (as that would imply potentially different alignments on the host).\r\n\r\nI almost wish Rust had explicit field offsets with a per-field attribute - we could require that to guarantee that the host would see the same layout *and* it would let us have the weirder layouts mentioned in #11.",
    "comments": [
      {
        "id": "MDEyOklzc3VlQ29tbWVudDgxMzg3NTM4Ng==",
        "author": {
          "login": "eddyb"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "One way we could avoid the limitations around Rust not having custom layouts, is requiring `#[repr(C, packed)]` - that way, there is no interior padding between fields, and if needed we could force the user to insert explicit unused fields to make it compatible with e.g. `std140`/`std430`/etc.\r\n\r\n**EDIT**: I should note that `#[repr(C, packed(4))]` works and unlike plain `packed`, allows taking references to fields (for fields of a type that itself requires an alignment of `4` or less). I should probably look into all of the possible SPIR-V layout rules to find which ones that matches up to.",
        "createdAt": "2021-04-06T06:56:55Z",
        "includesCreatedEdit": true,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "users": {
              "totalCount": 1
            }
          }
        ],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/575#issuecomment-813875386",
        "viewerDidAuthor": false
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDgyNTEwMjA4NA==",
        "author": {
          "login": "hrydgard"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "usize should also be banned in structs - easy mistake to make and end up with 64 bits on the host, and 32 bits in the shader.",
        "createdAt": "2021-04-22T18:53:02Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/575#issuecomment-825102084",
        "viewerDidAuthor": false
      },
      {
        "id": "IC_kwDOENG448497Sbq",
        "author": {
          "login": "eddyb"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "We could probably use the JSON output we have nowadays to reflect all types used in the interface, so that we can either generate appropriate Rust types, or validate (via compile-time `assert!`s) that the definitions used on the host end up with the same field offsets, compatible field types, etc.",
        "createdAt": "2022-02-14T11:06:59Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/575#issuecomment-1038952170",
        "viewerDidAuthor": false
      },
      {
        "id": "IC_kwDOENG448499ZdR",
        "author": {
          "login": "repi"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "@eddyb oh that sounds like an interesting idea, really do want some static validation / enforcement of these type of layout rules both for shader types and also we sees similar problems in our native and WASM code, so easy to miss a `repr(C)` and other things. @termhn been exploring this in native land and with `bytemuck`, our own experiments and such crates also. \r\n\r\ncould have specific solutions for the GPU shaders but feels like a larger shared problem here also",
        "createdAt": "2022-02-14T20:08:31Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/575#issuecomment-1039505233",
        "viewerDidAuthor": false
      },
      {
        "id": "IC_kwDOENG4484992nO",
        "author": {
          "login": "fu5ha"
        },
        "authorAssociation": "MEMBER",
        "body": "Yeah, generating or validating Rust structs would be really cool. Indeed easy to miss a #repr(C) and spend a whole day debugging why the data isn't getting to the shader right (ask me how I know...)",
        "createdAt": "2022-02-14T22:14:16Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [
          {
            "content": "HEART",
            "users": {
              "totalCount": 1
            }
          }
        ],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/575#issuecomment-1039624654",
        "viewerDidAuthor": false
      },
      {
        "id": "IC_kwDOENG4484994O5",
        "author": {
          "login": "repi"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "Wish `repr(C)` automatically provided a marker trait to the type so generic code could require it. Well that and a `repr(C)` that required recursively that all fields and their types also was `repr(C)`.\r\n\r\nNot sure if anything like that could be feasible? ",
        "createdAt": "2022-02-14T22:21:59Z",
        "includesCreatedEdit": true,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/575#issuecomment-1039631289",
        "viewerDidAuthor": false
      },
      {
        "id": "IC_kwDOENG4485VB10w",
        "author": {
          "login": "schell"
        },
        "authorAssociation": "NONE",
        "body": "I just ran into this problem with `glam::Vec3`. I didn't realize that its layout is 16bytes on GPU, but 12 on CPU.",
        "createdAt": "2023-02-11T01:01:28Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/575#issuecomment-1426545968",
        "viewerDidAuthor": false
      },
      {
        "id": "IC_kwDOENG4485qmvmE",
        "author": {
          "login": "the-ssd"
        },
        "authorAssociation": "NONE",
        "body": "I have found a solution\r\n[crevice](https://crates.io/crates/crevice)\r\n\r\nexample:\r\ncommon/src/lib.rs\r\n```rust\r\n#![cfg_attr(target_arch = \"spirv\", no_std)]\r\n\r\nuse spirv_std::glam as glam;\r\nuse glam::{Vec3, UVec2, Vec4};\r\n\r\n#[repr(C)]\r\n#[derive(Copy, Clone)]\r\n#[cfg_attr(not(target_arch = \"spirv\"), derive(Debug, crevice::std430::AsStd430))]\r\npub struct Input {\r\n    pub camera_pos: Vec3,\r\n    pub camera_quat: Vec4, // no Quat :(\r\n    pub camera_fov: f32,\r\n\r\n    pub screen_size: UVec2,\r\n    pub time: f32,\r\n}\r\n```\r\ncommon/Cargo.toml\r\n```toml\r\n[target.'cfg(not(target_arch = \"spirv\"))'.dependencies]\r\ncrevice = { version = \"0.14\", features = [\"glam\"] }\r\n```\r\n\r\ncrevice implements as_std[430,140] with give structs with bytemuck pod and as_bytes",
        "createdAt": "2023-11-01T07:41:09Z",
        "includesCreatedEdit": true,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/575#issuecomment-1788541316",
        "viewerDidAuthor": false
      },
      {
        "id": "IC_kwDOENG4485qm6UX",
        "author": {
          "login": "eddyb"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "> crevice implements as_std[430,140] with give structs with bytemuck pod and as_bytes\r\n\r\nYes, some projects use such derives, but this is offtopic on this issue (which is about making it hard/impossible for the same definition to be interpreted differently) *and* there's no guarantee that the GPU-side layout of any type matches that crate you are using (in fact, you would want `FromStd430`, if it exists, GPU-side, but it likely does direct memory manipulation not yet supported in Rust-GPU).",
        "createdAt": "2023-11-01T08:24:19Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/575#issuecomment-1788585239",
        "viewerDidAuthor": false
      },
      {
        "id": "IC_kwDOENG4485wE0mD",
        "author": {
          "login": "eddyb"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "On the Discord we did find an interesting way to use `crevice`: instead of *only* using it on the CPU side, and just hoping Rust-GPU matches, you could do this instead:\r\n```rust\r\nuse crevice::std430::{AsStd430, Vec3};\r\n\r\n#[derive(AsStd430)]\r\npub struct __Light_HighLevel {\r\n    position: Vec3,\r\n    intensity: f32,\r\n    color: Vec3,\r\n}\r\ntype Light = <__Light_HighLevel as AsStd430>::Output;\r\n\r\npub fn shader(lights: &[Light]) {\r\n    for i in 0..lights.len() {\r\n        let Light { position, intensity, color, .. } = lights[i];\r\n        let _x = position.x + intensity + color.x;\r\n    }\r\n}\r\n```\r\n\r\n(`Vec3` in particular tends to be annoying to support cleanly, but this way you could rely on `crevice` generating a `repr(C)` type that should have the same layout, on all targets)",
        "createdAt": "2024-01-08T02:38:30Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [
          {
            "content": "HEART",
            "users": {
              "totalCount": 2
            }
          }
        ],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/575#issuecomment-1880312195",
        "viewerDidAuthor": false
      },
      {
        "id": "IC_kwDOENG44854WR-3",
        "author": {
          "login": "LegNeato"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "What if `rust-gpu` used `serde`'s types & macro as it's interface for specifying \"this needs to be the same across CPU and GPU\" and use the method/format an implementation detail? The compiler would then know the exact way the type serializes to the serde/rust datamodel and can under the hood use something like`crevice` as a serde output format. Or you could introduce a `#[derive(SendGpu)]` and `#[derive(SendCpu)` which would act like the serde traits under the hood if you want less magic.",
        "createdAt": "2024-03-25T23:35:48Z",
        "includesCreatedEdit": true,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/575#issuecomment-2019106743",
        "viewerDidAuthor": false
      },
      {
        "id": "IC_kwDOENG44854dtAY",
        "author": {
          "login": "schell"
        },
        "authorAssociation": "NONE",
        "body": "@LegNeato that sounds a lot like what [crabslab](https://github.com/schell/crabslab) does, though crabslab stores and reads that data from an explicit buffer of `&[u32]`.",
        "createdAt": "2024-03-26T17:26:56Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "users": {
              "totalCount": 2
            }
          }
        ],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/575#issuecomment-2021052440",
        "viewerDidAuthor": false
      },
      {
        "id": "IC_kwDOENG44854e3z1",
        "author": {
          "login": "LegNeato"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "Yeah, I guess there are two target users here: those that want to control how things are padded / sent to the GPU explicitly, and those that just want it sent \"over the bridge\" and don't care how.",
        "createdAt": "2024-03-26T20:02:27Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "users": {
              "totalCount": 3
            }
          }
        ],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/575#issuecomment-2021358837",
        "viewerDidAuthor": false
      }
    ],
    "createdAt": "2021-04-05T07:04:27Z",
    "labels": [
      {
        "id": "MDU6TGFiZWwyMjI3MzM4ODE2",
        "name": "t: enhancement",
        "description": "A new feature or improvement to an existing one.",
        "color": "52E8A0"
      },
      {
        "id": "MDU6TGFiZWwyNDM3NjYwNTcw",
        "name": "c: rustc_codegen_spirv",
        "description": "Issues specific to the rustc_codegen_spirv crate.",
        "color": "006b75"
      }
    ],
    "number": 575,
    "reactionGroups": [
      {
        "content": "THUMBS_UP",
        "users": {
          "totalCount": 3
        }
      }
    ],
    "state": "OPEN",
    "title": "We should ensure entry interface types have reliable layout.",
    "url": "https://github.com/EmbarkStudios/rust-gpu/issues/575"
  },
  {
    "author": {
      "id": "MDQ6VXNlcjcyNTM4NDU=",
      "is_bot": false,
      "login": "msiglreith",
      "name": "Markus Siglreithmaier"
    },
    "body": "```rust\r\nconst QUAD_CLIP: [f32x2; 4] = [\r\n    f32x2 { x: -1.0, y: -1.0 },\r\n    f32x2 { x: 1.0, y: -1.0 },\r\n    f32x2 { x: -1.0, y: 1.0 },\r\n    f32x2 { x: 1.0, y: 1.0 },\r\n];\r\n\r\n#[spirv(vertex)]\r\npub fn quad_vs(#[spirv(vertex_id)] vert_id: i32, #[spirv(position)] a_position: &mut f32x4) {\r\n    let idx = vert_id as usize;\r\n    let pos_clip = QUAD_CLIP[idx];\r\n    *a_position = vec4(pos_clip.x, pos_clip.y, idx as f32, 1.0);\r\n}\r\n```\r\n\r\n`QUAD_CLIP` type will be generated with an `ArrayStride` of 8 which is incorrect as in this case all array elements should be treated as vec4 types, requiring a stride of 16.\r\n\r\nGenerated:\r\n```\r\nOpDecorate %_arr_v2float_uint_4 ArrayStride 8\r\n```\r\nExpected:\r\n```\r\nOpDecorate %_arr_v2float_uint_4 ArrayStride 16\r\n```\r\n",
    "comments": [
      {
        "id": "MDEyOklzc3VlQ29tbWVudDgxMTUxMDkyMQ==",
        "author": {
          "login": "msiglreith"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "maybe the decoration should be even removed because I don't recall if the stride is defined at all if not part of the shader resource interface..",
        "createdAt": "2021-03-31T22:36:53Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/573#issuecomment-811510921",
        "viewerDidAuthor": false
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDgxMTY3OTA4Mw==",
        "author": {
          "login": "hrydgard"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "Right - in a uniform buffer with no layout extensions, and thus std140 layout, the stride should be 16, and in a storage buffer with 430 layout, 8. For a plain array like that, it seems kinda arbitrary..",
        "createdAt": "2021-04-01T06:31:29Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/573#issuecomment-811679083",
        "viewerDidAuthor": false
      },
      {
        "id": "IC_kwDOENG4485YuX9G",
        "author": {
          "login": "eddyb"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "> in a uniform buffer with no layout extensions\r\n\r\n`QUAD_CLIP` is not an UBO here, so I'm confused why the mention.\r\n\r\n> `QUAD_CLIP` type will be generated with an `ArrayStride` of 8 which is incorrect as in this case all array elements should be treated as vec4 types, requiring a stride of 16.\r\n\r\nWhy should they be treated as such? The only rules I know of that have those requirements are for UBOs/SSBOs, and even there it's an archaic mess that I should we should paper over (e.g. if you had that `[f32x2; 4]` in an UBO, long-term we should probably turn that into a `[f32x4; 2]` for you, to maximize compatibility with the scalar layout which is the only thing you can easily automate on the CPU side).\r\n\r\nAre you getting an error from anything? Like a validation error that prompted this?\r\n\r\n**EDIT**: [according to the Vulkan spec](https://registry.khronos.org/vulkan/specs/1.3-extensions/html/chap15.html#interfaces-resources-layout):\r\n> If the `uniformBufferStandardLayout` feature is not enabled on the device, then any member of an `OpTypeStruct` with a storage class of `Uniform` and a decoration of `Block` must be aligned according to its extended alignment.\r\n\r\nUnsure which combination opts into that on the `spirv-val` side but I suspect [`SpirvBuilder::uniform_buffer_standard_layout`](https://embarkstudios.github.io/rust-gpu/api/spirv_builder/struct.SpirvBuilder.html#method.uniform_buffer_standard_layout) might do it?",
        "createdAt": "2023-03-29T12:54:59Z",
        "includesCreatedEdit": true,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/573#issuecomment-1488551750",
        "viewerDidAuthor": false
      },
      {
        "id": "IC_kwDOENG4485YueZy",
        "author": {
          "login": "oisyn"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "For sake of completeness, I altered your example somewhat to use glam and appropriate syntax:\n\n```rust\n#[spirv(vertex)]\npub fn quad_vs(\n    #[spirv(vertex_index)] vert_id: i32,\n    #[spirv(uniform, descriptor_set = 0, binding = 0)] clip: &[Vec2; 4],\n    #[spirv(position)] a_position: &mut Vec4,\n) {\n    let idx = vert_id as usize;\n    let pos_clip = clip[idx];\n    *a_position = Vec4::new(pos_clip.x, pos_clip.y, idx as f32, 1.0);\n}\n```\n\nAnd I get this error\n```\n  error: Structure id 10 decorated as Block for variable in Uniform storage class must follow relaxed uniform buffer layout rules: member 0 contains an array with stride 8 not satisfying alignment to 16\n           %_struct_10 = OpTypeStruct %_arr_v2float_uint_4\n```\n\nSo at least it throws an error when using an incorrect alignment for uniform buffers.",
        "createdAt": "2023-03-29T13:08:19Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/573#issuecomment-1488578162",
        "viewerDidAuthor": false
      }
    ],
    "createdAt": "2021-03-31T18:36:48Z",
    "labels": [
      {
        "id": "MDU6TGFiZWwyMjI3MzM4ODEz",
        "name": "t: bug",
        "description": "Something isn't working",
        "color": "52E8A0"
      },
      {
        "id": "MDU6TGFiZWwyNDM3NjYwNTcw",
        "name": "c: rustc_codegen_spirv",
        "description": "Issues specific to the rustc_codegen_spirv crate.",
        "color": "006b75"
      },
      {
        "id": "LA_kwDOENG4488AAAABPXHqow",
        "name": "s: qptr may fix",
        "description": "This might be fixed by the \"qptr\" experiment (https://github.com/EmbarkStudios/spirt/pull/24)",
        "color": "CCCCCC"
      }
    ],
    "number": 573,
    "reactionGroups": [],
    "state": "OPEN",
    "title": "Incorrect array stride for arrays of vector types",
    "url": "https://github.com/EmbarkStudios/rust-gpu/issues/573"
  },
  {
    "author": {
      "id": "MDQ6VXNlcjQ0NjQyOTU=",
      "is_bot": false,
      "login": "XAMPPRocky",
      "name": ""
    },
    "body": "With recent changes to how we specify the storage class of a variable, we've managed to eliminate the need for a few of the storage class attributes in cases where we can successfully infer all possible valid uses. Mainly the `input`, `output`, `private`, `function`, `generic`, and `uniform_constant` attributes at the time of this writing are no longer needed and should be removed now that they can't be used for anything useful.",
    "comments": [
      {
        "id": "IC_kwDOENG44846S_dz",
        "author": {
          "login": "andrewleverette"
        },
        "authorAssociation": "NONE",
        "body": "I would be happy to work on this. I've found the type and have removed the specified variants. I'm curious how you would want to handle cases where the variants are used. In some cases where they are used for error handling, I think those checks can just be removed. But a case that isn't as clear is handling cases that are dependent on module version like this:\r\n\r\n***/rustc_codegen_spriv/src/linker/entry_interface.rs***\r\n```rust\r\n        // Base case: the global itself is an interface-relevant `OpVariable`.\r\n        let interface_relevant_var = inst.class.opcode == Op::Variable && {\r\n            if version > (1, 3) {\r\n                // SPIR-V >= v1.4 includes all OpVariables in the interface.\r\n                true\r\n            } else {\r\n                let storage_class = inst.operands[0].unwrap_storage_class();\r\n                // SPIR-V <= v1.3 only includes Input and Output in the interface.\r\n                storage_class == StorageClass::Input || storage_class == StorageClass::Output\r\n            }\r\n        };\r\n```\r\n\r\nShould the else case just return false? Or is there some other logic that should be added here?\r\n\r\nAnother case is when a default is used like here:\r\n***rustc_codegen_spriv/src/codegen_cx/entry.rs***\r\n```rust\r\n        // If storage class was not inferred nor specified, compute the default (i.e. input/output)\r\n        let storage_class = inferred_storage_class_from_ty\r\n            .or(attr_storage_class)\r\n            .unwrap_or_else(|| match (is_ref, mutbl) {\r\n                (false, _) => StorageClass::Input,\r\n                (true, hir::Mutability::Mut) => StorageClass::Output,\r\n                (true, hir::Mutability::Not) => self.tcx.sess.span_fatal(\r\n                    hir_param.ty_span,\r\n                    &format!(\r\n                        \"invalid entry param type `{}` (expected `{}` or `&mut {1}`)\",\r\n                        layout.ty, value_ty\r\n                    ),\r\n                ),\r\n            });\r\n```\r\nShould this just call the `span_fatal` if the storage calls was not inferred?",
        "createdAt": "2021-11-24T16:54:47Z",
        "includesCreatedEdit": true,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/568#issuecomment-978057075",
        "viewerDidAuthor": false
      },
      {
        "id": "IC_kwDOENG44846TLXn",
        "author": {
          "login": "msiglreith"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "@andrewleverette I think this only refers to the `#spirv(..)` attributes which can be explicitly specified by the user and not the storage classes as a whole as they are still needed (just inferred by compiler).\r\nhttps://github.com/EmbarkStudios/rust-gpu/blob/d789b58b2e3f57bdd1cfc30ae4fed98e736b9577/crates/rustc_codegen_spirv/src/symbols.rs#L138-L165",
        "createdAt": "2021-11-24T17:59:33Z",
        "includesCreatedEdit": true,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/568#issuecomment-978105831",
        "viewerDidAuthor": false
      },
      {
        "id": "IC_kwDOENG44846TM5u",
        "author": {
          "login": "andrewleverette"
        },
        "authorAssociation": "NONE",
        "body": "Okay so sorry if this is a dumb question, but is this issue literally just removing those specified attributes from `STORAGE_CLASSES`?",
        "createdAt": "2021-11-24T18:08:18Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/568#issuecomment-978112110",
        "viewerDidAuthor": false
      },
      {
        "id": "IC_kwDOENG44846TRaP",
        "author": {
          "login": "andrewleverette"
        },
        "authorAssociation": "NONE",
        "body": "I think the linked pull request will resolve this issue. I'm still new to open source, so I'm definitely open to any feedback.",
        "createdAt": "2021-11-24T18:36:20Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/568#issuecomment-978130575",
        "viewerDidAuthor": false
      }
    ],
    "createdAt": "2021-03-31T11:43:53Z",
    "labels": [
      {
        "id": "MDU6TGFiZWwyMjI3MzM4ODE2",
        "name": "t: enhancement",
        "description": "A new feature or improvement to an existing one.",
        "color": "52E8A0"
      },
      {
        "id": "MDU6TGFiZWwyMjI3MzM4ODE3",
        "name": "t: good first issue",
        "description": "Good for newcomers",
        "color": "52E8A0"
      }
    ],
    "number": 568,
    "reactionGroups": [],
    "state": "OPEN",
    "title": "Remove unneeded Storage Class attributes",
    "url": "https://github.com/EmbarkStudios/rust-gpu/issues/568"
  },
  {
    "author": {
      "id": "MDQ6VXNlcjk1MzE1MQ==",
      "is_bot": false,
      "login": "khyperia",
      "name": "Ashley Hauck"
    },
    "body": "We're currently really inconsistent with our diagnostics style, e.g. some start with uppercase, some lowercase. We should change them to match rustc's style (casing, language style, etc.).",
    "comments": [
      {
        "id": "MDEyOklzc3VlQ29tbWVudDgyNjQyMzQ2MQ==",
        "author": {
          "login": "TuckerBMorgan"
        },
        "authorAssociation": "NONE",
        "body": "Hey taking a look at this, looking at the rust source code, and style guides, is a specific document that you had in mind that you wanted followed? ",
        "createdAt": "2021-04-26T00:21:31Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/565#issuecomment-826423461",
        "viewerDidAuthor": false
      }
    ],
    "createdAt": "2021-03-31T11:15:30Z",
    "labels": [
      {
        "id": "MDU6TGFiZWwyMjI3MzM4ODE2",
        "name": "t: enhancement",
        "description": "A new feature or improvement to an existing one.",
        "color": "52E8A0"
      },
      {
        "id": "MDU6TGFiZWwyNDk3MTIzNDIw",
        "name": "a: error messages",
        "description": "Issues specific to error messages",
        "color": "FCA492"
      }
    ],
    "number": 565,
    "reactionGroups": [],
    "state": "OPEN",
    "title": "Normalize compiler diagnostic messages",
    "url": "https://github.com/EmbarkStudios/rust-gpu/issues/565"
  },
  {
    "author": {
      "id": "MDQ6VXNlcjc3NDI0",
      "is_bot": false,
      "login": "eddyb",
      "name": "Eduard-Mihai Burtescu"
    },
    "body": "See #546 for some context and ideas - especially https://github.com/EmbarkStudios/rust-gpu/pull/546#issuecomment-809089160.\r\n\r\nSadly, this is likely blocked on moving CI to use `--release` to build examples (which depend on \"build dependency release mode `rustc_codegen_spirv` via the `spirv-builder`-using build scripts), otherwise the problem can't be reproduced in the first place (AFAIK).",
    "comments": [
      {
        "id": "IC_kwDOENG4485OfAM-",
        "author": {
          "login": "oisyn"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "Superseded by #911",
        "createdAt": "2022-11-16T10:20:34Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/549#issuecomment-1316750142",
        "viewerDidAuthor": false
      },
      {
        "id": "IC_kwDOENG4485O_tue",
        "author": {
          "login": "eddyb"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "Reopened because I think it's orthogonal to #911: we should find a way to detect redundant builds on CI *regardless* of what those build steps do internally.\r\n\r\nWorst case this looks like checking that `Compiling rustc_codegen_spirv` appears only once in the build logs (though build script stdout/stderr is hidden by default so it would have to search in `target/**/build/**/std{out,err}` too).\r\n\r\nMaybe all we need is a `RUSTC_WRAPPER` that adds the command to a \"log file\" and then we can check that e.g. `--crate-name rustc_codegen_spirv` appears only once (we'd have to make sure this gets propagated to build scripts tho).",
        "createdAt": "2022-11-23T16:14:48Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/549#issuecomment-1325325214",
        "viewerDidAuthor": false
      }
    ],
    "createdAt": "2021-03-29T07:28:00Z",
    "labels": [
      {
        "id": "MDU6TGFiZWwyMjI3MzM4ODE2",
        "name": "t: enhancement",
        "description": "A new feature or improvement to an existing one.",
        "color": "52E8A0"
      },
      {
        "id": "MDU6TGFiZWwyNDM3NzE1NTI3",
        "name": "c: meta",
        "description": "Issues specific to the GitHub repository. README, CI, etc.",
        "color": "006b75"
      },
      {
        "id": "MDU6TGFiZWwyNDQ4NzM0MTE1",
        "name": "a: test",
        "description": "Issues around testing rust-gpu.",
        "color": "FCA492"
      }
    ],
    "number": 549,
    "reactionGroups": [],
    "state": "OPEN",
    "title": "CI should check that we don't build `rustc_codegen_spirv` more than once.",
    "url": "https://github.com/EmbarkStudios/rust-gpu/issues/549"
  },
  {
    "author": {
      "id": "MDQ6VXNlcjQ0NjQyOTU=",
      "is_bot": false,
      "login": "XAMPPRocky",
      "name": ""
    },
    "body": "If you pass a reference to malformed instruction, it will cause the compiler to panic, when it should fail just fail to compile.\r\n\r\n### Rust\r\n\r\n```rust\r\n#[spirv(fragment)]\r\npub fn foo() {\r\n    asm! {\r\n        \"%u32 = OpTypeInte 32 0\",\r\n        \"%zero = OpConstant %u32 0\",\r\n}\r\n```\r\n\r\n### Error\r\n```\r\nerror: unknown spirv instruction OpTypeInte\r\n  --> /Users/erin.power/src/rust-gpu2/crates/spirv-std/src/arch/barrier.rs:5:5\r\n   |\r\n5  | /     asm! {\r\n6  | |         \"%u32 = OpTypeInte 32 0\",\r\n7  | |         \"%execution = OpConstant %u32 {execution}\",\r\n8  | |         // \"%memory = OpConstant %u32 {memory}\",\r\n...  |\r\n13 | |         // semantics = const SEMANTICS as u8,\r\n14 | |     }\r\n   | |_____^\r\n\r\nthread 'rustc' panicked at 'Tried to lookup value that wasn't a type, or has no definition', crates/rustc_codegen_spirv/src/spirv_type.rs:674:14\r\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\r\n\r\nerror: internal compiler error: unexpected panic\r\n```",
    "comments": [],
    "createdAt": "2021-03-22T07:37:30Z",
    "labels": [
      {
        "id": "MDU6TGFiZWwyMjI3MzM4ODEz",
        "name": "t: bug",
        "description": "Something isn't working",
        "color": "52E8A0"
      },
      {
        "id": "MDU6TGFiZWwyNDc5OTIzNDA4",
        "name": "a: ice",
        "description": "Issues about internal compiler errors",
        "color": "FCA492"
      },
      {
        "id": "MDU6TGFiZWwyNDk3MTIzNDIw",
        "name": "a: error messages",
        "description": "Issues specific to error messages",
        "color": "FCA492"
      },
      {
        "id": "MDU6TGFiZWwyODM2NzIzNzE1",
        "name": "a: asm",
        "description": "Issues related to inline assembly.",
        "color": "FCA492"
      }
    ],
    "number": 518,
    "reactionGroups": [],
    "state": "OPEN",
    "title": "asm reference to non-existent value causes ICE",
    "url": "https://github.com/EmbarkStudios/rust-gpu/issues/518"
  },
  {
    "author": {
      "id": "MDQ6VXNlcjk1MzE1MQ==",
      "is_bot": false,
      "login": "khyperia",
      "name": "Ashley Hauck"
    },
    "body": "Storage class inference is now a thing as of #300/#414. This details the design for the interface system taking advantage of inference, pointing out all the rules of how storage classes are specified in entry points.\r\n\r\nThere are a handful of ways of specifying a storage class:\r\n\r\n1) direct attribute: `fn main(#[spirv(input)] x: &f32)`. This uses the current list of storage classes.\r\n2) via builtin: `fn main(#[spirv(position)] x: &Vector3)` (inferred as input). This uses the current list of builtins (a table is needed to map builtin to storage class, I think some are input, some are output, and there may be others)\r\n3) via image: `fn main(x: &Image2d)` (inferred as uniform_constant). I thiiink images are always uniform_constant and not uniform, but I'm not sure.\r\n4) unspecified future inference rules that we haven't discovered yet (the spec is light on what goes in what storage class), suggestions are welcome\r\n\r\nIf exactly one of these rules matches, then use the storage class it specifies.\r\n\r\nIf more than one of these rules matches, and they all compute the same storage class, emit a warning (e.g. `#[spirv(position, input)]`, warn on `input` and say it's redundant). If more than one of these rules matches, and they compute different storage classes, emit an **error**.\r\n\r\nIf none of these rules matches, then we have an open design question. The options here are a trade-off between catching user errors that may be difficult to diagnose/guiding users with explicit syntax suggestions, and not annoying people with overly explicit syntax that takes a while to type out and read.\r\n\r\n1) `fn main(x: &f32)` -> is this an error, or does it default to `input`? (or something else)\r\n2) `fn main(x: &Struct)` -> is this an error, does it default to `input`, or does it default to `uniform`? (or something else)\r\n3) `fn main(x: &mut f32)` -> is this an error, or does it default to `output`? (or something else)\r\n\r\nFor 2, I don't know if it's valid to have a struct (or any other non-scalar) be an `input`/`output` variable, more research is needed.\r\n\r\n---\r\n\r\nAn alternative is to keep the current system of `Input<T>` and friends. We would *remove* the `.load()` and `.store()` methods entirely, and implement `Deref`/`DerefMut` (when applicable) for them. I much prefer the readability, recognizability, and usability of using plain references, but I understand others don't feel the same way~",
    "comments": [
      {
        "id": "MDEyOklzc3VlQ29tbWVudDc3NzUyNjUwNw==",
        "author": {
          "login": "eddyb"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "> via builtin: `fn main(#[spirv(position)] x: &Vector3)` (inferred as input). This uses the current list of builtins (a table is needed to map builtin to storage class, I think some are input, some are output, and there may be others)\r\n\r\nSome can be either, but I think the best default would be to picking input vs output based on the kind of reference, and use attributes to *override* that - we could also support outputs via returns, tho multiple/named outputs would require a `struct`.",
        "createdAt": "2021-02-11T14:53:59Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/416#issuecomment-777526507",
        "viewerDidAuthor": false
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDc3NzU5NjAyMw==",
        "author": {
          "login": "eddyb"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "For Vulkan 1.2, if anyone is curious, the valid Storage Classes for each builtin are listed here:\r\nhttps://www.khronos.org/registry/vulkan/specs/1.2/html/vkspec.html#interfaces-builtin-variables\r\n\r\nNot sure if the information is available in a machine-readable format (haven't checked yet), but Ctrl+F `Storage Class` can quickly highlight that each builtin varies with `Execution Model`, usually either `Input` or `Output`, but in some cases both are allowed.",
        "createdAt": "2021-02-11T15:53:29Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/416#issuecomment-777596023",
        "viewerDidAuthor": false
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDc3NzYwNzA1Mw==",
        "author": {
          "login": "Hentropy"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "How would a function like this be handled? Compiler error I guess?\r\n```Rust\r\nfn shader(#[spirv(input)] foo: &mut Vec4) {}\r\n```\r\n\r\nHow does the `SampleMask` builtin work? It can be either `Input` or `Output` into a frag shader, so will it always need to be specified? Maybe `Input` is a sensible default, and it only needs to be specified if you want `Output` (or vice versa)?\r\n\r\n`Output` is uninitialized, so reading before writing is bad.  How will this be prevented?\r\n\r\n\r\n(As you both know, I prefer a type based syntax for this because I think it's easier to read and write, more idiomatic, and will help with implementing safe CPU-GPU interop)",
        "createdAt": "2021-02-11T16:09:06Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/416#issuecomment-777607053",
        "viewerDidAuthor": false
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDc3NzYxMzE5MA==",
        "author": {
          "login": "eddyb"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "> `Output` is uninitialized, so reading before writing is bad. How will this be prevented?\r\n\r\nOh right, that's where I was suggesting `&mut MaybeUninit<T>` on Discord for `Output`.\r\n\r\nAlternatively, we could return the value from the entry-point - this gets more interesting with multiple outputs (which may be builtins so they would need a place to attach attributes to anyway) - probably be the best thing in that case is returning a `struct`.",
        "createdAt": "2021-02-11T16:17:58Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/416#issuecomment-777613190",
        "viewerDidAuthor": false
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDc3NzY1MTMzOQ==",
        "author": {
          "login": "XAMPPRocky"
        },
        "authorAssociation": "MEMBER",
        "body": "> Oh right, that's where I was suggesting &mut MaybeUninit<T> on Discord for Output.\r\n\r\nSmall note that, that is blocked on #415 ",
        "createdAt": "2021-02-11T17:13:54Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/416#issuecomment-777651339",
        "viewerDidAuthor": false
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDc3NzY1MzI1NA==",
        "author": {
          "login": "eddyb"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "Based on https://github.com/EmbarkStudios/rust-gpu/issues/415#issuecomment-777413450 I think we're fine - I doubt ZST inputs/outputs would be common, if at all supported by SPIR-V and/or Vulkan.",
        "createdAt": "2021-02-11T17:16:47Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/416#issuecomment-777653254",
        "viewerDidAuthor": false
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDc3NzY4MTU4NA==",
        "author": {
          "login": "msiglreith"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "> Alternatively, we could return the value from the entry-point - this gets more interesting with multiple outputs (which may be builtins so they would need a place to attach attributes to anyway) - probably be the best thing in that case is returning a struct.\r\n\r\nThis would be nice imo as it allows to default to `input` storage class for every parameter and `output` for the return type. (Feels also a bit nicer to write!)",
        "createdAt": "2021-02-11T18:01:38Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/416#issuecomment-777681584",
        "viewerDidAuthor": false
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDc4ODUyMTQzNQ==",
        "author": {
          "login": "Hentropy"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "How would descriptor indexing work?\r\n\r\n```rust\r\n#[spirv(uniform, descriptor_set = 0, binding = 0)] way_1: [&T],\r\n#[spirv(uniform, descriptor_set = 0, binding = 0)] way_2: &[T],\r\n#[spirv(uniform_array, descriptor_set = 0, binding = 0)] way_3: &T,\r\n#[spirv(uniform_array, descriptor_set = 0, binding = 0)] way_4: &[T],\r\n#[spirv(uniform_array, descriptor_set = 0, binding = 0)] way_5: &[&T],\r\n```\r\n`way_1` is not valid Rust, function parameters must be sized.\r\n`way_2` is ambiguous: is it a runtime descriptor array or a variably sized buffer?\r\n`way_3` does not require indexing before accessing the pointer.\r\n`way_4` requires `T: Sized` and makes the runtime descriptor array a fat pointer with an unknown size.\r\n`way_5` introduces an extra pointer that does not exist and makes the runtime descriptor array a fat pointer with an unknown size.\r\n\r\nDescriptor array bindings are created in Vulkan by specifying a count > 1 in [VkDescriptorSetLayoutBinding](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkDescriptorSetLayoutBinding.html).  Runtime descriptor array bindings additionally require the appropriate flag to be set in [VkDescriptorSetLayoutBindingFlagsCreateInfo](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkDescriptorSetLayoutBindingFlagsCreateInfo.html).",
        "createdAt": "2021-03-02T02:11:52Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/416#issuecomment-788521435",
        "viewerDidAuthor": false
      }
    ],
    "createdAt": "2021-02-11T13:41:36Z",
    "labels": [
      {
        "id": "MDU6TGFiZWwyNDQwMDc1MDU3",
        "name": "mcp: accepted",
        "description": "A major change to the compiler that has been accepted.",
        "color": "FBCA07"
      }
    ],
    "number": 416,
    "reactionGroups": [],
    "state": "OPEN",
    "title": "Move Output vars to return position (was: Storage class inference interface)",
    "url": "https://github.com/EmbarkStudios/rust-gpu/issues/416"
  },
  {
    "author": {
      "id": "MDQ6VXNlcjc3NDI0",
      "is_bot": false,
      "login": "eddyb",
      "name": "Eduard-Mihai Burtescu"
    },
    "body": "For #403 I changed the workspace `Cargo.toml`, but that didn't result in a rebuild of `sky-shader`, whereas something like this does cause a rebuild (of `example-runner-wgpu`, in this example):\r\n```toml\r\n[profile.dev.package.\"example-runner-wgpu\"]\r\nopt-level = 3\r\n```\r\n\r\nSo I think we need `spirv-builder` to get the workspace `Cargo.toml` (and `Cargo.lock`, I suppose) paths from `Cargo` somehow, and also list those out as \"rebuild if changed\".",
    "comments": [
      {
        "id": "IC_kwDOENG448467ehy",
        "author": {
          "login": "khyperia"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "Hm, thinking about this, is this something that should be fixed in rust-gpu, with manually finding the `Cargo.toml` somehow (or even more somehow, extracting from cargo), or something that cargo should do when ingesting rustc's `.d` file and outputting its custom cargo-mangled `.d` file? (the difference between `deps/compute_shader.d` and `libcompute_shader.d`) - if cargo automatically included the relevant files in its `.d` file, rust-gpu would \"just work\".",
        "createdAt": "2021-12-08T10:05:05Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/404#issuecomment-988670066",
        "viewerDidAuthor": false
      },
      {
        "id": "IC_kwDOENG4485Oe30L",
        "author": {
          "login": "oisyn"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "There currently is no example or test within rust-gpu that actually uses `spirv-builder`",
        "createdAt": "2022-11-16T09:55:01Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/404#issuecomment-1316715787",
        "viewerDidAuthor": false
      },
      {
        "id": "IC_kwDOENG4485PG1tl",
        "author": {
          "login": "eddyb"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "> that actually uses `spirv-builder`\r\n\r\nTo be clear, there is, but not *from a build script* (except for... Android and wasm, I think?)\r\n\r\nAnd that's because of the hot reloading feature. IMO we should do both: build them in the build script, and have hot reloading as an optional Cargo package feature, so people can know what they can ignore from the example, when they don't want to implement hot reloading themselves (and ideally all the logic that `ash` and `wgpu` examples want to share should be in one shared crate).",
        "createdAt": "2022-11-25T09:14:05Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/404#issuecomment-1327192933",
        "viewerDidAuthor": false
      }
    ],
    "createdAt": "2021-02-01T12:18:03Z",
    "labels": [
      {
        "id": "MDU6TGFiZWwyMjI3MzM4ODE2",
        "name": "t: enhancement",
        "description": "A new feature or improvement to an existing one.",
        "color": "52E8A0"
      },
      {
        "id": "LA_kwDOENG4488AAAABHkF3zA",
        "name": "s: needs update",
        "description": "This issue needs a follow up or investigation whether it still applies.",
        "color": "CCCCCC"
      }
    ],
    "number": 404,
    "reactionGroups": [],
    "state": "OPEN",
    "title": "spirv-builder should declare dependencies on Cargo.toml files.",
    "url": "https://github.com/EmbarkStudios/rust-gpu/issues/404"
  },
  {
    "author": {
      "id": "MDQ6VXNlcjQ5NTk0",
      "is_bot": false,
      "login": "Jasper-Bekkers",
      "name": "Jasper Bekkers"
    },
    "body": "Let's start off with the simplest hlsl shader I can more or less come up with to do bindless support, which I would like to port to rust-gpu.\r\n\r\nNotice that instead of ByteArrayBuffer here, for the full feature one should be able to have (RW)Texture2D and other types as well.\r\n\r\n```\r\nByteAddressBuffer g_byteAddressBuffer[] : register(t0, space3);\r\nRWByteAddressBuffer g_rwByteAddressBuffer[] : register(u0, space4);\r\n\r\n[numthreads(64, 1, 1)]\r\nvoid main(int threadId: SV_DispatchThreadID)\r\n{\r\n    g_rwByteAddressBuffer[0].Store(threadId, g_byteAddressBuffer[0].Load(threadId));\r\n}\r\n```\r\n\r\nEmitted SPIR-V from DXC:\r\n\r\n```\r\n; SPIR-V\r\n; Version: 1.0\r\n; Generator: Google spiregg; 0\r\n; Bound: 30\r\n; Schema: 0\r\n               OpCapability Shader\r\n               OpCapability RuntimeDescriptorArray\r\n               OpExtension \"SPV_EXT_descriptor_indexing\"\r\n               OpMemoryModel Logical GLSL450\r\n               OpEntryPoint GLCompute %main \"main\" %gl_GlobalInvocationID\r\n               OpExecutionMode %main LocalSize 64 1 1\r\n               OpSource HLSL 660\r\n               OpName %type_ByteAddressBuffer \"type.ByteAddressBuffer\"\r\n               OpName %g_byteAddressBuffer \"g_byteAddressBuffer\"\r\n               OpName %type_RWByteAddressBuffer \"type.RWByteAddressBuffer\"\r\n               OpName %g_rwByteAddressBuffer \"g_rwByteAddressBuffer\"\r\n               OpName %main \"main\"\r\n               OpDecorate %gl_GlobalInvocationID BuiltIn GlobalInvocationId\r\n               OpDecorate %g_byteAddressBuffer DescriptorSet 3\r\n               OpDecorate %g_byteAddressBuffer Binding 0\r\n               OpDecorate %g_rwByteAddressBuffer DescriptorSet 4\r\n               OpDecorate %g_rwByteAddressBuffer Binding 0\r\n               OpDecorate %_runtimearr_uint ArrayStride 4\r\n               OpMemberDecorate %type_ByteAddressBuffer 0 Offset 0\r\n               OpMemberDecorate %type_ByteAddressBuffer 0 NonWritable\r\n               OpDecorate %type_ByteAddressBuffer BufferBlock\r\n               OpMemberDecorate %type_RWByteAddressBuffer 0 Offset 0\r\n               OpDecorate %type_RWByteAddressBuffer BufferBlock\r\n        %int = OpTypeInt 32 1\r\n      %int_0 = OpConstant %int 0\r\n       %uint = OpTypeInt 32 0\r\n     %uint_2 = OpConstant %uint 2\r\n     %uint_0 = OpConstant %uint 0\r\n%_runtimearr_uint = OpTypeRuntimeArray %uint\r\n%type_ByteAddressBuffer = OpTypeStruct %_runtimearr_uint\r\n%_runtimearr_type_ByteAddressBuffer = OpTypeRuntimeArray %type_ByteAddressBuffer\r\n%_ptr_Uniform__runtimearr_type_ByteAddressBuffer = OpTypePointer Uniform %_runtimearr_type_ByteAddressBuffer\r\n%type_RWByteAddressBuffer = OpTypeStruct %_runtimearr_uint\r\n%_runtimearr_type_RWByteAddressBuffer = OpTypeRuntimeArray %type_RWByteAddressBuffer\r\n%_ptr_Uniform__runtimearr_type_RWByteAddressBuffer = OpTypePointer Uniform %_runtimearr_type_RWByteAddressBuffer\r\n      %v3int = OpTypeVector %int 3\r\n%_ptr_Input_v3int = OpTypePointer Input %v3int\r\n       %void = OpTypeVoid\r\n         %20 = OpTypeFunction %void\r\n%_ptr_Uniform_uint = OpTypePointer Uniform %uint\r\n%g_byteAddressBuffer = OpVariable %_ptr_Uniform__runtimearr_type_ByteAddressBuffer Uniform\r\n%g_rwByteAddressBuffer = OpVariable %_ptr_Uniform__runtimearr_type_RWByteAddressBuffer Uniform\r\n%gl_GlobalInvocationID = OpVariable %_ptr_Input_v3int Input\r\n       %main = OpFunction %void None %20\r\n         %22 = OpLabel\r\n         %23 = OpLoad %v3int %gl_GlobalInvocationID\r\n         %24 = OpCompositeExtract %int %23 0\r\n         %25 = OpBitcast %uint %24\r\n         %26 = OpShiftRightLogical %uint %25 %uint_2\r\n         %27 = OpAccessChain %_ptr_Uniform_uint %g_byteAddressBuffer %int_0 %uint_0 %26\r\n         %28 = OpLoad %uint %27\r\n         %29 = OpAccessChain %_ptr_Uniform_uint %g_rwByteAddressBuffer %int_0 %uint_0 %26\r\n               OpStore %29 %28\r\n               OpReturn\r\n               OpFunctionEnd\r\n```\r\n\r\n\r\nFirst attempt:\r\n```\r\n#[allow(unused_attributes)]\r\n#[spirv(gl_compute)]\r\npub fn main_cs(\r\n    #[spirv(descriptor_set = 0, binding = 0)] img: Uniform<&[u32]>,\r\n) {\r\n    let img = img.load();\r\n    let stuff = &img[0];\r\n}\r\n```\r\n\r\nThis seems to emit a OpRuntimeArray but then proceed to do some things wrong. I had even more trouble making the slice mutable (for storing data) since that leads to a bunch of compiler errors down the line around `.load` not being available etc.\r\n\r\nIdeally we would also like to declare the bindless arrays as globals, so it's nicer to create our own wrapper types around Image2d and other (so they can do the indirection through the bindless array).",
    "comments": [
      {
        "id": "MDEyOklzc3VlQ29tbWVudDc2NDUzODQ3Mg==",
        "author": {
          "login": "Jasper-Bekkers"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "Trying to re-create the needed SPIR-V in inline assembly also fails because of `OpVariable` needing to be `Uniform` and thus in global scope instead of inside the function.\r\n\r\n```\r\n#[allow(unused_attributes)]\r\n#[spirv(gl_compute)]\r\npub fn main_cs(\r\n) {\r\n\r\n    unsafe {\r\n        asm!(\r\n            \"%int = OpTypeInt 32 0\",\r\n            \"%uint = OpTypeInt 32 1\",\r\n            \"%int_0 = OpConstant %int 0\",\r\n            \"%uint_0 = OpConstant %uint 0\",\r\n            \"%int_array = OpTypeRuntimeArray %int\",\r\n            \"%ptr_int_array = OpTypePointer Uniform %int_array\",\r\n            \"%array = OpVariable %ptr_int_array Uniform\",\r\n            \"%stuff = OpAccessChain %ptr_int_array %array %uint_0 %uint_0 %uint_0\"\r\n        );\r\n    }\r\n}\r\n```",
        "createdAt": "2021-01-21T10:30:07Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/389#issuecomment-764538472",
        "viewerDidAuthor": false
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDc2NDU0MTA5Nw==",
        "author": {
          "login": "Jasper-Bekkers"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "From internal discussions it would seem that this is depending on https://github.com/EmbarkStudios/rust-gpu/issues/300",
        "createdAt": "2021-01-21T10:34:27Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/389#issuecomment-764541097",
        "viewerDidAuthor": false
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDc2NDc5ODI4OA==",
        "author": {
          "login": "repi"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "Really would like to have bindless support as believe it can simplify a lot in how we build our renderer with this. So approve of the idea :) But this is not that clear/concrete (to me) of how it would be implemented and what the options are, so maybe a lighter RFC is needed and/or some prototypes to map It out?",
        "createdAt": "2021-01-21T17:07:37Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/389#issuecomment-764798288",
        "viewerDidAuthor": false
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDc2NTAwOTkzOA==",
        "author": {
          "login": "Jasper-Bekkers"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "@repi This is just an issue to get over the initial hurdle so we can get rust-gpu to emit the correct SPIR-V incantation to even begin prototyping this.",
        "createdAt": "2021-01-21T23:36:58Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/389#issuecomment-765009938",
        "viewerDidAuthor": false
      }
    ],
    "createdAt": "2021-01-21T10:12:41Z",
    "labels": [
      {
        "id": "MDU6TGFiZWwyNDQwMDc1MDU3",
        "name": "mcp: accepted",
        "description": "A major change to the compiler that has been accepted.",
        "color": "FBCA07"
      },
      {
        "id": "MDU6TGFiZWwyNjc1Njc5MjE0",
        "name": "a: ark",
        "description": "Issues that Ark depends on",
        "color": "FCA492"
      }
    ],
    "number": 389,
    "reactionGroups": [],
    "state": "OPEN",
    "title": "MCP: Bindless support",
    "url": "https://github.com/EmbarkStudios/rust-gpu/issues/389"
  },
  {
    "author": {
      "id": "MDQ6VXNlcjQ0NjQyOTU=",
      "is_bot": false,
      "login": "XAMPPRocky",
      "name": ""
    },
    "body": "This is a tracking issue for tracking what rust-gpu can produce in terms of SPIR-V assembly.\r\n\r\n#### Emoji Legend\r\n- üõë ‚Äî Missing\r\n- ‚ö†Ô∏è ‚Äî Incomplete\r\n- ‚úÖ ‚Äî Complete (excluding vendor specific extensions)\r\n\r\n## Execution Models ‚úÖ\r\n\r\n<details><summary>Details</summary>\r\n<p>\r\n\r\n- [x] Vertex\r\n- [x] Tessellation Control\r\n- [x] Tessellation Evaluation\r\n- [x] Geometry\r\n- [x] Fragment\r\n- [x] GLCompute\r\n- [x] Kernel (Compute)\r\n- [x] TaskNV\r\n- [x] MeshNV\r\n- [x] Ray Generation NV\r\n- [x] Ray Intersection NV\r\n- [x] Ray Any-hit NV\r\n- [x] Ray Closest-hit NV\r\n- [x] Ray Miss NV\r\n- [x] Ray Callable NV\r\n\r\n</p>\r\n</details>\r\n\r\n## Addressing Model ‚ö†Ô∏è\r\n\r\n<details><summary>Details</summary>\r\n<p>\r\n\r\n\r\n- [x] Logical\r\n- [ ] Physical32\r\n- [ ] Physical64\r\n- [ ] PhysicalStorageBuffer64\r\n\r\n</p>\r\n</details>\r\n\r\n## Memory Model ‚úÖ\r\n\r\n<details><summary>Details</summary>\r\n<p>\r\n\r\n\r\n- [x] Simple\r\n- [x] GLSL450\r\n- [x] OpenCL\r\n- [x] Vulkan\r\n\r\n</p>\r\n</details>\r\n\r\n## Execution Modes ‚ö†Ô∏è\r\n\r\n<details><summary>Details</summary>\r\n\r\n### All models ‚úÖ\r\n<details><summary>Details</summary>\r\n<p>\r\n\r\n\r\n- [x] Initializer\r\n- [x] Finalizer\r\n- [x] SubgroupSize\r\n- [x] SubgroupsPerWorkgroup\r\n- [x] SubgroupsPerWorkgroupId\r\n- [x] PostDepthCoverage\r\n- [x] DenormPreserve\r\n- [x] DenormFlushToZero\r\n- [x] SignedZeroInfNanPreserve\r\n- [x] RoundingModeRTE\r\n- [x] RoundingModeRTZ\r\n\r\n</p>\r\n</details>\r\n\r\n### Kernel ‚úÖ\r\n<details><summary>Details</summary>\r\n<p>\r\n\r\n\r\n- [x] LocalSizeHint\r\n- [x] LocalSizeHintId\r\n- [x] VecTypeHint\r\n- [x] ContractionOff\r\n\r\n</p>\r\n</details>\r\n\r\n### Kernel & GLCompute ‚úÖ\r\n<details><summary>Details</summary>\r\n<p>\r\n\r\n\r\n- [x] LocalSize\r\n- [x] LocalSizeId\r\n\r\n</p>\r\n</details>\r\n\r\n### Geometry ‚úÖ\r\n<details><summary>Details</summary>\r\n<p>\r\n\r\n\r\n- [x] Invocations\r\n- [x] InputPoints\r\n- [x] InputLines\r\n- [x] InputLinesAdjacency\r\n- [x] InputTrianglesAdjacency\r\n\r\n</p>\r\n</details>\r\n\r\n### Geometry & Tessellation ‚úÖ\r\n<details><summary>Details</summary>\r\n<p>\r\n\r\n\r\n- [x] Triangles\r\n- [x] OutputVertices\r\n\r\n</p>\r\n</details>\r\n\r\n### Fragment ‚ö†Ô∏è\r\n<details><summary>Details</summary>\r\n<p>\r\n\r\n\r\n- [x] PixelCenterInteger\r\n- [ ] OriginUpperLeft\r\n- [x] OriginLowerLeft\r\n- [x] EarlyFragmentTests\r\n- [x] DepthReplacing\r\n- [x] DepthGreater\r\n- [x] DepthLess\r\n- [x] DepthUnchanged\r\n- [x] OutputPoints\r\n- [x] OutputLineStrip\r\n- [x] OutputTriangleStrip\r\n\r\n</p>\r\n</details>\r\n\r\n### Tessellation ‚ö†Ô∏è\r\n<details><summary>Details</summary>\r\n<p>\r\n\r\n\r\n- [x] SpacingEqual\r\n- [x] SpacingFractionalEven\r\n- [x] SpacingFractionalOdd\r\n- [x] VertexOrderCw\r\n- [x] VertexOrderCcw\r\n- [x] PointMode\r\n- [x] Quads\r\n- [ ] Isolines\r\n\r\n</p>\r\n</details>\r\n\r\n### Vertex ‚úÖ\r\n- [x] Xfb\r\n\r\n</details>\r\n\r\n## Storage Classes ‚úÖ\r\n<details><summary>Details</summary>\r\n<p>\r\n\r\n- [x] UniformConstant\r\n- [x] Input\r\n- [x] Uniform\r\n- [x] Output\r\n- [x] Workgroup\r\n- [x] CrossWorkgroup\r\n- [x] Private\r\n- [x] Function\r\n- [x] Generic\r\n- [x] PushConstant\r\n- [x] AtomicCounter\r\n- [x] Image\r\n- [x] StorageBuffer\r\n- [x] CallableDataKHR\r\n- [x] IncomingCallableDataKHR\r\n- [x] RayPayloadKHR\r\n- [x] HitAttributeKHR\r\n- [x] IncomingRayPayloadKHR\r\n- [x] ShaderRecordBufferKHR\r\n- [x] PhysicalStorageBuffer\r\n\r\n</p>\r\n</details>\r\n\r\n## Image ‚ö†Ô∏è\r\n<details><summary>Details</summary>\r\n<p>\r\n\r\n\r\n- [x] OpSampledImage\r\n- [x] OpImageSampleImplicitLod\r\n- [x] OpImageSampleExplicitLod\r\n- [x] OpImageSampleDrefImplicitLod\r\n- [x] OpImageSampleDrefExplicitLod\r\n- [x] OpImageSampleProjImplicitLod\r\n- [x] OpImageSampleProjExplicitLod\r\n- [x] OpImageSampleProjDrefImplicitLod\r\n- [x] OpImageSampleProjDrefExplicitLod\r\n- [x] OpImageFetch\r\n- [ ] OpImageGather\r\n- [ ] OpImageDrefGather\r\n- [x] OpImageRead\r\n- [x] OpImageWrite\r\n- [ ] OpImageQueryFormat\r\n- [ ] OpImageQueryOrder\r\n- [ ] OpImageQuerySizeLod\r\n- [ ] OpImageQuerySize\r\n- [ ] OpImageQueryLod\r\n- [ ] OpImageQueryLevels\r\n- [ ] OpImageQuerySamples\r\n- [ ] OpImageSparseSampleImplicitLod\r\n- [ ] OpImageSparseSampleExplicitLod\r\n- [ ] OpImageSparseSampleDrefImplicitLod\r\n- [ ] OpImageSparseSampleDrefExplicitLod\r\n- [ ] OpImageSparseFetch\r\n- [ ] OpImageSparseGather\r\n- [ ] OpImageSparseDrefGather\r\n- [ ] OpImageSparseTexelsResident\r\n- [ ] OpImageSparseRead\r\n\r\n</p>\r\n</details>\r\n\r\n## Conversions üõë\r\n<details><summary>Details</summary>\r\n<p>\r\n\r\n- [ ] Float <-> unsigned integer\r\n- [ ] Float <-> signed integer\r\n- [ ] OpUconvert\r\n- [ ] OpSConvert\r\n- [ ] OpFConvert\r\n- [ ] OpQuantizeToF16\r\n- [ ] OpConvertPtrToU\r\n- [ ] OpSatConvertSToU\r\n- [ ] OpSatConvertUToS\r\n- [ ] OpConvertUToPtr\r\n- [ ] OpPtrCastToGeneric\r\n- [ ] OpGenericCastToPtr\r\n- [ ] OpGenericCastToPtrExplicit\r\n- [ ] OpBitcast\r\n\r\n</p>\r\n</details>\r\n\r\n## Composite ‚ö†Ô∏è\r\n<details><summary>Details</summary>\r\n<p>\r\n\r\n- [x] OpVectorExtractDynamic\r\n- [x] OpVectorInsertDynamic\r\n- [ ] OpVectorShuffle\r\n- [ ] OpTranspose\r\n\r\n</p>\r\n</details>\r\n\r\n## Arithmetic ‚ö†Ô∏è\r\n<details><summary>Details</summary>\r\n<p>\r\n\r\n- [x] OpSNegate\r\n- [x] OpFNegate\r\n- [x] OpIAdd\r\n- [x] OpFAdd\r\n- [x] OpISub\r\n- [x] OpFSub\r\n- [x] OpIMul\r\n- [x] OpFMul\r\n- [x] OpUDiv\r\n- [x] OpSDiv\r\n- [x] OpFDiv\r\n- [x] OpUMod\r\n- [x] OpSRem\r\n- [x] OpSMod\r\n- [x] OpFRem\r\n- [x] OpFMod\r\n- [x] OpVectorTimesScalar\r\n- [ ] OpMatrixTimesScalar\r\n- [ ] OpVectorTimesMatrix\r\n- [ ] OpMatrixTimesVector\r\n- [ ] OpMatrixTimesMatrix\r\n- [ ] OpOuterProduct\r\n- [ ] OpDot\r\n- [ ] OpIAddCarry\r\n- [ ] OpISubBorrow\r\n- [ ] OpUMulExtended\r\n- [ ] OpSMulExtended\r\n\r\n</p>\r\n</details>\r\n\r\n## Bit ‚ö†Ô∏è\r\n<details><summary>Details</summary>\r\n<p>\r\n\r\n- [x] OpShiftRightLogical\r\n- [ ] OpShiftRightArithmetic\r\n- [x] OpShiftLeftLogical\r\n- [x] OpBitwiseOr\r\n- [x] OpBitwiseXor\r\n- [x] OpBitwiseAnd\r\n- [x] OpNot\r\n- [ ] OpBitFieldInsert\r\n- [ ] OpBitFieldSExtract\r\n- [ ] OpBitFieldUExtract\r\n- [ ] OpBitReverse\r\n- [ ] OpBitCount\r\n\r\n</p>\r\n</details>\r\n\r\n## Relational & Logical ‚ö†Ô∏è\r\n<details><summary>Details</summary>\r\n<p>\r\n\r\n- [x] OpAny\r\n- [x] OpAll\r\n- [ ] OpIsNan\r\n- [ ] OpIsInf\r\n- [ ] OpIsFinite\r\n- [ ] OpIsNormal\r\n- [ ] OpSignBitSet\r\n- [ ] OpLessOrGreater\r\n- [ ] OpOrdered\r\n- [ ] OpUnordered\r\n- [ ] OpLogicalEqual\r\n- [ ] OpLogicalNotEqual\r\n- [ ] OpLogicalOr\r\n- [ ] OpLogicalAnd\r\n- [ ] OpLogicalNot\r\n- [ ] OpSelect\r\n- [ ] OpIEqual\r\n- [ ] OpINotEqual\r\n- [ ] OpUGreaterThan\r\n- [ ] OpSGreaterThan\r\n- [ ] OpUGreaterThanEqual\r\n- [ ] OpSGreaterThanEqual\r\n- [ ] OpULessThan\r\n- [ ] OpSLessThan\r\n- [ ] OpULessThanEqual\r\n- [ ] OpSLessThanEqual\r\n- [ ] OpFOrdEqual\r\n- [ ] OpFUnordEqual\r\n- [ ] OpFOrdNotEqual\r\n- [ ] OpFUnordNotEqual\r\n- [ ] OpFOrdLessThan\r\n- [ ] OpFUnordLessThan\r\n- [ ] OpFOrdGreaterThan\r\n- [ ] OpFUnordGreaterThan\r\n- [ ] OpFOrdLessThanEqual\r\n- [ ] OpFUnordLessThanEqual\r\n- [ ] OpFOrdGreaterThanEqual\r\n- [ ] OpFUnordGreaterThanEqual\r\n\r\n</p>\r\n</details>\r\n\r\n## Derivative ‚úÖ\r\n\r\n<details><summary>Details</summary>\r\n<p>\r\n\r\n- [x] OpDPdx\r\n- [x] OpDPdy\r\n- [x] OpFwidth\r\n- [x] OpDPdxFine\r\n- [x] OpDPdyFine\r\n- [x] OpFwidthFine\r\n- [x] OpDPdxCoarse\r\n- [x] OpDPdyCoarse\r\n- [x] OpFwidthCoarse\r\n\r\n</p>\r\n</details>\r\n\r\n## Atomic üõë\r\n\r\n<details><summary>Details</summary>\r\n<p>\r\n\r\n- [ ] OpAtomicLoad\r\n- [ ] OpAtomicStore\r\n- [ ] OpAtomicExchange\r\n- [ ] OpAtomicCompareExchange\r\n- [ ] OpAtomicCompareExchangeWeak\r\n- [ ] OpAtomicIIncrement\r\n- [ ] OpAtomicIDecrement\r\n- [ ] OpAtomicIAdd\r\n- [ ] OpAtomicISub\r\n- [ ] OpAtomicSMin\r\n- [ ] OpAtomicUMin\r\n- [ ] OpAtomicSMax\r\n- [ ] OpAtomicUMax\r\n- [ ] OpAtomicAnd\r\n- [ ] OpAtomicOr\r\n- [ ] OpAtomicXor\r\n- [ ] OpAtomicFlagTestAndSet\r\n- [ ] OpAtomicFlagClear\r\n\r\n</p>\r\n</details>\r\n\r\n## Barrier üõë\r\n\r\n<details><summary>Details</summary>\r\n<p>\r\n\r\n- [ ] OpControlBarrier\r\n- [ ] OpMemoryBarrier\r\n- [ ] OpNamedBarrierInitialize\r\n- [ ] OpMemoryNamedBarrier\r\n\r\n</p>\r\n</details>\r\n\r\n## Group & Subgroup üõë\r\n\r\n<details><summary>Details</summary>\r\n<p>\r\n\r\n- [ ] OpGroupAsyncCopy\r\n- [ ] OpGroupWaitEvents\r\n- [ ] OpGroupAll\r\n- [ ] OpGroupAny\r\n- [ ] OpGroupBroadcast\r\n- [ ] OpGroupIAdd\r\n- [ ] OpGroupFAdd\r\n- [ ] OpGroupFMin\r\n- [ ] OpGroupUMin\r\n- [ ] OpGroupSMin\r\n- [ ] OpGroupFMax\r\n- [ ] OpGroupUMax\r\n- [ ] OpGroupSMax\r\n\r\n</p>\r\n</details>\r\n\r\n## Device-side Enqueue üõë\r\n\r\n<details><summary>Details</summary>\r\n<p>\r\n\r\n- [ ] OpEnqueueMarker\r\n- [ ] OpEnqueueKernel\r\n- [ ] OpGetKernelNDrangeSubGroupCount\r\n- [ ] OpGetKernelNDrangeMaxSubGroupSize\r\n- [ ] OpGetKernelWorkGroupSize\r\n- [ ] OpGetKernelPreferredWorkGroupSizeMultiple\r\n- [ ] OpRetainEvent\r\n- [ ] OpReleaseEvent\r\n- [ ] OpCreateUserEvent\r\n- [ ] OpIsValidEvent\r\n- [ ] OpSetUserEventStatus\r\n- [ ] OpCaptureEventProfilingInfo\r\n- [ ] OpGetDefaultQueue\r\n- [ ] OpBuildNDRange\r\n- [ ] OpGetKernelLocalSizeForSubgroupCount\r\n- [ ] OpGetKernelMaxNumSubgroups\r\n\r\n</p>\r\n</details>\r\n\r\n## Pipe üõë\r\n\r\n<details><summary>Details</summary>\r\n<p>\r\n\r\n- [ ] OpReadPipe\r\n- [ ] OpWritePipe\r\n- [ ] OpReservedReadPipe\r\n- [ ] OpReservedWritePipe\r\n- [ ] OpReserveReadPipePackets\r\n- [ ] OpReserveWritePipePackets\r\n- [ ] OpCommitReadPipe\r\n- [ ] OpCommitWritePipe\r\n- [ ] OpIsValidReserveId\r\n- [ ] OpGetNumPipePackets\r\n- [ ] OpGetMaxPipePackets\r\n- [ ] OpGroupReserveReadPipePackets\r\n- [ ] OpGroupReserveWritePipePackets\r\n- [ ] OpGroupCommitReadPipe\r\n- [ ] OpGroupCommitWritePipe\r\n- [ ] OpConstantPipeStorage\r\n- [ ] OpCreatePipeFromPipeStorage\r\n\r\n</p>\r\n</details>\r\n\r\n## Non-uniform üõë\r\n\r\n<details><summary>Details</summary>\r\n<p>\r\n\r\n- [ ] OpGroupNonUniformElect\r\n- [ ] OpGroupNonUniformAll\r\n- [ ] OpGroupNonUniformAny\r\n- [ ] OpGroupNonUniformAllEqual\r\n- [ ] OpGroupNonUniformBroadcast\r\n- [ ] OpGroupNonUniformBroadcastFirst\r\n- [ ] OpGroupNonUniformBallot\r\n- [ ] OpGroupNonUniformInverseBallot\r\n- [ ] OpGroupNonUniformBallotBitExtract\r\n- [ ] OpGroupNonUniformBallotBitCount\r\n- [ ] OpGroupNonUniformBallotFindLSB\r\n- [ ] OpGroupNonUniformBallotFindMSB\r\n- [ ] OpGroupNonUniformShuffle\r\n- [ ] OpGroupNonUniformShuffleXor\r\n- [ ] OpGroupNonUniformShuffleUp\r\n- [ ] OpGroupNonUniformShuffleDown\r\n- [ ] OpGroupNonUniformIAdd\r\n- [ ] OpGroupNonUniformFAdd\r\n- [ ] OpGroupNonUniformIMul\r\n- [ ] OpGroupNonUniformFMul\r\n- [ ] OpGroupNonUniformSMin\r\n- [ ] OpGroupNonUniformUMin\r\n- [ ] OpGroupNonUniformFMin\r\n- [ ] OpGroupNonUniformSMax\r\n- [ ] OpGroupNonUniformUMax\r\n- [ ] OpGroupNonUniformFMax\r\n- [ ] OpGroupNonUniformBitwiseAnd\r\n- [ ] OpGroupNonUniformBitwiseOr\r\n- [ ] OpGroupNonUniformBitwiseXor\r\n- [ ] OpGroupNonUniformLogicalAnd\r\n- [ ] OpGroupNonUniformLogicalOr\r\n- [ ] OpGroupNonUniformLogicalXor\r\n- [ ] OpGroupNonUniformQuadBroadcast\r\n- [ ] OpGroupNonUniformQuadSwap\r\n\r\n</p>\r\n</details>",
    "comments": [],
    "createdAt": "2021-01-18T15:02:57Z",
    "labels": [
      {
        "id": "MDU6TGFiZWwyNDQzMjY4NzAw",
        "name": "t: tracking issue",
        "description": "An issue tracking the progress of a specific feature or change.",
        "color": "52E8A0"
      },
      {
        "id": "LA_kwDOENG4488AAAABHkF3zA",
        "name": "s: needs update",
        "description": "This issue needs a follow up or investigation whether it still applies.",
        "color": "CCCCCC"
      }
    ],
    "number": 383,
    "reactionGroups": [],
    "state": "OPEN",
    "title": "SPIR-V Support",
    "url": "https://github.com/EmbarkStudios/rust-gpu/issues/383"
  },
  {
    "author": {
      "id": "MDQ6VXNlcjQ0NjQyOTU=",
      "is_bot": false,
      "login": "XAMPPRocky",
      "name": ""
    },
    "body": "A lot of image operations (mainly those around sampling, or getting/setting texels from images) support [additional optional operands](https://www.khronos.org/registry/spir-v/specs/1.0/SPIRV.html#Image_Operands). At the SPIR-V level this comes in the form of an operand at the end of each instruction which is a 8 bit integer that acts as a bit mask for indicating the how many operands follow and what they are used for. Additionally certain operands can only be used with certain image parameters, (such as the `Bias` operand only being available for single sampled 1D, 2D, 3D, and Cube image.)\r\n\r\nThe question becomes how to best support using these operands at the Rust level and validate these constraints.\r\n\r\n### Possibilities\r\n\r\n- Have a different function for each operand.\r\n   - **Advantage** Simplest to implement.\r\n   - **Drawback** Requires dozens if not hundreds of functions to cover every possible combination for each instruction, leading to a lot of repetition.\r\n- Use const generics on the functions for each instruction.\r\n  - **Advantage** Potential to avoid a lot of repetition\r\n  - **Drawback** Unclear how generic it could be at this point. \r\n\r\nOne example of where it's unclear with constant generics is the `Grad` operand. Which allows you to pass 2 vectors or scalars of the same size as the `Dim`, so right now I'm unsure how we'd allow that to  generically while also validating the length. ",
    "comments": [
      {
        "id": "MDEyOklzc3VlQ29tbWVudDc1NTMwMDAzMA==",
        "author": {
          "login": "Jasper-Bekkers"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "For reference; GLSL has the following texture sampling functions\r\n\r\n```glsl\r\nivec textureSize(gsampler sampler‚Äã, int lod‚Äã);\r\nint textureQueryLevels(gsampler sampler‚Äã);\r\ngvec texture(gsampler sampler‚Äã, vec texCoord‚Äã[, float bias‚Äã]);\r\ngvec textureOffset(gsampler sampler‚Äã, vec texCoord‚Äã, ivec offset‚Äã[, float bias‚Äã]);\r\ngvec textureProj(gsampler sampler‚Äã, vec projTexCoord‚Äã[, float bias‚Äã]);\r\ngvec textureLod(gsampler sampler‚Äã, vec texCoord‚Äã, float lod‚Äã);\r\ngvec textureGrad(gsampler sampler‚Äã, vec texCoord‚Äã, gradvec dTdx‚Äã, gradvec dTdy‚Äã);\r\ngvec4 textureGather(gsampler sampler‚Äã‚Äã, vec texCoord‚Äã‚Äã, int comp‚Äã);\r\ngvec4 textureGatherOffset(gsampler sampler‚Äã‚Äã, vec texCoord‚Äã‚Äã, ivec2 offset‚Äã, int comp‚Äã);\r\ngvec4 textureGatherOffsets(gsampler sampler‚Äã‚Äã, vec texCoord‚Äã‚Äã, ivec2 offsets‚Äã[4], int comp‚Äã);\r\ngvec textureProjLodOffset(gsampler sampler‚Äã, vec projTexCoord‚Äã, float lod‚Äã, ivec offset‚Äã);\r\n```\r\n\r\nSome of those have optional parameters; if we were to mimic these 1:1 in Rust we'd end up with these sampling functions\r\n\r\n```\r\nivec texture_size(gsampler sampler‚Äã, int lod‚Äã);\r\nint texture_query_levels(gsampler sampler‚Äã);\r\ngvec texture(gsampler sampler‚Äã, vec texCoord‚Äã);\r\ngvec texture_with_bias(gsampler sampler‚Äã, vec texCoord‚Äã, float bias‚Äã);\r\ngvec texture_offset(gsampler sampler‚Äã, vec texCoord‚Äã, ivec offset‚Äã);\r\ngvec texture_offset_with_bias(gsampler sampler‚Äã, vec texCoord‚Äã, ivec offset‚Äã, float bias‚Äã);\r\ngvec texture_proj(gsampler sampler‚Äã, vec projTexCoord‚Äã);\r\ngvec texture_proj_with_bias(gsampler sampler‚Äã, vec projTexCoord‚Äã, float bias‚Äã);\r\ngvec texture_lod(gsampler sampler‚Äã, vec texCoord‚Äã, float lod‚Äã);\r\ngvec texture_grad(gsampler sampler‚Äã, vec texCoord‚Äã, gradvec dTdx‚Äã, gradvec dTdy‚Äã);\r\ngvec4 texture_gather(gsampler sampler‚Äã‚Äã, vec texCoord‚Äã‚Äã, int comp‚Äã);\r\ngvec4 texture_gather_offset(gsampler sampler‚Äã‚Äã, vec texCoord‚Äã‚Äã, ivec2 offset‚Äã, int comp‚Äã);\r\ngvec4 texture_gather_offsets(gsampler sampler‚Äã‚Äã, vec texCoord‚Äã‚Äã, ivec2 offsets‚Äã[4], int comp‚Äã);\r\ngvec texture_proj_lod_offset(gsampler sampler‚Äã, vec projTexCoord‚Äã, float lod‚Äã, ivec offset‚Äã);\r\n```\r\n\r\nWhich doesn't seem too bad?",
        "createdAt": "2021-01-06T13:31:15Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/364#issuecomment-755300030",
        "viewerDidAuthor": false
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDc1NTkyMDYzMQ==",
        "author": {
          "login": "XAMPPRocky"
        },
        "authorAssociation": "MEMBER",
        "body": "If it's just those it might be fine, though as far as I can tell the spec allows for much more combinations (for example you could have `texture` with `Lod`,`Bias`, `MinLod`, and `Offset` operands simultaneously) , and it applies not just to sampling functions, but also `OpImageRead`, `OpImageWrite`, and all the `OpImageSparse*` equivalents.\r\n\r\nAnother pattern I was thinking that could be useful here, is the builder pattern for the operands part, which would allow to us to only have one extra function for each instruction equivalent. So for example we could have the `texture` that doesn't include any and the `texture_with_operands` function which returns a `ImageOperandBuilder` so then we would just have methods for each of the operands individually, and then a final `build`/`run` method. For example handling the above case would look like the following.\r\n\r\n```rust\r\nimage.texture_with_operands(sampler, coords)\r\n    .bias(1.0)\r\n    .lod(3.0)\r\n    .offset(vec![1.0, 2.0])\r\n    .min_lod(2.0)\r\n    .run()\r\n```",
        "createdAt": "2021-01-07T06:42:10Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/364#issuecomment-755920631",
        "viewerDidAuthor": false
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDc1NjUxODA1Mw==",
        "author": {
          "login": "DeanBDean"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "So many AWS functions have lots and lots of optional parameters. The way that [rusoto](https://github.com/rusoto/rusoto), the wrapper library for AWS in Rust, handles this by defining all possible inputs in a struct, with the Default trait also defined. You can then pretty ergonomically specific the parameters you want, and then call Default::default() to hydrate the rest of the struct. [Here](https://github.com/matthewkmayer/matthewkmayer.github.io/blob/master/samples/rusoto-local-dynamodb/src/main.rs#L46) is an example from that library. In this case, the operands would just be wrapped in Option, and default would be None. \r\n \r\n The builder pattern looks easier to use and reason to me, but I just wanted to throw this out there as an option",
        "createdAt": "2021-01-08T03:05:51Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/364#issuecomment-756518053",
        "viewerDidAuthor": false
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDc1Nzc4NjA1Mg==",
        "author": {
          "login": "khyperia"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "Note that \"dynamically\" passing in values (like the builder methods, or arguments to a method) runs into compiler implementation difficulty: in the instruction, the extra operands bit pattern is embedded into the instruction itself. Doing a _potentially_ dynamic thing like a builder pattern, or passing in the bit pattern as an argument, is really tough to implement (you could add some if statements to change what the resulting bit pattern is, which would somehow have to be a compiler error) - const generic argument should be fine though.",
        "createdAt": "2021-01-11T09:24:08Z",
        "includesCreatedEdit": true,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/364#issuecomment-757786052",
        "viewerDidAuthor": false
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDc1NzgzMDMzNg==",
        "author": {
          "login": "XAMPPRocky"
        },
        "authorAssociation": "MEMBER",
        "body": "> Note that \"dynamically\" passing in values (like the builder methods, or arguments to a method) runs into compiler implementation difficulty\r\n\r\nWell the builder itself could be passed in a const fashion, it wouldn't have the syntax above though.\r\n\r\nThe problem I was running into with it all being const generic arguments is enforcing things like `ConstOffset` requiring that the number of components it uses is equal to the number of components you passed in minus the array layer. And currently you can't have const generic parameters that depend on other parameters.\r\n\r\n```rust\r\n#![feature(const_generics)]\r\n\r\nconst fn bar(v: u8) -> u8 {\r\n    match v {\r\n        0 => 1,\r\n        1 => 2,\r\n        _ => 3\r\n    }\r\n}\r\n\r\n// Errors\r\nconst fn foo<const V: u8, const A: [u8; { bar(V) }]>() {}\r\n```\r\n\r\n",
        "createdAt": "2021-01-11T09:53:30Z",
        "includesCreatedEdit": true,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/364#issuecomment-757830336",
        "viewerDidAuthor": false
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDc1OTMxNjA3Mw==",
        "author": {
          "login": "khyperia"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "Ah, just realized these issues weren't linked: https://github.com/EmbarkStudios/rust-gpu/issues/369 is about supporting image operands in `asm!`, and this issue is about supporting image operands in the user-visible spirv-std API (which are two distinct things).",
        "createdAt": "2021-01-13T09:16:52Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/364#issuecomment-759316073",
        "viewerDidAuthor": false
      },
      {
        "id": "IC_kwDOENG4485ULHT4",
        "author": {
          "login": "oisyn"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "This came up again in the context of sampling from multisampled images. I really think we need some kind of generic way to specify the operands, rather than creating all sorts of permutations for the different sampling instructions.\r\n\r\nA third option not mentioned is to use some kind of macro. That way we can add a bit of grammar catering to our needs and do something more elaborate at compile time.",
        "createdAt": "2023-02-01T14:59:36Z",
        "includesCreatedEdit": true,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/364#issuecomment-1412199672",
        "viewerDidAuthor": false
      },
      {
        "id": "IC_kwDOENG4485UMjbY",
        "author": {
          "login": "Jasper-Bekkers"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "> This came up again in the context of sampling from multisampled images. I really think we need some kind of generic way to specify the operands, rather than creating all sorts of permutations for the different sampling instructions.\n> \n> A third option not mentioned is to use some kind of macro. That way we can add a bit of grammar catering to our needs and do something more elaborate at compile time.\n\nYou may want to consider a macro to generate the functions rather then one on the usage side of the API.",
        "createdAt": "2023-02-01T19:09:32Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/364#issuecomment-1412576984",
        "viewerDidAuthor": false
      }
    ],
    "createdAt": "2021-01-05T12:34:20Z",
    "labels": [
      {
        "id": "MDU6TGFiZWwyMjI3MzM4ODE2",
        "name": "t: enhancement",
        "description": "A new feature or improvement to an existing one.",
        "color": "52E8A0"
      },
      {
        "id": "MDU6TGFiZWwyNDM3NjYzNTA3",
        "name": "c: spirv-std",
        "description": "Issues specific to the spirv-std crate",
        "color": "006C75"
      },
      {
        "id": "MDU6TGFiZWwyNzg5MjI1Nzgw",
        "name": "a: image",
        "description": "Issues related to image operations in SPIR-V.",
        "color": "FCA492"
      }
    ],
    "number": 364,
    "reactionGroups": [],
    "state": "OPEN",
    "title": "Supporting Image Operands in spirv-std",
    "url": "https://github.com/EmbarkStudios/rust-gpu/issues/364"
  },
  {
    "author": {
      "id": "MDQ6VXNlcjI2MTk0OTkx",
      "is_bot": false,
      "login": "charles-r-earp",
      "name": ""
    },
    "body": "# Summary \r\nThis proposal attempts to address #232, #180, and #8. StorageBuffers, aka Buffer Blocks, are the primary inputs / outputs to compute shaders, though they can also be used in other stages. Iterators are one of Rust's highlights, and I propose emulating them in gpu code. \r\n\r\n# Example: Scaled Add aka Saxpy\r\n```\r\n// Rust Cpu\r\nfn scaled_add(x: &[f32], mut y: &mut [f32], alpha: f32) {\r\n    for (x, mut y) in x.iter().copied().zip(y) {\r\n        *y += alpha * x;\r\n    }\r\n}\r\n\r\n// OpenCL \r\n__kernel void scaled_add(__global const float* x, __global float* y, float alpha, uint n) {\r\n    uint gid = get_global_id(0);\r\n    if gid < n {\r\n        y[gid] += alpha * x[gid];\r\n    }\r\n}\r\n\r\n// GLSL \r\n#version 450\r\n\r\nlayout(set=0, binding=0) buffer Input {\r\n    float x[];    \r\n}\r\n\r\nlayout(set=0, binding=1) buffer Output {\r\n    float y[];    \r\n}\r\n\r\nlayout(push_constant) uniform PushConsts {\r\n    float alpha;\r\n    uint n;\r\n}\r\n\r\nvoid main() {\r\n    uint gid = gl_GlobalInvocationID.x;\r\n    if gid < n {\r\n        y[gid] += alpha * x[gid];\r\n    }\r\n}\r\n```\r\n\r\nSaxpy is trivially parallel, that is, it can be separated into n independent operations. There are plenty of other similar kinds of operations common in CUDA / OpenCL code, which do not require any synchronization / barriers. In fact, this is probably the most common case. \r\n\r\n## Possible Naive Implementation in rust-gpu\r\n\r\n```\r\n#[allow(unused_attributes)]\r\n#[spirv(gl_compute)]\r\npub fn scaled_add(x: Buffer<[f32]>, mut y: BufferMut<[f32]>, alpha: f32, n: u32) {\r\n    let gid = spirv_std::global_x();\r\n    if gid < n {\r\n        unsafe {\r\n            *y.get_mut_unchecked(gid) = x.get_unchecked(gid);\r\n        }    \r\n    } \r\n} \r\n```\r\n\r\nThis is the most straightforward translation of the above to rust gpu code. If we neglect concerns about aliasing with other shaders, then the only potential failure mode would be that the user provided n is outside the bounds of either x or y. The programmer is responsible, by using unsafe, to ensure no aliasing within the shader. \r\n\r\nThe rayon crate allows for easy parallel processing on cpu's, with its ParallelIterator trait. It looks like this:\r\n\r\n```\r\n// rayon\r\nfn scaled_add(x: &[f32], mut y: &mut [f32], alpha: f32) {\r\n    use rayon::iter::ParallelIterator;\r\n    for (mut y, x) in y.par_iter_mut().zip(x.iter().copied()) {\r\n        *y += alpha * x;\r\n    }\r\n}\r\n```\r\n\r\nRayon divides the work into n parts, where n is the number of workers. It knows that partioning a slice, even a mutable one, is safe. I propose a similar api for rust-gpu. \r\n\r\n# Proposal \r\n\r\nBuffers: Runtime Arrays of T: Copy\r\n  - GlobalBuffer: StorageBuffer\r\n  - GlobalBufferMut: StorageBuffer, mutable\r\n  - GroupBufferMut: Workgroup, mutable\r\n  \r\nArrays: Like buffers, but with a const size, either const generics or array type ie <T = f32, const N: usize = 1024>, or <T = [f32; 1024]> \r\n  - GlobalArray: StorageBuffer\r\n  - GlobalArrayMut: StorageBuffer, mutable\r\n  - GroupArrayMut: Workgroup, mutable\r\n  \r\nMatrices!?? Would probably want const generics, ie Matrix2<T, D1 = 100, D2 = 64>\r\n  - An abstraction over Array, maybe even Buffer\r\n  - Useful for iterating over dimensions, see ndarray\r\n  - If we express the access as an iterator, then we can prevent aliases or perform appropriate synchronization\r\n  - Long term idea\r\n\r\nBlocks: A single T struct item, T: Copy\r\n  - GlobalBlock: StorageBuffer\r\n  - load() -> T\r\n  - Potentially borrow() / as_ref() -> &T\r\n\r\nIf necessary, mutable Block fields could be accomplished via some sort of Mutex or ArcCell equivalent, but that would require relaxing the Copy requirement. \r\n  \r\nArrays and Blocks are safer because the runtime can validate the inputs prior to launching. Start with blocks, then arrays, then buffers. Note that all of these require a special \"Block\" decorated struct wrapper, at least per SPIR-V specification. Slices are also tricky / not allowed in exports because of Rust's unstable abi.\r\n\r\n## Iterators\r\n\r\nGlobalIterator trait\r\n  - Like rayon::iter::ParallelIterator\r\n  - Divides the work into global size pieces, and each invocation works on one piece \r\n  - fn for_each(self, f: impl Fn(Self::Item)) \r\n  - fn enumerate() \r\n  - fn enumerate_xyz() Same as enumerate, but provides the coordinates rather than the index\r\n  - fn zip() for iterating over multiple buffers\r\n  - others from Iterator if possible\r\n  - some sort of hidden drive / next function\r\n  - unsafe to implement, may even be sealed\r\n  \r\nGroupIterator trait \r\n  - Like GlobalIterator, but iterates over local size\r\n  \r\n*Iter's are like slice::Iter, they iterate over a borrow.\r\n  \r\nIntoGlobalIterator / IntoGroupIterator\r\n\r\n*IntoIter's: consume their container, but still yield borrowed values. This allows them to mutate the output, but they are consumed from the scope of the shader. \r\n\r\n## Unsafe \r\nBuffers, Arrays, may have unsafe access to their internal Slice. It may not always be possible to prove that a program is safe, and it will take time to implement enough safe wrappers to fit every need. \r\n\r\nLikewise, access to invocation specific values, like the global xyz, must be unsafe or even not allowed at all to ensure that the safe GlobalIterator construct is in fact safe. This means that the shader cannot get the u32 value, but could say, manipulate it mathmatically, and index a Buffer / slice / or pointer with it (this would require unsafe). The key thing is that it can't be read and it can't be used in control flow outside of the inner closure of for_each. This could be implemented as a wrapper, ie Idx(u32), which implements the appropriate traits. \r\n\r\n## Barriers\r\nBarriers are emitted by *Iter and *IterMut iterators as required. IntoIter's should be able to ommit barriers, since they consume their inputs, so that they cannot be read / written to again within the shader.\r\n\r\n## Globally Const vs Per Invocation\r\nFor trivial cases like axpy, there is no need for the shader to access non-const memory (outside of the closure passed to for_each). The closure cannot mutate it's environment, or even borrow it, and nothing is returned from it. This prevents non-static control flow. Only the push_constants would be copied into the closure (via move).\r\n\r\n## Single Invocation operations\r\nIn some cases, it may be necessary to have only one invocation peform some work. This could potentially handled with a special SingleGlobalBufferIntoIter or the like.  \r\n\r\n## Putting it all together \r\n\r\n```\r\n#[allow(unused_attributes)]\r\n#[spirv(gl_compute)]\r\npub fn scaled_add(x: GlobalArray<f32, 100>, y: GlobalArrayMut<f32, 100>, alpha: f32) {\r\n    y.into_global_iter_mut().zip(x)\r\n        .for_each(|(mut y, x)| *y += alpha * x);\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n\r\n",
    "comments": [
      {
        "id": "MDEyOklzc3VlQ29tbWVudDczNDM1MTc1Mw==",
        "author": {
          "login": "Jasper-Bekkers"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "Related to #216 so might be good to get @Tobski's eyes on this as well.",
        "createdAt": "2020-11-26T15:12:30Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/249#issuecomment-734351753",
        "viewerDidAuthor": false
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDczNDM2MTgxMg==",
        "author": {
          "login": "Jasper-Bekkers"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "> For trivial cases like axpy, there is no need for the shader to access non-const memory (outside of the closure passed to for_each). The closure cannot mutate it's environment, or even borrow it, and nothing is returned from it. This prevents non-static control flow. Only the push_constants would be copied into the closure (via move).\r\n\r\nWould you mind elaborating \"non-const memory\" here? \r\n\r\nI've had discussions with @Tobski before, and the iterator based approach to data access is actually quite appealing to us - especially having something like you've proposed for the simpler cases.\r\n\r\nOne extension we discussed back then was to have a `UniformIndex`-style type which would allow safe remapping operations on the equivalent of gl_globalinvocationid (at least in such a way that they wouldn't clobber other elements in the buffer). Kind of like this:\r\n\r\n```rust\r\n#[allow(unused_attributes)]\r\n#[spirv(gl_compute)]\r\npub fn scaled_add(x: GlobalArray<f32, 100>, y: GlobalArrayMut<f32, 100>, alpha: f32) {\r\n    y.into_global_iter_mut().map_idx(|idx| idx ^ 2).zip(x)\r\n        .for_each(|(mut y, x)| *y += alpha * x);\r\n}\r\n```",
        "createdAt": "2020-11-26T15:31:05Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/249#issuecomment-734361812",
        "viewerDidAuthor": false
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDczNDM5OTU3OA==",
        "author": {
          "login": "XAMPPRocky"
        },
        "authorAssociation": "MEMBER",
        "body": "We discussed this at the meeting today, and the consensus that we're generally in favour of idea of adding storage buffers, and we really like the style of using iterators for this task. However we think that there's still a lot of design work to be done in this, and would like to see a full RFC on this topic.\r\n\r\nAdditionally before we'd accept an RFC on a safe API for storage buffers, we'd like to first see an unsafe API for storage buffers available, that allows people to prototype and build their own safe abstractions before merging it into `spirv-std`.",
        "createdAt": "2020-11-26T16:43:34Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/249#issuecomment-734399578",
        "viewerDidAuthor": false
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDczNDQ0MDA4OA==",
        "author": {
          "login": "charles-r-earp"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "> > For trivial cases like axpy, there is no need for the shader to access non-const memory (outside of the closure passed to for_each). The closure cannot mutate it's environment, or even borrow it, and nothing is returned from it. This prevents non-static control flow. Only the push_constants would be copied into the closure (via move).\r\n> \r\n> Would you mind elaborating \"non-const memory\" here?\r\n\r\nHmmm, by non-const I mean the data in buffers, and global_id's, sizes etc. The idea is that the closure passed to for_each can't borrow anything, and doesn't return anything, and is the only way, at least safely, to access the data in buffers or the global id. If we know that at entry level that the code only has access to things that are uniform across all invocations,  then control flow must also be uniform. The non uniform part is either in the closure, or expressed via the iterator, ie if the buffer is len 100 and the global size is 128, then the extra 28 are invalidated, rather than reading out of bounds. This acts like zipping a collection with a range. ",
        "createdAt": "2020-11-26T18:43:31Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/249#issuecomment-734440088",
        "viewerDidAuthor": false
      }
    ],
    "createdAt": "2020-11-18T05:30:29Z",
    "labels": [
      {
        "id": "MDU6TGFiZWwyMjg0ODcxMDQ1",
        "name": "t: design",
        "description": "Design of our rust-gpu language and std",
        "color": "52E8A0"
      },
      {
        "id": "MDU6TGFiZWwyNDM3Njk5MTUx",
        "name": "mcp: rfc needed",
        "description": "Issues that need an RFC before implementation.",
        "color": "FBCA07"
      }
    ],
    "number": 249,
    "reactionGroups": [],
    "state": "OPEN",
    "title": "API Design: StorageBuffers",
    "url": "https://github.com/EmbarkStudios/rust-gpu/issues/249"
  },
  {
    "author": {
      "id": "MDQ6VXNlcjg4NzcxMQ==",
      "is_bot": false,
      "login": "fu5ha",
      "name": "Gray Olson"
    },
    "body": "<!-- Thank you for filing a bug report! üêõ -->\r\n\r\n### Expected Behaviour\r\n<!-- Please describe what you expected to happen. -->\r\n\r\nBe able to use `Option<Mat4>`\r\n\r\n### Example & Steps To Reproduce\r\n\r\nUse an `Option` that contains a value larger than some threshold\r\n\r\n```rust\r\n    pub fn from_mat4(t: &Mat4) -> Option<Self> {\r\n        let (scale3, rotation, translation) = t.to_scale_rotation_translation();\r\n        if scale3.abs_diff_eq(Vec3::splat(1.0), 1e-4) {\r\n            Some(Self::from_rotation_translation(rotation, translation))\r\n        } else {\r\n            None\r\n        }\r\n    }\r\n```\r\n\r\n![image](https://user-images.githubusercontent.com/887711/98978156-c4e6e680-24d6-11eb-9ffa-db615f465364.png)\r\n\r\n",
    "comments": [
      {
        "id": "MDEyOklzc3VlQ29tbWVudDcyNjM3MzQ4OQ==",
        "author": {
          "login": "MarijnS95"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "@termhn This error is identical to the one I intended to create an issue for following https://github.com/EmbarkStudios/rust-gpu/pull/220#discussion_r520862235, thanks for waking me up :smile: \r\n\r\n```rust\r\nerror: Cannot cast between pointer types\r\n   --> examples/shaders/sky-shader/src/lib.rs:156:19\r\n    |\r\n156 |     let sun_pos = const_vec3!([0.0, 75.0, -1000.0]);\r\n    |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n    |\r\n    = note: from: *{Function} [u8; 16]\r\n    = note: to: *{Function} [f32; 3]\r\n    = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\r\n```\r\n\r\n`Cannot cast between pointer types` comes from `zombie_bitcast_ptr`.\r\n\r\nThe `const_vec3` macro (and the `f32x4` in your error likely means a `const_quat!` somewhere) use a `union` to perform casting. Using it on a primitive like `[ui]64` is fine (for lack of `[iu]128`):\r\n\r\n```rust\r\n    union Foo {\r\n        a: u64,\r\n        b: i64,\r\n    }\r\n    let x = unsafe { Foo { a: 1 }.b };\r\n```\r\n\r\nThis compiles without errors. Turning it into a statically sized array (internal representation in glam), no matter how small surfaces this error:\r\n\r\n```rust\r\n    union Foo {\r\n        a: [u8; 1],\r\n        b: [i8; 1],\r\n    }\r\n    let x = unsafe { Foo { a: [1] }.b };\r\n```\r\n\r\n```rust\r\nerror: Cannot cast between pointer types\r\n   --> examples/shaders/sky-shader/src/lib.rs:163:22\r\n    |\r\n163 |     let x = unsafe { Foo { a: [1] }.b };\r\n    |                      ^^^^^^^^^^^^^^^^\r\n    |\r\n    = note: from: *{Function} [u8; 1]\r\n    = note: to: *{Function} [i8; 1]\r\n```\r\n\r\nBonus, attempting to \"get\" a `[iu]128` by using a tuple throws something completely different:\r\n\r\n```rust\r\n    union Foo {\r\n        a: (u64, u64),\r\n        b: (i64, u64),\r\n    }\r\n    let x = unsafe { Foo { a: (1, 1) }.b };\r\n```\r\n\r\n```rust\r\nerror: Cannot use this pointer directly, it must be dereferenced first\r\n   --> examples/shaders/sky-shader/src/lib.rs:163:22\r\n    |\r\n163 |     let x = unsafe { Foo { a: (1, 1) }.b };\r\n    |                      ^^^^^^^^^^^^^^^^^^^\r\n\r\nerror: aborting due to previous error\r\n```\r\n\r\nI'm not enough of a compiler engineer to take the plunge and understand + solve this issue (despite that I assume these statically sized arrays should be taken and reinterpreted \"by value\") but this mini-investigation might give someone else a head-start :grin: ",
        "createdAt": "2020-11-12T22:17:38Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/234#issuecomment-726373489",
        "viewerDidAuthor": false
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDcyNjYyOTQxOA==",
        "author": {
          "login": "khyperia"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "Unfortunately these are far from different errors, they merely fail with the same compiler error message. Enums we can fix via the approach that RLSL took and generate an \"exploded\" data representation, where each enum kind is stored as separate field (and disallow interaction with host-rust). This will remove the need to bitcast pointers, fixing the compiler error reported here.\r\n\r\nHowever, arbitrary bitcasting between pointers is impossible to do on the GPU, and will never be supported.",
        "createdAt": "2020-11-13T08:51:23Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/234#issuecomment-726629418",
        "viewerDidAuthor": false
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDc1NjA2Nzc2MA==",
        "author": {
          "login": "XAMPPRocky"
        },
        "authorAssociation": "MEMBER",
        "body": "Updated title to reflect that this currently affects all `Option<T>`'s for example this provides the same error.\r\n\r\n```rust\r\npub fn foo () -> Option<u8> { Some(5u8) }\r\n```\r\n\r\n```\r\nerror: Cannot cast between pointer types\r\n  --> examples/shaders/sky-shader/src/lib.rs:40:31\r\n   |\r\n40 | pub fn foo () -> Option<u8> { Some(5u8) }\r\n   |                               ^^^^^^^^^\r\n   |\r\n   = note: from: *{Function} struct core::option::Option<u8> { u8, u8 }\r\n   = note: to: *{Function} struct core::option::Option<u8>::Some { 0: u8 }\r\n```",
        "createdAt": "2021-01-07T11:46:18Z",
        "includesCreatedEdit": true,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/234#issuecomment-756067760",
        "viewerDidAuthor": false
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDc3OTMwNzk2Mw==",
        "author": {
          "login": "XAMPPRocky"
        },
        "authorAssociation": "MEMBER",
        "body": "Adding this as another thing that needs options, which is `num_traits::Float::powi`, it uses an `.unwrap` in it's code when converting to usize. https://github.com/rust-num/num-traits/blob/319623616822ab8d77ba0422dc63ed4ff5b9a809/src/float.rs#L684\r\n\r\n```rust\r\n#[test]\r\nfn powi() {\r\n    val(r#\"\r\nfn powi(x: f32) -> f32 {\r\n    x.powi(80)\r\n}\r\n#[allow(unused_attributes)]\r\n#[spirv(fragment)]\r\npub fn main() {\r\n    assert!(powi(1.0) == 80.0);\r\n}\r\n\"#);\r\n}\r\n```\r\n\r\n### Error\r\n```\r\nerror: Cannot cast between pointer types\r\n   --> /Users/.cargo/registry/src/github.com-1ecc6299db9ec823/num-traits-0.2.14/src/cast.rs:278:1\r\n    |\r\n278 | impl_to_primitive_uint!(u32);\r\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n    |\r\n    = note: from: *{Function} struct core::option::Option<usize> { u32, u32 }\r\n    = note: to: *{Function} struct core::option::Option<usize>::Some { 0: u32 }\r\n    = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\r\n\r\nerror: Cannot cast between pointer types\r\n   --> /Users/.rustup/toolchains/nightly-2020-12-28-x86_64-apple-darwin/lib/rustlib/src/rust/library/core/src/option.rs:385:18\r\n    |\r\n385 |             Some(val) => val,\r\n    |                  ^^^\r\n    |\r\n    = note: from: *{Function} struct core::option::Option<usize> { u32, u32 }\r\n    = note: to: *{Function} struct core::option::Option<usize>::Some { 0: u32 }\r\n```",
        "createdAt": "2021-02-15T15:50:32Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/234#issuecomment-779307963",
        "viewerDidAuthor": false
      },
      {
        "id": "IC_kwDOENG44842r-mK",
        "author": {
          "login": "DavidTruby"
        },
        "authorAssociation": "NONE",
        "body": "This issue also seems to prevent num-complex compiling in shader crates. I'd be interested in having a deeper look at this if it's possible to fix. I have a couple of questions though.\r\n\r\nFirstly, why is it that pointer bitcasts aren't possible on the GPU? I worked (briefly) on the GPU OpenMP backend in clang and am pretty sure I remember that we allowed arbitrary `reinterpret_cast`s on there.\r\n\r\nSecondly, specifically what I'm seeing is pointer casts like `from: *[struct &str { *[u8], u32 }; 6]` to `*[struct &str { *[u8], u32 }]`. I'm not really a rust expert, but why are these even considered pointer casts at all from the GPU's perspective? Aren't these just casts from fixed to \"variable\" length arrays? The CPU architectures I'm familiar with have no concept of fixed length arrays anyway (as far as I'm aware) so surely this cast is a no-op by that point even on a CPU?\r\n\r\nIf anyone can point me in the right direction here I'd be happy to take a look!",
        "createdAt": "2021-09-11T22:59:44Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/234#issuecomment-917498250",
        "viewerDidAuthor": false
      },
      {
        "id": "IC_kwDOENG44842tl_6",
        "author": {
          "login": "khyperia"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "(meta note: I believe you discussed those questions on discord with eddyb after you posted this, so I won't answer again here - let me know if I'm mistaken and I can give answers here)",
        "createdAt": "2021-09-13T07:35:01Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/234#issuecomment-917921786",
        "viewerDidAuthor": false
      },
      {
        "id": "IC_kwDOENG4485aW2P6",
        "author": {
          "login": "Lucky4Luuk"
        },
        "authorAssociation": "NONE",
        "body": "Any updates on this? I'd love to be able to use Option<T> in shaders.",
        "createdAt": "2023-04-20T08:34:00Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/234#issuecomment-1515938810",
        "viewerDidAuthor": false
      },
      {
        "id": "IC_kwDOENG4486PkCoe",
        "author": {
          "login": "reinismu"
        },
        "authorAssociation": "NONE",
        "body": "https://github.com/EmbarkStudios/spirt/pull/24 doesn't unlock Option<T>?",
        "createdAt": "2024-10-12T14:47:12Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/234#issuecomment-2408589854",
        "viewerDidAuthor": false
      }
    ],
    "createdAt": "2020-11-12T18:04:17Z",
    "labels": [
      {
        "id": "MDU6TGFiZWwyMjI3MzM4ODEz",
        "name": "t: bug",
        "description": "Something isn't working",
        "color": "52E8A0"
      },
      {
        "id": "MDU6TGFiZWwyNDM3NjYwNTcw",
        "name": "c: rustc_codegen_spirv",
        "description": "Issues specific to the rustc_codegen_spirv crate.",
        "color": "006b75"
      },
      {
        "id": "LA_kwDOENG4488AAAABPXHqow",
        "name": "s: qptr may fix",
        "description": "This might be fixed by the \"qptr\" experiment (https://github.com/EmbarkStudios/spirt/pull/24)",
        "color": "CCCCCC"
      }
    ],
    "number": 234,
    "reactionGroups": [],
    "state": "OPEN",
    "title": "Support Option<T>",
    "url": "https://github.com/EmbarkStudios/rust-gpu/issues/234"
  },
  {
    "author": {
      "id": "MDQ6VXNlcjQ0NjQyOTU=",
      "is_bot": false,
      "login": "XAMPPRocky",
      "name": ""
    },
    "body": "This is a tracking issue for adding support for using Rust language features and the `core` library with `rustc_codegen_spirv`.\r\n\r\n\r\n## Language Support\r\n- [x] Closures\r\n- [ ] Enums\r\n  - [x] Data-less enums. `enum Foo { A, B }`\r\n  - [ ] Algebraic data types.  `enum Option<T> { Some(T), None }`\r\n- [x] Loops\r\n  - [x] `loop`\r\n  - [x] `while`\r\n  - [x] `for`\r\n- [x] `if`\r\n- [x] `match`\r\n- [x] [Proc macros]\r\n- [ ] Try (`?`) operator\r\n- [ ] [128 bit integers](https://github.com/EmbarkStudios/rust-gpu/issues/196)\r\n- [ ] [`union`](https://github.com/EmbarkStudios/rust-gpu/issues/415)\r\n- [ ] Compiles on stable\r\n  - Blocked on stabilisation of `-Z codegen-backend`, also see https://github.com/rust-lang/rust/issues/77933\r\n\r\n[proc macros]: https://github.com/EmbarkStudios/rust-gpu/issues/192\r\n\r\n## Compiler & Library Support\r\n- [ ] Debug builds\r\n  - Blocked on #81, #186 \r\n- [ ] Iterators\r\n- [ ] [`Option<T>`](https://github.com/EmbarkStudios/rust-gpu/issues/234)\r\n\r\n## Features that don't work\r\n- Dynamic Dispatch\r\n- Pointer casts\r\n- [Unsized slices](https://github.com/EmbarkStudios/rust-gpu/issues/378#issue-786964025) (`&[T]`)\r\n\r\n## About Tracking Issues\r\nTracking issues are meant for providing status updates on the progress of a feature, it's not meant for bug reports or discussions on a feature. Please instead file a new issue or join the `#rust-gpu` channel on Discord. ",
    "comments": [
      {
        "id": "MDEyOklzc3VlQ29tbWVudDc2MTIwOTU1Nw==",
        "author": {
          "login": "jarble"
        },
        "authorAssociation": "NONE",
        "body": "Will closures be supported as well?",
        "createdAt": "2021-01-15T21:32:09Z",
        "includesCreatedEdit": false,
        "isMinimized": true,
        "minimizedReason": "resolved",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/78#issuecomment-761209557",
        "viewerDidAuthor": false
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDc2MjA4OTk4NA==",
        "author": {
          "login": "XAMPPRocky"
        },
        "authorAssociation": "MEMBER",
        "body": "@jarble Closures are currently supported.",
        "createdAt": "2021-01-18T08:48:49Z",
        "includesCreatedEdit": false,
        "isMinimized": true,
        "minimizedReason": "resolved",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/78#issuecomment-762089984",
        "viewerDidAuthor": false
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDgwNDI1NDE1NQ==",
        "author": {
          "login": "eddyb"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "Should we update `README.md` and/or `docs` to indicate that e.g. `for` loops are now supported?",
        "createdAt": "2021-03-22T17:30:01Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "users": {
              "totalCount": 3
            }
          }
        ],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/78#issuecomment-804254155",
        "viewerDidAuthor": false
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDg1ODU3NjMzNQ==",
        "author": {
          "login": "mitchmindtree"
        },
        "authorAssociation": "NONE",
        "body": "Hi folks! Is it possible that rust-gpu may one day support trait objects? I'm currently implementing \"ray tracing in one weekend\" with `rust-gpu` and there are a couple cases like `Hittable` and `Material` where a trait allows for abstracting them nicely and a trait object would allow to work with collections of each with a little more ease. Being able to have world be a [&dyn Hittable; N] e.g. would allow for easily adding new objects to the world. I think support for ADTs would get us a lot of these same benefits where we specify different implementations under variants of an enum, though would lack the benefit of adding new variants in downstream crates.\r\n\r\nI realise what we can achieve when targeting SPIR-V is far more limited and that it might not be possible to achieve use of `&dyn Trait`, though my understanding of these limitations is limited, so just thought I'd ask!\r\n\r\n(edit: accidentally tapped \"Comment\" before finishing!)",
        "createdAt": "2021-06-10T12:25:42Z",
        "includesCreatedEdit": true,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/78#issuecomment-858576335",
        "viewerDidAuthor": false
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDg1ODU4Mzk2Nw==",
        "author": {
          "login": "khyperia"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "> Hi folks! Is it possible that rust-gpu may one day support trait objects?\r\n\r\nI think at some point in the future, it may - however, we'd first have to get through a SPIR-V spec change to be able to support dynamic dispatch. The Slang folks are considering doing this (we've discussed a bit about what rust-gpu's needs would be if a SPIR-V feature for dynamic dispatch was proposed), but it's likely a ways off (if it happens at all), and then even further beyond that to let drivers implement it, and beyond _that_ rust-gpu can start implementing it. So, I wouldn't hold your breath.\r\n\r\n(`impl Trait` and friends all work 100% today, but yeah, unfortunately I don't think that's what you're asking)",
        "createdAt": "2021-06-10T12:36:29Z",
        "includesCreatedEdit": true,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "users": {
              "totalCount": 1
            }
          }
        ],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/78#issuecomment-858583967",
        "viewerDidAuthor": false
      },
      {
        "id": "IC_kwDOENG44847y18r",
        "author": {
          "login": "tema3210"
        },
        "authorAssociation": "NONE",
        "body": "What about plain function pointers then? AFAIK spirv doesn't support these at all.",
        "createdAt": "2021-12-30T21:16:51Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/78#issuecomment-1003183915",
        "viewerDidAuthor": false
      },
      {
        "id": "IC_kwDOENG448471tCP",
        "author": {
          "login": "khyperia"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "> What about plain function pointers then? AFAIK spirv doesn't support these at all.\r\n\r\nYep, SPIR-V doesn't support them at all right now. With the Slang folks considering pushing through an implementation for dynamic dispatch in SPIR-V, plain function pointers may be able to piggyback on the same infrastructure as well, we'll see (probably more likely than not some hack would make it work). However, we haven't heard any updates in a while (and our unrelated requests for changes/clarifications to the SPIR-V spec have not made much progress at all), so I wouldn't hold your breath.",
        "createdAt": "2022-01-03T08:25:20Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "users": {
              "totalCount": 2
            }
          }
        ],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/78#issuecomment-1003933839",
        "viewerDidAuthor": false
      },
      {
        "id": "IC_kwDOENG4485v-sS9",
        "author": {
          "login": "pyranota"
        },
        "authorAssociation": "NONE",
        "body": "Hey!\r\nIs lifetimes supported in enums?\r\n```rust\r\npub enum MyEnum<'a> {\r\n    A {\r\n        tmp: &'a Foo,\r\n    },\r\n    B {},\r\n}\r\n```\r\nIm not sure if its `Data-less enums` or `Algebraic data types`",
        "createdAt": "2024-01-05T13:56:19Z",
        "includesCreatedEdit": true,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/78#issuecomment-1878705341",
        "viewerDidAuthor": false
      },
      {
        "id": "IC_kwDOENG4486Izxwf",
        "author": {
          "login": "tuguzT"
        },
        "authorAssociation": "NONE",
        "body": "It seems that blockers of \"debug builds\" feature are all fixed at this moment.\r\nI wonder if it is possible to implement such feature.",
        "createdAt": "2024-08-18T14:02:39Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/78#issuecomment-2295274527",
        "viewerDidAuthor": false
      }
    ],
    "createdAt": "2020-10-21T09:57:13Z",
    "labels": [
      {
        "id": "MDU6TGFiZWwyNDQzMjY4NzAw",
        "name": "t: tracking issue",
        "description": "An issue tracking the progress of a specific feature or change.",
        "color": "52E8A0"
      }
    ],
    "number": 78,
    "reactionGroups": [
      {
        "content": "THUMBS_UP",
        "users": {
          "totalCount": 18
        }
      },
      {
        "content": "HOORAY",
        "users": {
          "totalCount": 5
        }
      },
      {
        "content": "ROCKET",
        "users": {
          "totalCount": 2
        }
      },
      {
        "content": "EYES",
        "users": {
          "totalCount": 5
        }
      }
    ],
    "state": "OPEN",
    "title": "Rust Language Support",
    "url": "https://github.com/EmbarkStudios/rust-gpu/issues/78"
  },
  {
    "author": {
      "id": "MDQ6VXNlcjQ5NTk0",
      "is_bot": false,
      "login": "Jasper-Bekkers",
      "name": "Jasper Bekkers"
    },
    "body": "Tracking issue for features we think are missing or useful in to have in SPIR-V\r\n\r\n - `OpTrap`: trigger a breakpoint",
    "comments": [
      {
        "id": "MDEyOklzc3VlQ29tbWVudDY4NDYzODkzMg==",
        "author": {
          "login": "Jasper-Bekkers"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "Noticed a few comments other things in the codebase yesterday:\r\n\r\n - Checked math as native SPIR-V ops could help slightly more optimized checked math routines https://github.com/EmbarkStudios/rust-gpu/blob/f79ca6cfef6316a516f366cfed3d248ee5d387ec/rustc_codegen_spirv/src/builder/builder_methods.rs#L218-L226\r\n - Saturating math ops (already supported by some GPU ISAs - so should be easier to drive adoption for): https://github.com/EmbarkStudios/rust-gpu/blob/17814d69d1b2ddf6976357bd5a313e849883b7d6/rustc_codegen_spirv/src/builder/mod.rs#L350-L360\r\n - Equivalent of `llvm.expect`: https://github.com/EmbarkStudios/rust-gpu/blob/17814d69d1b2ddf6976357bd5a313e849883b7d6/rustc_codegen_spirv/src/builder/mod.rs#L386-L390\r\n - Equivalent of `llvm.sideeffects`: https://github.com/EmbarkStudios/rust-gpu/blob/17814d69d1b2ddf6976357bd5a313e849883b7d6/rustc_codegen_spirv/src/builder/mod.rs#L391-L395\r\n - Equivalent of `llvm.assume`: https://github.com/EmbarkStudios/rust-gpu/blob/17814d69d1b2ddf6976357bd5a313e849883b7d6/rustc_codegen_spirv/src/builder/mod.rs#L382-L385",
        "createdAt": "2020-09-01T09:17:14Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/17#issuecomment-684638932",
        "viewerDidAuthor": false
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDY4NDgxNzM0NA==",
        "author": {
          "login": "khyperia"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "For the \"equivalent of `llvm.*`\", there are a *lot* of these, those are just the ones that have been hit so far - I've just been JITting them into the codebase. For a reasonably full list, look at this file - for example, `llvm.expect.i1` (`sym::likely`/`sym::unlikely`), `llvm.debugtrap` (`sym::breakpoint`), and so forth. (including `llvm.trap` (`sym::abort`), which was already mentioned at the start of this thread)\r\n\r\nhttps://github.com/rust-lang/rust/blob/e88e908e66cd1e6e30d789b37bcd774951d01856/compiler/rustc_codegen_llvm/src/intrinsic.rs",
        "createdAt": "2020-09-01T12:30:36Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/17#issuecomment-684817344",
        "viewerDidAuthor": false
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDY5MTE5MDE4OA==",
        "author": {
          "login": "Jasper-Bekkers"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": " * Potentially request OpControlBarrier  for non-uniform controlflow (useful for #29)",
        "createdAt": "2020-09-11T16:21:20Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/17#issuecomment-691190188",
        "viewerDidAuthor": false
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDY5MTE5MTQzNA==",
        "author": {
          "login": "nhaehnle"
        },
        "authorAssociation": "NONE",
        "body": ">     * Potentially request OpControlBarrier  for non-uniform controlflow (useful for #29)\r\n\r\nTo clarify, for #29 the thinking is that OpControlBarrier without undefined behavior may be useful. This would be done by making the behavior a guaranteed hang when it's not executed in uniform control flow...",
        "createdAt": "2020-09-11T16:23:55Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/17#issuecomment-691191434",
        "viewerDidAuthor": false
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDcwNzgzMTA5Ng==",
        "author": {
          "login": "Jasper-Bekkers"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "> @khyperia \r\n> not only is this legal spir-v, it is unspecified what the return value is (like, it's not specified as undefined, it's unspecified)\r\n\r\n```spirv\r\n         %f_ = OpFunction %int None %7\r\n          %9 = OpLabel\r\n          %x = OpVariable %_ptr_Function_int Function\r\n         %12 = OpLoad %int %x\r\n               OpReturnValue %12\r\n               OpFunctionEnd\r\n```\r\n> can we get this fixed in the spec, please?\r\n> this is equivalent to the glsl\r\n\r\n```glsl\r\nint f() {\r\n    int x; // explicitly uninitialized\r\n    return x;\r\n}\r\n```\r\n",
        "createdAt": "2020-10-13T15:43:20Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/17#issuecomment-707831096",
        "viewerDidAuthor": false
      }
    ],
    "createdAt": "2020-08-20T13:53:30Z",
    "labels": [
      {
        "id": "MDU6TGFiZWwyNDQzMjY4NzAw",
        "name": "t: tracking issue",
        "description": "An issue tracking the progress of a specific feature or change.",
        "color": "52E8A0"
      }
    ],
    "number": 17,
    "reactionGroups": [],
    "state": "OPEN",
    "title": "SPIR-V wishlist",
    "url": "https://github.com/EmbarkStudios/rust-gpu/issues/17"
  },
  {
    "author": {
      "id": "MDQ6VXNlcjQ5NTk0",
      "is_bot": false,
      "login": "Jasper-Bekkers",
      "name": "Jasper Bekkers"
    },
    "body": "We want to have the same types of safety on the GPU as we do on the CPU. One of those areas that make it easy to introduce race conditions is with memory barriers. HLSL and GLSL require the programmer to explicitly put them in the right locations without any formal verifiction.\r\n\r\nThis is an attempt at solving that within the Rust type system (attempt still has racy bugs and is largely incomplete).\r\n\r\n```rust\r\nuse core::ops::Deref;\r\nuse core::ops::DerefMut;\r\nuse core::ops::Index;\r\nuse core::ops::IndexMut;\r\n\r\nstruct MyFoo {\r\n    test: GroupSharedArray<u32>,\r\n}\r\n\r\nstruct GroupSharedArray<T>\r\nwhere\r\n    T: Default + Copy,\r\n{\r\n    data: Box<[T]>,\r\n    size: usize,\r\n}\r\n\r\nimpl<T: Default + Copy> GroupSharedArray<T> {\r\n    fn new() -> Self {\r\n        Self {\r\n            size: 100,\r\n            data: Box::new([T::default(); 100]),\r\n        }\r\n    }\r\n}\r\n\r\nstruct GroupSharedWriter<T> {\r\n    data: T,\r\n}\r\n\r\nimpl<T> Deref for GroupSharedWriter<T> {\r\n    type Target = T;\r\n\r\n    fn deref(&self) -> &Self::Target {\r\n        &self.data\r\n    }\r\n}\r\n\r\nimpl<T> DerefMut for GroupSharedWriter<T> {\r\n    fn deref_mut(&mut self) -> &mut Self::Target {\r\n        &mut self.data\r\n    }\r\n}\r\n\r\nimpl<T> GroupSharedWriter<T> {\r\n    fn new(data: T) -> Self {\r\n        Self { data }\r\n    }\r\n    fn barrier(self) -> GroupSharedReader<T> {\r\n        GroupSharedReader { data: self.data }\r\n    }\r\n}\r\n\r\nstruct GroupSharedReader<T> {\r\n    data: T,\r\n}\r\n\r\nimpl<T> Deref for GroupSharedReader<T> {\r\n    type Target = T;\r\n\r\n    fn deref(&self) -> &Self::Target {\r\n        &self.data\r\n    }\r\n}\r\n\r\nimpl<T> GroupSharedReader<T> {\r\n    fn barrier(self) -> GroupSharedWriter<T> {\r\n        GroupSharedWriter { data: self.data }\r\n    }\r\n}\r\n\r\nimpl<T: Default + Copy> Index<Uniform<u32>> for GroupSharedArray<T> {\r\n    type Output = T;\r\n\r\n    fn index(&self, index: Uniform<u32>) -> &Self::Output {\r\n        &self.data[index.data as usize]\r\n    }\r\n}\r\n\r\nimpl<T: Default + Copy> IndexMut<Uniform<u32>> for GroupSharedArray<T> {\r\n    fn index_mut(&mut self, index: Uniform<u32>) -> &mut Self::Output {\r\n        &mut self.data[index.data as usize]\r\n    }\r\n}\r\n\r\nstruct Uniform<T> {\r\n    data: T,\r\n}\r\n\r\nimpl<T> Uniform<T> {\r\n    fn new(data: T) -> Self {\r\n        Self { data }\r\n    }\r\n}\r\n\r\nfn thread_idx() -> Uniform<u32> {\r\n    Uniform::new(0)\r\n}\r\n\r\nfn main() {\r\n    let mut data = GroupSharedWriter::new(MyFoo {\r\n        test: GroupSharedArray::new(),\r\n    }); // new does barrier\r\n\r\n    data.test[thread_idx()] = thread_idx().data;\r\n    data.test[thread_idx()] = 666; // should be illegal\r\n\r\n    let value = data.test[thread_idx()]; // should be illegal\r\n\r\n    //data.test[0] = thread_idx().data; // what happens in this case? it's unsafe/unsound. race cnd over contents of `test`\r\n\r\n    let other_data = data.barrier(); // `barrier` return GroupSharedReader\r\n    \r\n    // some race-y cases handled correctly:\r\n    // data.test[thread_idx()] = 666; // is correctly marked illegal\r\n    // other_data.test[thread_idx()] = 666; // is correctly marked illegal\r\n\r\n    let test = other_data.data.test[thread_idx()];\r\n}\r\n\r\n// tl;dr\r\n// - use move semantics to enforce barriers betwen reading and writing\r\n// - broken right now because DerefMut and IndexMut require Deref and Index to be implemented\r\n// - broken right now because we can write to the same location multiple times (data race)\r\n```",
    "comments": [
      {
        "id": "MDEyOklzc3VlQ29tbWVudDY3NTYxNTY0MQ==",
        "author": {
          "login": "Jasper-Bekkers"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "The `Uniform` type currently is very limited, but it prevents neighboring threads from writing into each other's LDS buckets concurrently (because we can't do any sort of math on it). However, we should investigate if we can relax this a bit, especially when reading it should be totally fine to index into a neighbors groupshared memory.",
        "createdAt": "2020-08-18T17:34:50Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/8#issuecomment-675615641",
        "viewerDidAuthor": false
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDY3NjA4OTAzNQ==",
        "author": {
          "login": "Jasper-Bekkers"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "Examples from @h3r2tic and others using group shared memory:\r\n\r\n - 1D index with math applied to gl_LocalInvocationID (`id * 2` and `id * 2 + 1`): https://github.com/h3r2tic/rtoy-samples/blob/6aeb26230ea3f4b98ef34d522b38fc7be865a2d6/assets/shaders/hybrid-adaptive-shadows/prefix_scan_2d_vertical.glsl \r\n - one variable written by gl_LocalInvocationID 0: https://github.com/h3r2tic/rtoy-samples/blob/6aeb26230ea3f4b98ef34d522b38fc7be865a2d6/assets/shaders/hybrid-adaptive-shadows/alloc_rt_pixel_locations.glsl\r\n - build a stack - one stack per group / localinvocation this doesn't need any barriers, because there's no cross-thread access\r\n\r\n```hlsl\r\ngroupshared uint stack[GROUP_SIZE * LDS_STACK_SIZE];\r\n\r\nbool bvhIntersectAny(Ray ray, uint stackBase : SV_GroupIndex) {\r\n    uint bottom = stackBase * LDS_STACK_SIZE;\r\n    uint stackPtr = bottom;\r\n    stack[stackPtr++] = InvalidAddr;\r\n\r\n    do {\r\n        Node node = g_nodes[NonUniformResourceIndex(bvh)][addr];\r\n\r\n        if(!isLeaf(node)) {\r\n            // ... \r\n            if(traverseLeft || traverseRight) {\r\n                uint postpone = InvalidAddr;\r\n                // ...\r\n                if(traverseLeft && traverseRight) {\r\n                    stack[stackPtr++] = postpone; // needs manual bounds checking\r\n                }\r\n\r\n                continue;\r\n            }\r\n        } else {\r\n            if(isInstance(node)) {\r\n                stack[stackPtr++] = InvalidAddr; // needs manual bounds checking\r\n                continue;\r\n            } else {\r\n                // \r\n            }\r\n        }\r\n\r\n        addr = stack[--stackPtr];// needs manual bounds checking\r\n\r\n        if(addr == InvalidAddr && stackPtr > 0 && instanceId != ~0) {\r\n            addr = stack[--stackPtr];// needs manual bounds checking\r\n        }\r\n    } while(addr != InvalidAddr);\r\n}\r\n```\r\n\r\n - Complex indexing based on bit logic to index neighbors like in a bitonic sort: https://github.com/microsoft/DirectX-Graphics-Samples/blob/master/MiniEngine/Core/Shaders/Bitonic32InnerSortCS.hlsl\r\n - Treelet rotation example uses crazy groupshared access (and might be race-y as written?) https://github.com/microsoft/DirectX-Graphics-Samples/blob/07008938a0dc5a187a23abcb55b61f8c2809c874/Libraries/D3D12RaytracingFallback/src/TreeletReorder.hlsl#L181",
        "createdAt": "2020-08-19T10:16:31Z",
        "includesCreatedEdit": true,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/8#issuecomment-676089035",
        "viewerDidAuthor": false
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDcxNDgyNTM2OQ==",
        "author": {
          "login": "Tobski"
        },
        "authorAssociation": "NONE",
        "body": "We had the following discussion in the Discord about trying to bring some of Rust's \"fearless concurrency\" to rust-gpu, by tweaking the way that accesses to shared memory (Buffers/UAVs, Workgroup memory, etc.) is managed when translating to SPIR-V. Just so we don't lose the conversation, I've pasted it below - can try to tease out more details later but for now we just want to be able to stow this so we don't lose it...\r\n\r\n> \r\n> Tobias Hector Today at 00:30\r\n> So I've been thinking about the buffer/workgroup memory interface and how they need to ideally interact with synchronization. There's two key parts that kind of need to interact. The first is memory ordering - your typical acquire/release semantics as baseline here. Vulkan/SPIR-V also have some interesting additional semantics though once you look at the way the memory model works; notably values are not \"coherent\" by default like they are on CPU - you have to explicitly tell the compiler to make them visible to other invocations at a given scope. Acquire and release are also scoped - typically you want these scopes to agree with the visibility scope. (The handful of use cases for NOT doing that are really not worth worrying about in the first iteration outside of a single exception which is easy to deal with).\r\n> \r\n> The other part is execution synchronization - telling threads in e.g. a workgroup, subgroup (/warp/wave), or whatever else, to get together so you don't race accesses. This needs to interact with the acquire/release operations, but the crucial part of it initially is simply that you probably need the acquire/release operations to know about sync operations in order to do useful compile time checks. The details of that aren't my concern right now.\r\n> So what I'm thinking is that what would be incredibly nice, is if you could write code like this:\r\n> \r\n> ```rust\r\n> struct Buffer {\r\n>     data: [u32; 32],\r\n> }\r\n> \r\n> fn shader(buffer: &mut Buffer) {\r\n>     buffer.data[SubgroupInvocationId()] = 2;\r\n> }\r\n> ```\r\n> \r\n> And have it fill in the appropriate acquire/release/coherency - without toooo much pain in terms of annotations.\r\n> \r\n> Exploding out the \"shader\" function above, it should generate spir-v something like this:\r\n> \r\n> ```rust\r\n> fn shader(buffer: &mut Buffer) {\r\n>     let blah = &mut buffer.data[SubgroupInvocationId()];    // OpMemoryBarrier, Acquire\r\n>     \r\n>     *blah = 2;                                              // OpStore, MakePointerAvailable\r\n>     \r\n>     drop(blah);                                             // OpMemoryBarrier, Release\r\n> }\r\n> ```\r\n> \r\n> The rust-gpu backend can't just universally emit this for all shader function arguments because you need to handle the different storage classes differently and somewhere the synchronization scope needs annotating.\r\n> Trying to turn this concept into something rusty is eluding me however - borrow/drop/access all need overriding somewhere, but the only place I can see to do that is by overriding the basic types or adding annoying syntax. I think/hope I'm just being a rust noob though :upside_down:\r\n> \r\n> What I imagine would be quite nice is if you could just throw some attributes on the buffer struct that tell it that all accesses to its data have these semantics - but I don't know how realistic that is. Maybe this is something that would make more sense if I had a better sense of rustc internals. I'm hoping someone here has some good ideas :sweat_smile:\r\n> \r\n> Jasper-BekkersToday at 00:31\r\n> Is this something we would need to apply to all buffer types?\r\n> I'm trying to understand the plan a bit\r\n> \r\n> Tobias HectorToday at 00:32\r\n> Uniform/Constant buffers wouldn't have any of these sync semantics\r\n>\r\n> Jasper-BekkersToday at 00:32\r\n> You're thinking about making safety guarantees for concurrent access to buffers\r\n>\r\n> Tobias HectorToday at 00:32\r\n> yes\r\n>\r\n> Jasper-BekkersToday at 00:32\r\n> Yeah let's assume uavs\r\n>\r\n> Tobias HectorToday at 00:32\r\n> trying to make synchronization and lifetime management one and the same as much as possible\r\n> because that's... kind of what they are\r\n> Synchronization in GLSL/HLSL is enormously painful, and rust has some nice tools to do much better, so ideally want to try to use them\r\n>\r\n> Jasper-BekkersToday at 00:33\r\n> If we add . store and .load functions, could that do it?\r\n>\r\n> Tobias HectorToday at 00:33\r\n> you'd probably need to have explicit acquire/release too\r\n> I mean you could do it that way, but my gut says that seems like unnecessary programmer burden :woman_shrugging:\r\n>\r\n> Jasper-BekkersToday at 00:34\r\n> Fair\r\n>\r\n> Tobias HectorToday at 00:34\r\n> might work as an initial prototype, but I don't think it's tenable long term\r\n> if you can make this work for UAVs it would also work for LDS/workgroup memory too :grimacing:\r\n>\r\n> Jasper-BekkersToday at 00:35\r\n> Right so this would, on deref return a RAII object, that can acquire when constructed and release when dropped?\r\n>\r\n> Jasper-BekkersToday at 00:35\r\n> And access to the data would go through this RAII guard\r\n>\r\n> Tobias HectorToday at 00:36\r\n> yea broadly speaking that's basically it:\r\n>  - Acquire on borrow\r\n>  - Make available on store\r\n>  - Make visible on load\r\n>  - Release on drop",
        "createdAt": "2020-10-23T00:00:20Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "users": {
              "totalCount": 1
            }
          }
        ],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/8#issuecomment-714825369",
        "viewerDidAuthor": false
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDcxNDgyOTI1Mw==",
        "author": {
          "login": "Tobski"
        },
        "authorAssociation": "NONE",
        "body": "One additional detail that got discussed after this little back and forth was that the aim here is to get borrow checking working across GPU threads - being able to know explicitly that indexing into the buffer is safe. For instance, if you're mutably borrowing from a buffer via a unique index (say indexing by the workgroup ID per workgroup), then a compile time check should be able to tell you your access is safe. For debugging, it should also be possible to automatically insert (somewhat expensive) checks that invocations aren't racing. There's probably also a place in there somewhere for something akin to rust's explicit lifetimes to allow more complex indexing to be compile-time checked.\r\n\r\nFrom the SPIR-V side the aim is to make painless things that typically developers get frustrated over or make mistakes with - acquire/release/barriers are a pain in the prominent shading languages, and experience shows developers very much tend to get them wrong. The proposal discussed above takes that decision making away from the developer and hard codes what the most useful case as a default behavior - unlike GLSL/HLSL. We may want to provide hooks for less common patterns further down the line, but for now this behaviour should cover the needs of any developer that isn't trying to experiment with synchronization patterns...",
        "createdAt": "2020-10-23T00:09:28Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/8#issuecomment-714829253",
        "viewerDidAuthor": false
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDcxNTM1MTYwMw==",
        "author": {
          "login": "Tobski"
        },
        "authorAssociation": "NONE",
        "body": "Putting this on the correct issue this time....\r\n\r\n\r\nOk so turning this into something a _bit_ more concrete, I think I'd propose three new attributes that affect struct definitions declared as storage buffers/images/texel buffers (UAVs), shared memory (LDS), or anything else we somehow end up being able to touch from multiple threads:\r\n\r\n```rust\r\n#[SubgroupVisible]\r\n#[WorkgroupVisible]\r\n#[DeviceVisible]\r\n```\r\n\r\nEach of these attributes modifies what happens during borrow and drop, and memory semantics used for OpLoad/OpStore when accessing references to these structs.\r\n\r\nNote: **If none of these attributes are present it should be a compiler error to borrow a mutable reference from the struct**, (unless the code is declared unsafe?).\r\n\r\n## Scope\r\n\r\nThe word before \"Visible\" in the attribute determines the scope at which writes to the structure are made visible to other shader invocations.\r\nSo \"SubgroupVisible\" indicates that other invocations in the same subgroup can see values written by other invocations, assuming correct synchronization.\r\nThis scope is used as the `%scope` operand for the instructions detailed below.\r\n\r\n## Acquire on Borrow\r\n\r\nWhen a reference is borrowed from the structure, an [OpMemoryBarrier](https://www.khronos.org/registry/spir-v/specs/unified1/SPIRV.html#OpMemoryBarrier) should be performed as follows:\r\n\r\n```spir-v\r\nOpMemoryBarrier %scope Acquire|%storage_class\r\n```\r\n\r\n## Release on Drop\r\n\r\nWhen a reference to the structure is dropped, an [OpMemoryBarrier](https://www.khronos.org/registry/spir-v/specs/unified1/SPIRV.html#OpMemoryBarrier) should be performed as follows:\r\n\r\n```spir-v\r\nOpMemoryBarrier %scope Release|%storage_class\r\n```\r\n\r\n## Loads\r\n\r\nWhen a reference to the structure is read from, an [OpLoad](https://www.khronos.org/registry/spir-v/specs/unified1/SPIRV.html#OpLoad) should be generated with the following [Memory Operands](https://www.khronos.org/registry/spir-v/specs/unified1/SPIRV.html#OpStore): \r\n\r\n```spir-v\r\n%value = OpLoad %pointer MakePointerVisible|NonPrivatePointer %scope\r\n```\r\n\r\nor similarly for images:\r\n\r\n```spir-v\r\n%value = OpImageRead ... MakeTexelVisible|NonPrivateTexel %scope\r\n```\r\n\r\n## Stores\r\n\r\nWhen a reference to the structure is written to, an [OpStore](https://www.khronos.org/registry/spir-v/specs/unified1/SPIRV.html#OpStore) should be generated with the following [Memory Operands](https://www.khronos.org/registry/spir-v/specs/unified1/SPIRV.html#Memory_Operands):\r\n\r\n```spir-v\r\nOpStore %pointer %value MakePointerAvailable|NonPrivatePointer %scope\r\n```\r\n\r\nor similarly for images:\r\n\r\n```spir-v\r\nOpImageWrite ... MakeTexelAvailable|NonPrivateTexel %scope\r\n```\r\n",
        "createdAt": "2020-10-23T13:46:29Z",
        "includesCreatedEdit": true,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/8#issuecomment-715351603",
        "viewerDidAuthor": false
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDcxNjM5Mjk1OQ==",
        "author": {
          "login": "khyperia"
        },
        "authorAssociation": "CONTRIBUTOR",
        "body": "A couple issues:\r\n\r\n1) AFAIK, there is no way to tell in the backend when a borrow starts/stops, and so we cannot emit code at those points.\r\n2) How do you intend to deal with `OpAccessChain` to a field on the struct? All attributes for the resulting pointer would be dropped, and we would no longer be able to emit the proper memory operands for load/store.",
        "createdAt": "2020-10-26T08:26:47Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/8#issuecomment-716392959",
        "viewerDidAuthor": false
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDcxNjUxNjM1MA==",
        "author": {
          "login": "Tobski"
        },
        "authorAssociation": "NONE",
        "body": "@khyperia Thanks for looking at this!\r\n\r\n> AFAIK, there is no way to tell in the backend when a borrow starts/stops, and so we cannot emit code at those points.\r\n\r\nMy understanding is that it's possible to override borrow/drop in the language itself, rather than in the backend, so I was imagining this be dealt with at least partially _above_ the compiler; perhaps emitting some sort of intrinsic that the backend would turn into the right memory barriers. I was experimenting with this on the rust playground and made some decent progress in getting a struct in regular rust to output something (println! with the relevant instruction) at borrow/drop, but like a fool I hadn't saved it locally and lost it all when my browser tab crashed ü§¶‚Äç‚ôÄÔ∏è\r\n\r\n> How do you intend to deal with OpAccessChain to a field on the struct? All attributes for the resulting pointer would be dropped, and we would no longer be able to emit the proper memory operands for load/store.\r\n\r\nOk so again I'm not necessarily expecting this to be a wholly backend issue. My hope here is that we can coax the front-end into tagging the variables (and/or the variable accesses), such that when it gets to the backend all you'd need to do is check if a relevant tag is there or not. Unlike the first issue you pointed out, I don't have a handle on how this might be done with rust's attribute system yet - so this is kind of an open issue that I'm hoping we can have more discussion on.",
        "createdAt": "2020-10-26T12:32:00Z",
        "includesCreatedEdit": true,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/8#issuecomment-716516350",
        "viewerDidAuthor": false
      },
      {
        "id": "MDEyOklzc3VlQ29tbWVudDcxNzM5ODEwMQ==",
        "author": {
          "login": "Tobski"
        },
        "authorAssociation": "NONE",
        "body": "So I've been thinking about the implementation complexity, and given the newness of this project and that it's probably useful to bootstrap this in the short term, maybe there should be two phases to this? The initial phase will have dedicated acquire/release and load/store ops, and then the more complex/ergonomic thing here can be a future investigation? Unless anyone thinks that's a terrible idea I'll write this into the draft RFC I'm working on.",
        "createdAt": "2020-10-27T17:20:36Z",
        "includesCreatedEdit": false,
        "isMinimized": false,
        "minimizedReason": "",
        "reactionGroups": [
          {
            "content": "THUMBS_UP",
            "users": {
              "totalCount": 1
            }
          }
        ],
        "url": "https://github.com/EmbarkStudios/rust-gpu/issues/8#issuecomment-717398101",
        "viewerDidAuthor": false
      }
    ],
    "createdAt": "2020-08-18T17:33:10Z",
    "labels": [
      {
        "id": "MDU6TGFiZWwyMjg0ODcxMDQ1",
        "name": "t: design",
        "description": "Design of our rust-gpu language and std",
        "color": "52E8A0"
      }
    ],
    "number": 8,
    "reactionGroups": [],
    "state": "OPEN",
    "title": "Language feature: barriers",
    "url": "https://github.com/EmbarkStudios/rust-gpu/issues/8"
  }
]
